<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ruvikm</title>
  <icon>https://www.gravatar.com/avatar/710ecfc7f4f0bd22cb3d5ec44d498105</icon>
  <subtitle>Nia~</subtitle>
  <link href="https://ruvikm.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://ruvikm.gitee.io/"/>
  <updated>2023-12-15T10:20:30.849Z</updated>
  <id>https://ruvikm.gitee.io/</id>
  
  <author>
    <name>Ruvikm</name>
    <email>ruvikm@126.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>建立一个简易的TCP客户端与服务端</title>
    <link href="https://ruvikm.gitee.io/2023/12/15/%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    <id>https://ruvikm.gitee.io/2023/12/15/%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF/</id>
    <published>2023-12-15T10:19:52.000Z</published>
    <updated>2023-12-15T10:20:30.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a>TCP服务端</h2><p>分为一下六步：</p><ol><li>建立一个socket 套接字</li><li>bind 绑定用于接受客户端连接的网络接口</li><li>listen 监听网络端口</li><li>accept 等待接受客户端连接</li><li>send 向客户端发送一条数据</li><li>关闭套接字closesocket</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//只有在WIN里可以</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//启动Windows socket 2.x环境</span></span><br><span class="line">WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA dat;</span><br><span class="line"><span class="built_in">WSAStartup</span>(ver, &amp;dat);</span><br><span class="line"><span class="comment">// 用Socket API 建立一个简易的TCP服务端</span></span><br><span class="line"><span class="comment">// 1 建立一个socket 套接字</span></span><br><span class="line">SOCKET _sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="comment">// 2 bind 绑定用于接受客户端连接的网络接口</span></span><br><span class="line">sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">_sin.sin_family = AF_INET;</span><br><span class="line">_sin.sin_port = <span class="built_in">htons</span>(<span class="number">4567</span>);<span class="comment">// host to net unsigned short</span></span><br><span class="line">_sin.sin_addr.S_un.S_addr = INADDR_ANY;<span class="comment">//inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(_sock, (sockaddr*)&amp;_sin, <span class="built_in">sizeof</span>(_sin)) == SOCKET_ERROR) &#123;</span><br><span class="line"><span class="comment">//绑定错误</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;绑定网络端口失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;绑定网络端口成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 listen 监听网络端口</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">listen</span>(_sock, <span class="number">5</span>)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;监听网络端口失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;监听网络端口成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4 accept 等待接受客户端连接</span></span><br><span class="line">sockaddr_in clientAddr = &#123;&#125;;</span><br><span class="line"><span class="type">int</span> nAddrLen = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line">SOCKET _cSock = INVALID_SOCKET;</span><br><span class="line"><span class="type">char</span> msgBuf[] = <span class="string">&quot;Hello ,I&#x27;m Server.&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">_cSock = <span class="built_in">accept</span>(_sock, (sockaddr*)&amp;clientAddr, &amp;nAddrLen);</span><br><span class="line"><span class="keyword">if</span> (_cSock == INVALID_SOCKET) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;接受到无效客户端SOCKET...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;新客户端加入：IP =&quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr) &lt;&lt; endl;</span><br><span class="line"><span class="comment">//5 send 向客户端发送一条数据</span></span><br><span class="line"><span class="built_in">send</span>(_cSock, msgBuf, <span class="built_in">strlen</span>(msgBuf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6 关闭套接字closesocket</span></span><br><span class="line"><span class="built_in">closesocket</span>(_sock);</span><br><span class="line"><span class="comment">//7 清除windows socket环境</span></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="comment">//保留界面</span></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP服务端-1"><a href="#TCP服务端-1" class="headerlink" title="TCP服务端"></a>TCP服务端</h2><p>分为四步：</p><ol><li>建立一个socket</li><li>连接服务器 connect</li><li>接受服务器信息 recv</li><li>关闭套接字closesocket</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//只有在WIN里可以</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//启动Windows socket 2.x环境</span></span><br><span class="line">WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA dat;</span><br><span class="line"><span class="built_in">WSAStartup</span>(ver, &amp;dat);</span><br><span class="line"><span class="comment">// 用Socket API 建立一个简易的TCP服务端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 建立一个socket</span></span><br><span class="line">SOCKET _sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == _sock) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;建立Socket失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;建立Socket成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 连接服务器 connect</span></span><br><span class="line">sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">_sin.sin_family = AF_INET;</span><br><span class="line">_sin.sin_port = <span class="built_in">htons</span>(<span class="number">4567</span>);</span><br><span class="line">_sin.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">connect</span>(_sock, (sockaddr*)&amp;_sin, <span class="built_in">sizeof</span>(sockaddr_in));</span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == ret) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;连接Socket失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;连接Socket成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 接受服务器信息 recv</span></span><br><span class="line"><span class="type">char</span> recvBuf[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line"><span class="type">int</span> nlen = <span class="built_in">recv</span>(_sock, recvBuf, <span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (nlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;接收到数据为：&quot;</span> &lt;&lt; recvBuf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4 关闭套接字closesocket</span></span><br><span class="line"><span class="built_in">closesocket</span>(_sock);</span><br><span class="line"><span class="comment">// 5 清除windows socket环境</span></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="comment">//保留界面</span></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><strong>服务端</strong></p><p><img src="/2023/12/15/%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF/pi41BFK.png" alt="屏幕截图 2023-12-15 181558"></p><p><strong>客户端</strong></p><p><img src="/2023/12/15/%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF/pi41DJO.png" alt="屏幕截图 2023-12-15 181602"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TCP服务端&quot;&gt;&lt;a href=&quot;#TCP服务端&quot; class=&quot;headerlink&quot; title=&quot;TCP服务端&quot;&gt;&lt;/a&gt;TCP服务端&lt;/h2&gt;&lt;p&gt;分为一下六步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立一个socket 套接字&lt;/li&gt;
&lt;li&gt;bind 绑定用于</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://ruvikm.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JZ22 链表中倒数最后k个结点</title>
    <link href="https://ruvikm.gitee.io/2023/11/20/JZ22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8Ek%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://ruvikm.gitee.io/2023/11/20/JZ22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8Ek%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2023-11-20T08:08:47.000Z</published>
    <updated>2023-11-20T15:19:06.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>输入一个长度为 n 的链表，设链表中的元素的值为 a_i ，返回该链表中倒数第k个节点。</p><p>如果该链表长度小于k，请返回一个长度为 0 的链表。</p><p>数据范围：</p><script type="math/tex; mode=display">0 \leq n \leq 10^5,0 \leq a_i \leq 10^9,0 \leq k \leq 10^9</script><p>要求：空间复杂度 <em>O</em>(n)，时间复杂度 O<em>(</em>n)</p><p>进阶：空间复杂度O(1)，时间复杂度 O(n)</p><p>例如输入{1,2,3,4,5},2时，对应的链表结构如下图所示：</p><p><img src="https://z1.ax1x.com/2023/11/20/piap43j.png" alt="img"></p><p>其中蓝色部分为该链表的最后2个结点，所以返回倒数第2个结点（也即结点值为4的结点）即可，系统会打印后面所有的节点来比较。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">&#123;1,2,3,4,5&#125;,2</span><br><span class="line">返回值：</span><br><span class="line">&#123;4,5&#125;</span><br><span class="line">说明：</span><br><span class="line">返回倒数第2个节点4，系统会打印后面所有的节点来比较。 </span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">&#123;2&#125;,8</span><br><span class="line">返回值：</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>首先求出链表的长度<code>n</code>，从题目的倒数第<code>k</code>个结点，推出是正数的第<code>n - k</code>个结点。若<code>n - k &lt; 0</code>，则返回空值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param pHead ListNode类</span></span><br><span class="line"><span class="comment">     * @param k int整型</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pHead, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode* p = pHead;</span><br><span class="line">        <span class="keyword">for</span> (; p != <span class="literal">nullptr</span>; p = p-&gt;next, len++);</span><br><span class="line">        <span class="type">int</span> step = len - k;</span><br><span class="line">        <span class="keyword">if</span> (step &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (step--) &#123;</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>用一个栈处理，由于栈是后进先出的，所以正好符合题意的倒数。倒数第k个结点就意味着栈需要弹出k次即可。</p><p>这里有一个细节，栈都弹完了，k还是大于等于0的，则应该返回空值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param pHead ListNode类</span></span><br><span class="line"><span class="comment">     * @param k int整型</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pHead, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        stack&lt;ListNode*&gt; st;</span><br><span class="line">        ListNode* res;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(pHead);</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (k-- &amp;&amp; !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;输入一个长度为 n 的链表，设链表中的元素的值为 a_i ，返回该链表中倒数第k个节点。&lt;/p&gt;
&lt;p&gt;如果该链表长度小于k，请返回一个长度</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>jz23 链表中环的入口结点</title>
    <link href="https://ruvikm.gitee.io/2023/11/20/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/"/>
    <id>https://ruvikm.gitee.io/2023/11/20/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/</id>
    <published>2023-11-20T02:33:18.000Z</published>
    <updated>2023-11-20T07:26:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。</p><p>数据范围： n≤10000，1&lt;=结点值&lt;=10000</p><p>要求：空间复杂度 O<em>(1)，时间复杂度 O</em>(<em>n</em>)</p><p>例如，输入{1,2},{3,4,5}时，对应的环形链表如下图所示：</p><p><img src="https://z1.ax1x.com/2023/11/20/piU6lqS.png" alt="img"></p><p>可以看到环的入口结点的结点值为3，所以返回结点值为3的结点。</p><h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>输入分为2段，第一段是入环前的链表部分，第二段是链表环的部分，后台会根据第二段是否为空将这两段组装成一个无环或者有环单链表</p><h3 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h3><p>返回链表的环的入口结点即可，我们后台程序会打印这个结点对应的结点值；若没有，则返回对应编程语言的空结点即可。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2&#125;,&#123;3,4,5&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回环形链表入口结点，我们后台程序会打印该环形链表入口结点对应的结点值，即3   </span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1&#125;,&#123;&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;null&quot;</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">没有环，返回对应编程语言的空结点，后台程序会打印&quot;null&quot;   </span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;,&#123;2&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环的部分只有一个结点，所以返回该环形链表入口结点，后台程序打印该结点对应的结点值，即2 </span><br></pre></td></tr></table></figure><h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>如果不考虑空间复杂度，可以使用一个大小为10000的数组<code>a</code>存放各个结点的值，每当遍历到一个节点V的时候，就把<code>a[v-val]++</code></p><p>因为存在换，所以当第一个<code>a[v-val] == 2</code>的时候，即为环的入口结点</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vt</span><span class="params">(<span class="number">10000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(pHead != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            vt[pHead-&gt;val]++;</span><br><span class="line">            <span class="keyword">if</span>(vt[pHead-&gt;val] == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>可以使用快慢指针，快指针<code>fast</code>每次走两步，慢指针<code>slow</code>每次走一步。这样如果有环存在的话，在环中，快慢指针的距离，每移动一次距离就会减一，这样如果它们相遇的话，就一定可以判断链表中有没有环。</p><p>那么如何判断环的入口点是在哪里呢？我们假设环前面的节点有a个，环中的节点有b个，慢指针走的长度为S_dis</p><p>快指针走的路线为F_dis。当两个指针相遇时，依据题意可以等于以下两个等式</p><script type="math/tex; mode=display">F_{dis} = 2  S_{dis}(因为快指针每次走的步数是慢指针的两倍)</script><script type="math/tex; mode=display">F_{dis} = a + nb(当两者相遇时，快指针一定已经绕环走了n圈)</script><p>联立可得</p><script type="math/tex; mode=display">2  S_{dis} = a + nb</script><p>可以得出</p><script type="math/tex; mode=display">a = S_{dis} = nb</script><script type="math/tex; mode=display">F_{dis} = 2nb</script><p>所以当两个指针相遇的时候，将快指针移到链表头部重新往后走，这次一次走一步。慢指针保持原来的位置，继续向后走，也是一次走一步，当两个指针相遇的时候，即是环的入口处。（这时候快指针刚好走完<code>a = nb</code>的长度到达环的入口处）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = pHead;</span><br><span class="line">        ListNode* fast = pHead;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = slow -&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">//如果指向空就说明没有环</span></span><br><span class="line">            <span class="keyword">if</span> (slow == <span class="literal">nullptr</span> || fast == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。&lt;/p&gt;
&lt;p&gt;数据范围： n≤10000，1&amp;lt;=结</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JZ52 两个链表的第一个公共结点</title>
    <link href="https://ruvikm.gitee.io/2023/11/19/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/"/>
    <id>https://ruvikm.gitee.io/2023/11/19/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/</id>
    <published>2023-11-19T11:13:13.000Z</published>
    <updated>2023-11-19T13:01:02.734Z</updated>
    
    <content type="html"><![CDATA[<p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p><p>数据范围： n≤1000<br>要求：空间复杂度 O<em>(1)，时间复杂度 )</em>O<em>(</em>n)</p><p>例如，输入{1,2,3},{4,5},{6,7}时，两个无环的单向链表的结构如下图所示：</p><p><img src="https://z1.ax1x.com/2023/11/19/piUE2Pf.png" alt="img"></p><p>可以看到它们的第一个公共结点的结点值为6，所以返回结点值为6的结点。</p><h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>输入分为是3段，第一段是第一个链表的非公共部分，第二段是第二个链表的非公共部分，第三段是第一个链表和第二个链表的公共部分。 后台会将这3个参数组装为两个链表，并将这两个链表对应的头节点传入到函数FindFirstCommonNode里面，用户得到的输入只有pHead1和pHead2。</p><h3 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h3><p>返回传入的pHead1和pHead2的第一个公共结点，后台会打印以该节点为头节点的链表。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;6,7&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一个参数&#123;1,2,3&#125;代表是第一个链表非公共部分，第二个参数&#123;4,5&#125;代表是第二个链表非公共部分，最后的&#123;6,7&#125;表示的是2个链表的公共部分</span><br><span class="line">这3个参数最后在后台会组装成为2个两个无环的单链表，且是有公共节点的          </span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1&#125;,&#123;2,3&#125;,&#123;&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2个链表没有公共节点 ,返回null，后台打印&#123;&#125;       </span><br></pre></td></tr></table></figure><h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>首先先求出两个链表的长度，让长度长一点的指针先往前走几步（走的步数 = 两链表长度差），然后让两个指针分别指向两个链表，当两个指针相等的时候几个返回当前指向的结点</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span> || pHead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> len1 = <span class="number">0</span>, len2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ListNode* p = pHead1; p != <span class="literal">nullptr</span>; p = p-&gt;next, len1++);</span><br><span class="line">        <span class="keyword">for</span> (ListNode* p = pHead2; p != <span class="literal">nullptr</span>; p = p-&gt;next, len2++);</span><br><span class="line">        <span class="type">int</span> step = <span class="built_in">abs</span>(len2 - len1);</span><br><span class="line"><span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line"><span class="keyword">while</span>(step--)&#123;</span><br><span class="line">pHead1 = pHead1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(step--)&#123;</span><br><span class="line">pHead2 = pHead2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(pHead1 != pHead2)&#123;</span><br><span class="line">pHead1 = pHead1-&gt;next;</span><br><span class="line">pHead2 = pHead2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> pHead1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>用两个指针分别指向两个链表，让其循环移动，当指向同一个结点的时候即为公共结点</p><p><img src="https://z1.ax1x.com/2023/11/19/piUES4f.png" alt="微信图片_20231119204317"></p><p>也就是说，当指针1走完{1,2,3,6,7}的时候，让它指向{4,5}。同理，当指针2走完{4,5,6,7}的时候，让它指向{1,2,3}</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="literal">nullptr</span> ||pHead2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">ListNode * H1 = pHead1, * H2 = pHead2;</span><br><span class="line"><span class="keyword">while</span>(H1 != H2)&#123;</span><br><span class="line">H1 = (H1 == <span class="literal">nullptr</span>) ? pHead2 : H1-&gt;next;</span><br><span class="line">H2 = (H2 == <span class="literal">nullptr</span>) ? pHead1 : H2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> H1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）&lt;/p&gt;
&lt;p&gt;数据范围： n≤1000&lt;br&gt;要求：空间复杂度 O&lt;em&gt;(1)，时间复杂度 )&lt;/em&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>jz25 合并两个排序的链表</title>
    <link href="https://ruvikm.gitee.io/2023/11/18/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>https://ruvikm.gitee.io/2023/11/18/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2023-11-18T02:35:51.000Z</published>
    <updated>2023-11-19T13:00:46.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p>数据范围： 0≤10000≤<em>n</em>≤1000，−1000≤节点值≤1000−1000≤节点值≤1000<br>要求：空间复杂度 <em>O</em>(1)，时间复杂度 <em>O</em>(<em>n</em>)</p><p>如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6}，转换过程如下图所示：</p><p><img src="https://z1.ax1x.com/2023/11/19/piUEyVI.png" alt="09DD8C2662B96CE14928333F055C5580"></p><p>或输入{-1,2,4},{1,3,4}时，合并后的链表为{-1,1,2,3,4,4}，所以对应的输出为{-1,1,2,3,4,4}，转换过程如下图所示：</p><p><img src="https://z1.ax1x.com/2023/11/19/piUE6at.png" alt="8266E4BFEDA1BD42D8F9794EB4EA0A13"></p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,3,5&#125;,&#123;2,4,6&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3,4,5,6&#125;</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;,&#123;&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;-1,2,4&#125;,&#123;1,3,4&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;-1,1,2,3,4,4&#125;</span><br></pre></td></tr></table></figure><h1 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h1><p>可以使用虚拟头结点，可以再新建一个链表，然后把两个链表的结点从小到大依次插入到新链表中即可。使用双指针分别指向两个链表，然后每次将较小的结点放在虚拟头结点后面，然后指针（刚刚较小的）放后移动，另一个指针不动</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param pHead1 ListNode类</span></span><br><span class="line"><span class="comment">     * @param pHead2 ListNode类</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span> (pHead2 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        ListNode* p = pHead2, *q = pHead1;</span><br><span class="line">        ListNode* newHead;</span><br><span class="line">        newHead = p-&gt;val &lt;= q-&gt;val ? p : q;</span><br><span class="line">        ListNode *res = newHead;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt;= q-&gt;val) &#123;</span><br><span class="line">                ListNode* tmp = p-&gt;next;</span><br><span class="line">                ListNode* node = p;</span><br><span class="line">                newHead-&gt;next = node;</span><br><span class="line">                newHead = node;</span><br><span class="line">                p = tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ListNode* tmp = q-&gt;next;</span><br><span class="line">                ListNode* node = q;</span><br><span class="line">                newHead-&gt;next = node;</span><br><span class="line">                newHead = node;</span><br><span class="line">                q = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            newHead-&gt;next = p;</span><br><span class="line">            newHead = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            newHead-&gt;next = q;</span><br><span class="line">            newHead = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本来打算将一个链表插入到另一个链表之中的，但是太复杂了，一直没有AC</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。&lt;/p&gt;
&lt;p&gt;数据范围： 0≤10000≤&lt;em</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JZ24 反转链表</title>
    <link href="https://ruvikm.gitee.io/2023/11/16/JZ24%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://ruvikm.gitee.io/2023/11/16/JZ24%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2023-11-16T10:48:55.000Z</published>
    <updated>2023-11-19T12:58:52.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个单链表的头结点<code>pHead</code>(该头节点是有值的，比如在下图，它的<code>val</code>是1)，长度为n，反转该链表后，返回新链表的表头。</p><p>数据范围： 0≤10000≤<em>n</em>≤1000</p><p>要求：空间复杂度 O<em>(1) ，时间复杂度 O</em>(<em>n</em>) 。</p><p>如当输入链表{1,2,3}时，</p><p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。</p><p>以上转换过程如下图所示：</p><p><img src="https://z1.ax1x.com/2023/11/19/piUEBKH.png" alt="4A47A0DB6E60853DEDFCFDF08A5CA249"></p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;3,2,1&#125;</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空链表则输出空                 </span><br></pre></td></tr></table></figure><h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>使用栈当做中转站，把每个节点倒过来，然后重新拼成一个新链表</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param head ListNode类</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        stack&lt;ListNode*&gt; st;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tail = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        ListNode* res = tail;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ListNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            tail-&gt;next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后的节点为原来的头结点，需要将其的下一个节点设为空，否则会构成环</span></span><br><span class="line">        tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://z1.ax1x.com/2023/11/16/pit8EWR.png" alt="构成环"></p><p><strong>题目细节</strong></p><p>结点3为<code>tail</code>变量，经过<code>while</code>循环，会使用尾插法将结点1和2都插入到3后面，这期间，结点2和3和<code>next</code>指针都经过了处理，而最后一个结点1的<code>next</code>指针（结点1的<code>next</code>原本是指向结点2的）却没有处理，因为此时已经跳出了<code>while</code>循环。如果不将结点1的下一个结点置为空，则会在结点1和2之间形成环，程序输出会如下：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">3,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...</span><br></pre></td></tr></table></figure><h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>使用两个结点求解，将摘下来的每一个结点使用头插法插入到新的链表中，如图画了程序两步的情况</p><p><img src="https://z1.ax1x.com/2023/11/17/pit5oeP.png" alt="反转链表"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *int val;</span></span><br><span class="line"><span class="comment"> *struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ListNode* newHead = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* tmp = head-&gt;next;</span><br><span class="line">            head-&gt;next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>扩展思维</strong></p><p>其实用<code>vector</code>容器顺序存放各个结点，然后出来的时候使用头插法新建链表也可以，这样分离结点的时候可能不太容易出错</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param head ListNode类</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        vector&lt;ListNode*&gt; vt;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">//分离结点</span></span><br><span class="line">            ListNode* tmp = head-&gt;next;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            vt.<span class="built_in">push_back</span>(head);</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新建链表</span></span><br><span class="line">        ListNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node : vt) &#123;</span><br><span class="line">            node-&gt;next = res;</span><br><span class="line">            res = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样也可以不使用<code>vector</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param head ListNode类</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* tmp = head-&gt;next;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            ListNode* node = head;</span><br><span class="line"></span><br><span class="line">            node-&gt;next = res;</span><br><span class="line">            res = node;</span><br><span class="line"></span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>tip：之前头插法一直记错了，如果头结点没有数据的话，可以使用下面的操作</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">node-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = node;</span><br></pre></td></tr></table></figure><p>但是如果头结点有值，就要用下列的插入</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">node-&gt;next = head；</span><br><span class="line">head = node;</span><br></pre></td></tr></table></figure><h2 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h2><p>原地反转，用三个指针逆置</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *int val;</span></span><br><span class="line"><span class="comment"> *struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ListNode* p = head-&gt;next, *pre = head;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//第一个结点的next指针要预先处理，循环只能处理后面结点的next指针</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* tmp = p-&gt;next;</span><br><span class="line">            <span class="comment">//反转</span></span><br><span class="line">            p-&gt;next = pre;</span><br><span class="line"></span><br><span class="line">            pre = p;</span><br><span class="line">            p = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法4"><a href="#解法4" class="headerlink" title="解法4"></a>解法4</h2><p>使用递归解决</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param head ListNode类</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* cur_next = head-&gt;next;</span><br><span class="line">        ListNode* newHead = <span class="built_in">ReverseList</span>(cur_next);</span><br><span class="line">        cur_next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;给定一个单链表的头结点&lt;code&gt;pHead&lt;/code&gt;(该头节点是有值的，比如在下图，它的&lt;code&gt;val&lt;/code&gt;是1)，长度为</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://ruvikm.gitee.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>JZ6 从尾到头打印链表</title>
    <link href="https://ruvikm.gitee.io/2023/11/15/JZ6%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://ruvikm.gitee.io/2023/11/15/JZ6%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</id>
    <published>2023-11-15T12:15:13.000Z</published>
    <updated>2023-11-19T12:58:04.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</p><p>如输入{1,2,3}的链表如下图:</p><p><img src="https://z1.ax1x.com/2023/11/19/piUE8bR.png" alt="103D87B58E565E87DEFA9DD0B822C55F"></p><p>返回一个数组为[3,2,1]</p><p>0 &lt;= 链表长度 &lt;= 10000</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[3,2,1]</span><br></pre></td></tr></table></figure><h2 id="算法思路1"><a href="#算法思路1" class="headerlink" title="算法思路1"></a>算法思路1</h2><p>主要考察翻转数组的操作，把链表的数据放到数组里，然后在数组里操作，一个比较简单的操作是调用C++的库函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vt;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            vt.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(vt.<span class="built_in">begin</span>(),vt.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> vt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="算法思路2"><a href="#算法思路2" class="headerlink" title="算法思路2"></a>算法思路2</h2><p>使用递归的方式解决，递归出口是链表循环到末尾，每次递归做的事就是把当前结点的值放到<code>vector</code>容器中，由于递归到末尾才会开始存放结点（<code>res.push_back(head-&gt;val);</code>）的值，时间顺序正好为从后往前的存放，符合题目要求的逆序</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(ListNode* head,vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">reverse</span>(head-&gt;next,res);</span><br><span class="line">            res.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">reverse</span>(head,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。&lt;/p&gt;
&lt;p&gt;如输入{1,2,3}的链表如下图:&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://ruvikm.gitee.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Win11配置多个CUDA环境</title>
    <link href="https://ruvikm.gitee.io/2023/09/30/Win11%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AACUDA%E7%8E%AF%E5%A2%83/"/>
    <id>https://ruvikm.gitee.io/2023/09/30/Win11%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AACUDA%E7%8E%AF%E5%A2%83/</id>
    <published>2023-09-30T01:25:18.000Z</published>
    <updated>2023-09-30T04:13:35.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>由于跑项目发现需要配置不同版本的Pytorch，而不同版本的Pytorch又对应不同版本的CUDA，于是有了在Win上装多个CUDA的打算</p><p>默认已经在电脑上装了一个CUDA</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqY5Bd.png" alt="屏幕截图 2023-09-30 112423"></p><p>现在开始下载第二个CUDA版本，前面下载的操作和普通安装的几乎一样</p><h2 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h2><p><a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA下载链接</a></p><p>下载自己需要的CUDA版本，以我自己要安装的为例</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqlwXn.png" alt="屏幕截图 2023-09-30 095614"></p><p><img src="https://z1.ax1x.com/2023/09/30/pPqlD00.png" alt="屏幕截图 2023-09-30 095815"></p><p>下载打开exe文件进行安装，第一步不用管，直接点击确认</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqlWc9.png" alt="屏幕截图 2023-09-30 100402"></p><p>后面选择自定义安装，只选择安装CUDA</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqlfXR.png" alt="屏幕截图 2023-09-30 100534"></p><p>其他一路下一步就可以了</p><h2 id="安装cuDNN"><a href="#安装cuDNN" class="headerlink" title="安装cuDNN"></a>安装cuDNN</h2><p><a href="https://developer.nvidia.com/rdp/cudnn-archive">cuDNN下载链接</a></p><p>PS：下载需要登录一下账号</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqlchF.png" alt="屏幕截图 2023-09-30 100047"></p><p>下载下来后，把压缩包解压，得到如下文件</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqlq9e.png" alt="image-20230930100746137"></p><p>将<strong>bin，include文件夹中的文件</strong>，分别复制到下列地址对应的文件夹下（CUDA的安装地址，以我的地址为例），遇到提示，为全部选择覆盖和替换。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.7</span><br></pre></td></tr></table></figure><p>需要注意的是，lib文件夹里的所有文件，需要复制到</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.7\lib\x64</span><br></pre></td></tr></table></figure><p>至此，安装工作就做完了，可以看到电脑上已经有两个CUDA版本了</p><p><img src="https://z1.ax1x.com/2023/09/30/pPq3dZq.png" alt="image-20230930101157014"></p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>由于CUDA11.7是后面安装的，所以可以看到系统把之前的环境覆盖了</p><p><img src="https://z1.ax1x.com/2023/09/30/pPq3rJU.png" alt="屏幕截图 2023-09-30 103109"></p><p>以作者在为例，系统变量的PATH里配置一下路径</p><p><strong>CUDA_11.7</strong></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%CUDA_PATH_V11_7%\lib\x64</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_7%\include</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_7%\extras\CUPTI\lib64</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_7%\bin</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_7%\libnvvp</span></span><br></pre></td></tr></table></figure><p><strong>CUDA_11.0</strong></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%CUDA_PATH_V11_0%\lib\x64</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_0%\include</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_0%\extras\CUPTI\lib64</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_0%\bin</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_0%\libnvvp</span></span><br></pre></td></tr></table></figure><p>配置好如下：</p><p><img src="https://z1.ax1x.com/2023/09/30/pPq3yz4.jpg" alt="微信截图_20230930105036"></p><p>配置好之后，默认CUDA版本是11.7的，如果要切换到11.0版本的，只需要把下面的五条整体上移到CUDA_11.7配置的前面</p><p><img src="https://z1.ax1x.com/2023/09/30/pPq3cQJ.jpg" alt="微信截图_20230930105411"></p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="测试CUDA11-7"><a href="#测试CUDA11-7" class="headerlink" title="测试CUDA11.7"></a>测试CUDA11.7</h3><p>首先验证CUDA_11.7是否配置成功</p><p><img src="https://z1.ax1x.com/2023/09/30/pPq8upF.png" alt="image-20230930105601201"></p><p>测试Pytorch是否可以调用显卡</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.cuda.is_available()</span><br><span class="line">torch.cuda.get_device_name(<span class="number">0</span>)</span><br><span class="line">torch.version.cuda</span><br></pre></td></tr></table></figure><p><img src="https://z1.ax1x.com/2023/09/30/pPqYiOH.png" alt="image-20230930120418607"></p><h3 id="测试CUDA11-0"><a href="#测试CUDA11-0" class="headerlink" title="测试CUDA11.0"></a>测试CUDA11.0</h3><p>先把系统变量里Path里相关路径上移</p><p><img src="https://z1.ax1x.com/2023/09/30/pPq8ZkV.jpg" alt="微信截图_20230930110409"></p><p><strong>然后重启！重启！重启！</strong></p><p>验证CUDA_11.7是否配置成功</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqGkge.png" alt="image-20230930112425329"></p><p>测试Pytorch是否可以调用显卡</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqYkmd.png" alt="image-20230930112626663"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>切换CUDA的时候除了要修改系统变量Path中的路径顺序，一定要记得重启！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;由于跑项目发现需要配置不同版本的Pytorch，而不同版本的Pytorch又对应不同版本的CUDA，于是有了在Win上装多个CUDA的打算&lt;</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>学校GPU平台使用教程</title>
    <link href="https://ruvikm.gitee.io/2023/08/28/%E5%AD%A6%E6%A0%A1GPU%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://ruvikm.gitee.io/2023/08/28/%E5%AD%A6%E6%A0%A1GPU%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2023-08-28T01:18:54.000Z</published>
    <updated>2023-10-19T10:26:46.596Z</updated>
    
    <content type="html"><![CDATA[<p>首先连接内网登录<a href="http://paas.183-175-12-11.nip.io:30080/">平台</a></p><p>一般使用的话，直接找到<code>开发环境</code>一栏，创建环境。然后通过<code>Pycharm</code>中的<code>ssh</code>连接</p><p><img src="https://s1.ax1x.com/2023/08/28/pPaw2X6.png" alt="屏幕截图 2023-08-28 221321"></p><p>在<code>Pycharm</code>中，找到工具—部署—配置</p><p><img src="https://s1.ax1x.com/2023/08/28/pPad5zq.png" alt="image-20230828220300678"></p><p>点击<code>+</code>后选择<code>SFTP</code></p><p><img src="https://s1.ax1x.com/2023/08/28/pPaw5Ae.png" alt="屏幕截图 2023-08-28 221526"></p><p>在<code>SSH配置</code>那里后点击后面<code>...</code></p><p><img src="https://s1.ax1x.com/2023/08/28/pPawbct.png" alt="屏幕截图 2023-08-28 092517"></p><p>进入后填写主机名和用户名，这里详细讲一下</p><p>例如平台给的ssh连接是</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ssh://root@paas.xxx-xxx-xx-xx.nip.io:xxxxx</span><br></pre></td></tr></table></figure><p>这里用户名就需要填写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root</span><br></pre></td></tr></table></figure><p>主机名填写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">paas.xxx-xxx-xx-xx.nip.io</span><br></pre></td></tr></table></figure><p>端口号填写<code>xxxxx</code></p><p>然后填写创建环境时设置的密码</p><p><img src="https://s1.ax1x.com/2023/08/28/pPawjHS.png" alt="屏幕截图 2023-08-28 092917"></p><p>这一步完事以后，点击确定，返回到之前的页面，点击<code>映射</code></p><p><img src="https://s1.ax1x.com/2023/08/30/pPd7RaD.png" alt="屏幕截图 2023-08-30 145658"></p><p>配置好本机的地址和远程的地址，点击确认</p><p><img src="https://s1.ax1x.com/2023/08/30/pPd7LdS.png" alt="image-20230830145937224"></p><p>之后选择工具—部署—选项</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdHIkF.png" alt="QQ截图20230830150656"></p><p>可以根据自己习惯决定是否配置一下</p><p>然后找到工具—启动SSH会话，选择刚刚配置的SSH</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdbmtg.png" alt="屏幕截图 2023-08-30 151730"></p><p>然后输入</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.executable)</span><br></pre></td></tr></table></figure><p>记住输出的地址，比如我的就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usr/bin/python</span><br></pre></td></tr></table></figure><p>最后，找到项目—项目XXXX—Python解释器，找到添加解释器—SSH</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdHj0K.png" alt="image-20230830151124394"></p><p>选择刚刚配置的SSH服务器，然后下一步</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdbHUS.png" alt="屏幕截图 2023-08-30 152226"></p><p>点击下一步</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdbO3j.png" alt="image-20230830152644100"></p><p>然后选择<code>现有</code></p><p>把刚刚的地址输入到<code>解释器</code>里</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdqSbV.png" alt="image-20230830152826067"></p><p>点击确定就完事了</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdqtqP.png" alt="image-20230830152939492"></p><p>之后用<code>工具</code>—<code>SSH会话</code>配合，就可以用学校的GPU跑程序了</p><p>tips：后期可以在服务器上安装<code>Anaconda</code>，然后把新建的虚拟环境中python路径配置到上述图片的<code>解释器</code>中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook --ip 0.0.0.0 --allow-root</span><br></pre></td></tr></table></figure><p>再补充一下，之前用conda的操作可能是麻烦了，服务器里自带好多python的环境，每个环境里也有很多自带的包</p><p><img src="https://z1.ax1x.com/2023/10/04/pPOHyIe.png" alt="屏幕截图 2023-10-04 204942"></p><p>选择例如选择python3.6后</p><p><img src="https://z1.ax1x.com/2023/10/04/pPOHgGd.png" alt="屏幕截图 2023-10-04 211210"></p><p>之后就《愉快》的调参吧，附一张成功用学校GPU跑代码的图片</p><p><img src="https://z1.ax1x.com/2023/10/04/pPOHqRs.png" alt="image-20231004211915616"></p><p> <strong>10.19继续补充一下</strong><br>有的项目跑起来需要运行作者的<code>run.sh</code>文件，这时候需要切换到项目的目录然后运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash run.sh</span><br></pre></td></tr></table></figure><p>但是环境默认是python2.7版本的，项目跑不起来，这时候需要切换python的环境</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whereis python</span><br><span class="line">rm /usr/bin/python</span><br><span class="line">ln -s /usr/bin/python3.6 /usr/bin/python</span><br></pre></td></tr></table></figure><p><img src="https://z1.ax1x.com/2023/10/19/piitih6.png" alt="image-20231019153231564"></p><p>还有一种方法，比如需要切换的环境在</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usr/bin/python3.6</span><br></pre></td></tr></table></figure><p>这时候需要在<code>.sh</code>文件中开头加上</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env python3.6</span></span><br></pre></td></tr></table></figure><p>可以在后面查看python环境</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python --version</span><br></pre></td></tr></table></figure><p><img src="https://z1.ax1x.com/2023/10/19/piir6K0.png" alt="image-20231019163749724"></p><p>这时候就切换了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先连接内网登录&lt;a href=&quot;http://paas.183-175-12-11.nip.io:30080/&quot;&gt;平台&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一般使用的话，直接找到&lt;code&gt;开发环境&lt;/code&gt;一栏，创建环境。然后通过&lt;code&gt;Pycharm&lt;/code&gt;中的&lt;co</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>使用蓝牙外设却不小心把台式机电脑蓝牙关了</title>
    <link href="https://ruvikm.gitee.io/2023/08/12/%E4%BD%BF%E7%94%A8%E8%93%9D%E7%89%99%E5%A4%96%E8%AE%BE%E5%8D%B4%E4%B8%8D%E5%B0%8F%E5%BF%83%E6%8A%8A%E5%8F%B0%E5%BC%8F%E6%9C%BA%E7%94%B5%E8%84%91%E8%93%9D%E7%89%99%E5%85%B3%E4%BA%86/"/>
    <id>https://ruvikm.gitee.io/2023/08/12/%E4%BD%BF%E7%94%A8%E8%93%9D%E7%89%99%E5%A4%96%E8%AE%BE%E5%8D%B4%E4%B8%8D%E5%B0%8F%E5%BF%83%E6%8A%8A%E5%8F%B0%E5%BC%8F%E6%9C%BA%E7%94%B5%E8%84%91%E8%93%9D%E7%89%99%E5%85%B3%E4%BA%86/</id>
    <published>2023-08-12T09:43:40.000Z</published>
    <updated>2023-08-12T10:54:07.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>今天犯了一个贼SB的错误，起因是蓝牙键盘突然就不能输入了（虽然是连接状态，但是按什么键都没有反应）</p><p>原来我的解决方法就是重启一下电脑，但是那会电脑开了贼多的软件。我就想重启也太麻烦了，既然重启的本质也是重启蓝牙，那我要不直接就把蓝牙重启算了，当时想到这里啊，我心中一阵狂喜，觉得我真TMD是个天才</p><p>于是我兴冲冲的找到系统设置—蓝牙，把蓝牙关了，然后当我准备开启蓝牙的时候，我傻眼了，艹，我外设都是蓝牙连接的啊，这TM开不开了</p><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><h3 id="尝试用带USB接收器的鼠标"><a href="#尝试用带USB接收器的鼠标" class="headerlink" title="尝试用带USB接收器的鼠标"></a>尝试用带USB接收器的鼠标</h3><p>我的鼠标不仅可以蓝牙连接，还可以用USB接收器连接，我心想这不是轻轻松松简简单单。于是给鼠标换了一个连接方式，插入了USB接收器。但是奇怪的事情发生了，无论我怎么动鼠标，鼠标的指针就是纹丝不动。我怀疑难道是关了蓝牙功能，连这个都影响到了吗</p><h3 id="尝试用有线设备"><a href="#尝试用有线设备" class="headerlink" title="尝试用有线设备"></a>尝试用有线设备</h3><p>虽然心中有一丝紧张，但是我感觉这不就是个小事嘛，那要不找个有线的外设不就可以了。于是翻箱倒柜，刨出来家里的古董有线键盘，插入了电脑前面的USB口。</p><p>但是，重量级来了，无论按什么键，都没有反应，让我一度以为是不是键盘寄了。然后我把键盘插到了笔记本上，发现还是可以用的，灯也是亮的（但是刚刚插在台式机上灯就没亮）</p><p>前面不行，后面总可以吧，肯定么得问题（Flag立的飞起）我买的主板可是有7个USB插口呢！！！这么想着我钻到桌子下面，吸着尘土，一个一个试着USB口，结果是全都不能用。当时心态就发生了一丝变化，我看着屏幕，屏幕看着我，但是感觉我们之间隔了一个不可逾越的鸿沟，那个鸿沟就是USB口。</p><h3 id="尝试远程软件"><a href="#尝试远程软件" class="headerlink" title="尝试远程软件"></a>尝试远程软件</h3><p>我逐渐意识到了问题的严重性，但我灵机一动，心想不还有远程软件么，用手机作为输入不就解决了。</p><p>我再次满怀希望的打开手机远程操作APP，在“我的设备”里寻找台式机，但是，咚咚咚！！！设备显示是离线状态，这我才想起来之前为了优化开机，把这个软件的开机自启给关了，我又傻眼了。</p><h3 id="分析现状"><a href="#分析现状" class="headerlink" title="分析现状"></a>分析现状</h3><p>现在的问题是，台式机蓝牙关了，但是我的常用外设都是蓝牙连接的，没有有线功能。我有一个有线键盘，但是台式机的USB口不知道为什么全不能用了，这就意味着即使我有有线鼠标理论上也没有用。远程软件也没有开启，不用通过手机远程把蓝牙打开。</p><h3 id="扣电池"><a href="#扣电池" class="headerlink" title="扣电池"></a>扣电池</h3><p>和卖主板的客服沟通后，建议我扣主板电池试试。关机后，等待5min后（为了放干净电），我把电池扣了下来，又等了3min左右装了上去。奇迹发生了，USB口能用了！！！于是我用键盘操作（一路按tab键）这找到了蓝牙的开关按钮，</p><p><img src="https://s1.ax1x.com/2023/08/12/pPu8BIP.png" alt="屏幕截图 2023-08-12 181458"></p><p>按空格打开了蓝牙的开关，至此，终于是解决了！！！</p><p>PS：如果不知道用空格是确认，当时用键盘打开我的远程软件其实也解决了</p><h2 id="反思及预防"><a href="#反思及预防" class="headerlink" title="反思及预防"></a>反思及预防</h2><p>三思而后行啊，<del>以及中午不能睡时间太长</del></p><h3 id="关闭蓝牙功能影响USB接收器的使用吗"><a href="#关闭蓝牙功能影响USB接收器的使用吗" class="headerlink" title="关闭蓝牙功能影响USB接收器的使用吗"></a>关闭蓝牙功能影响USB接收器的使用吗</h3><p>之后又专门把蓝牙关了，使用带USB接收器的鼠标连接，发现可以正常使用。看来问题就出在USB接口上了</p><h3 id="为什么USB接口不能用"><a href="#为什么USB接口不能用" class="headerlink" title="为什么USB接口不能用"></a>为什么USB接口不能用</h3><p>然后网上查到了USB口之前为什么不能用的原因及解决方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了省电，Windows默认情况下会在不使用USB控制器时将其关闭，在需要时再将其重新开启。但有时候Windows不会自动开启。</span><br><span class="line">1、右键单击开始菜单，打开设备管理器。</span><br><span class="line">2、双击展开“通用串行总线控制器”一栏。</span><br><span class="line">3、双击列表中的第一个“USB根集线器”。</span><br><span class="line">4、点击切换到“电源管理”标签页。</span><br><span class="line">5、取消勾选“允许计算机关闭此设备以节省电源”，点击“确定”。</span><br><span class="line">6、对通用串行总线控制器列表中的每个“USB根集线器”重复步骤3-5。</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/08/12/pPu8haq.png" alt="image-20230812182055614"></p><p>按照教程把上面一个一个都关了就好了</p><h3 id="打开远程软件的自启"><a href="#打开远程软件的自启" class="headerlink" title="打开远程软件的自启"></a>打开远程软件的自启</h3><p>由于也没啥重要的东西，就把软件自启打开了。再也不想为了一点优化差点坑死自己了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;今天犯了一个贼SB的错误，起因是蓝牙键盘突然就不能输入了（虽然是连接状态，但是按什么键都没有反应）&lt;/p&gt;
&lt;p&gt;原来我的解决方法就是重启一</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>拼模型尝试</title>
    <link href="https://ruvikm.gitee.io/2023/08/12/%E6%8B%BC%E6%A8%A1%E5%9E%8B%E5%B0%9D%E8%AF%95/"/>
    <id>https://ruvikm.gitee.io/2023/08/12/%E6%8B%BC%E6%A8%A1%E5%9E%8B%E5%B0%9D%E8%AF%95/</id>
    <published>2023-08-12T02:40:48.000Z</published>
    <updated>2023-08-15T07:53:48.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>记录一下自己首次组合模型的过程，希望可以为以后论文打基础。</p><p>PS：由于自己是零基础，看了一下李沐的教程，感觉理论部分有点多，没看完可能<code>deadline</code>都到了。唐老师的人工智能课也看了看，总感觉不是特别系统，都是一个一个项目，于是我打算效率亿点点，需要什么先学什么。</p><p>我需要跑的一个模型是这样的架构</p><p><img src="https://s1.ax1x.com/2023/08/12/pPuCZes.png" alt="模型架构"></p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>客观分析一下我遇到的这个问题</p><p><strong>1.目标问题</strong></p><p>把这个架构跑通$\rightarrow$</p><p>从中文电子病历提取有用信息$\rightarrow$</p><p>进行医疗大数据挖掘、临床辅助决策系统、AI 电子病历质控系统构建等的基础工作</p><p><strong>2.方法问题</strong></p><p>寻找相似的项目或者使用了相似模型架构的项目，把他们的模型删删改改</p><p>删改可能需要借助到模型的官方文档，例如<a href="https://paddlenlp.readthedocs.io/zh/latest/index.html">PaddleNLP文档</a>，或者<a href="https://pytorch-cn.readthedocs.io/zh/latest/">PyTorch文档</a></p><p>然后多借鉴一些博客的方法</p><p><strong>3.执行问题</strong></p><p>先安装一下paddle，然后尝试先把网上的项目跑通，在看懂的基础上进行修改</p><h2 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h2><h3 id="安装paddleNLP"><a href="#安装paddleNLP" class="headerlink" title="安装paddleNLP"></a>安装paddleNLP</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认前提是已经安装好了paddle(2.5.1)，我之前已经安装完，现在直接进入这个环境(CUDA 11.0)</span></span><br><span class="line">conda activate paddle</span><br><span class="line"><span class="comment"># 安装PaddleNLP 换成阿里云的镜像安装会快很多</span></span><br><span class="line">pip install --upgrade paddlenlp&gt;=2.0.0rc -i https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure><p>验证安装</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> paddlenlp</span><br></pre></td></tr></table></figure><p>没有error应该就是安装好了</p><h3 id="复现别人项目"><a href="#复现别人项目" class="headerlink" title="复现别人项目"></a>复现别人项目</h3><p>首先找到一个使用了类似框架的项目——<a href="https://aistudio.baidu.com/aistudio/projectdetail/1761182">中文命名实体识别-Bi-GRU+CRF</a>，然后把代码以<code>.py</code>的格式下载下来,用PyCharm打开</p><p>打开后项目结构如下</p><p><img src="https://s1.ax1x.com/2023/08/13/pPKFcad.png" alt="image-20230813171608656"></p><p>开始一步一步跑了</p><p>首先遇到的一个问题，<code>UnicodeDecodeError: &#39;gbk&#39; codec can&#39;t decode byte 0xa8 in position 2: illegal multibyte sequence</code></p><p><img src="https://s1.ax1x.com/2023/08/13/pPKFoqg.png" alt="image-20230813172211506"></p><p>加一个<code>encoding</code>属性就可以了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">open</span>(<span class="string">&#x27;data/train.txt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)):</span><br></pre></td></tr></table></figure><p>往下跑的时候又出现了一个错，<code>ValueError: not enough values to unpack (expected 2, got 1)</code></p><p><img src="https://s1.ax1x.com/2023/08/13/pPK0js0.png" alt="image-20230813205507724"></p><p>经过调试发现，<code>word_vocab = load_dict(&#39;./conf/word.dic&#39;)</code>这句就不会报错，只有前一句报错，于是我对比了两个数据集，发现了原因</p><p><code>word.dic</code>数据集（部分）</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">0a</span><br><span class="line">1e</span><br><span class="line">2i</span><br><span class="line">3n</span><br><span class="line">4o</span><br><span class="line">5s</span><br></pre></td></tr></table></figure><p><code>tag.dic</code>数据集（部分）</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">B-PER</span><br><span class="line">I-PER</span><br><span class="line">B-ORG</span><br><span class="line">I-ORG</span><br></pre></td></tr></table></figure><p>问题就出现在函数<code>load_dict</code>的这句话上</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_dict</span>(<span class="params">dict_path</span>):</span><br><span class="line">    vocab = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(dict_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>):</span><br><span class="line">    //这句有问题，第一个数据集一行有两个参数，但是第二个数据集只有一个参数</span><br><span class="line">        value, key = line.strip(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;\t&#x27;</span>)  </span><br><span class="line">        vocab[key] = <span class="built_in">int</span>(value)</span><br><span class="line">    <span class="keyword">return</span> vocab</span><br></pre></td></tr></table></figure><p>于是我分开写了两个函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_word_dict</span>(<span class="params">dict_path</span>):</span><br><span class="line">    vocab = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(dict_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>):</span><br><span class="line">        value, key = line.strip(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        vocab[key] = <span class="built_in">int</span>(value)</span><br><span class="line">    <span class="keyword">return</span> vocab</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_tag_dict</span>(<span class="params">dict_path</span>):</span><br><span class="line">    vocab = &#123;&#125;</span><br><span class="line">    key = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(dict_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>):</span><br><span class="line">        value = line.strip(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        vocab[key] = value</span><br><span class="line">        key += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> vocab</span><br></pre></td></tr></table></figure><p>后面的调用在改一下就行了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">label_vocab = load_tag_dict(<span class="string">&#x27;./conf/tag.dic&#x27;</span>) </span><br><span class="line">word_vocab = load_word_dict(<span class="string">&#x27;./conf/word.dic&#x27;</span>)</span><br></pre></td></tr></table></figure><p>按照同样的逻辑，把前面单元格里的代码改一下就行，但是发现还有错误</p><p><img src="https://s1.ax1x.com/2023/08/13/pPKBYef.png" alt="image-20230813211023632"></p><p>发现上下两个代码块其实意思差不多，把上面代码块里的<code>load_dataset</code>函数替换掉下面的就行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_dataset</span>(<span class="params">datafiles</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">data_path</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(data_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            word_list = []</span><br><span class="line">            tag_list = []</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                <span class="keyword">if</span> line != <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">                    word, tag = line.strip(<span class="string">&#x27;\n&#x27;</span>).split()</span><br><span class="line">                    word_list.append(word)</span><br><span class="line">                    tag_list.append(tag)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">yield</span> word_list, tag_list</span><br><span class="line">                    word_list = []</span><br><span class="line">                    tag_list = []</span><br><span class="line">            <span class="comment"># next(fp)</span></span><br><span class="line">            <span class="comment"># for line in fp.readlines():</span></span><br><span class="line">            <span class="comment">#     words, labels = line.strip(&#x27;\n&#x27;).split(&#x27;\t&#x27;)</span></span><br><span class="line">            <span class="comment">#     words = words.split(&#x27;\002&#x27;)</span></span><br><span class="line">            <span class="comment">#     labels = labels.split(&#x27;\002&#x27;)</span></span><br><span class="line">            <span class="comment">#     yield words, labels</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(datafiles, <span class="built_in">str</span>):</span><br><span class="line">        <span class="keyword">return</span> MapDataset(<span class="built_in">list</span>(read(datafiles)))</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(datafiles, <span class="built_in">list</span>) <span class="keyword">or</span> <span class="built_in">isinstance</span>(datafiles, <span class="built_in">tuple</span>):</span><br><span class="line">        <span class="keyword">return</span> [MapDataset(<span class="built_in">list</span>(read(datafile))) <span class="keyword">for</span> datafile <span class="keyword">in</span> datafiles]</span><br></pre></td></tr></table></figure><p>之后好多代码块都没有报错，直到需要训练的时候，遇到了这个</p><p><img src="https://s1.ax1x.com/2023/08/13/pPKsRk8.png" alt="image-20230813220554458"></p><p>网上查了好长时间也不知道怎么解决，以为是版本<code>paddle</code>太高了，降级完但是出现了更多的错，弄了好半天也没成功，最后又装回<code>2.5.1</code>版本的了。后来看到网上说很可能是dataset类型的原因，官方API要求的类型如下</p><p><strong>dataset</strong> (Dataset) - <code>DataLoader</code> 从此参数给定数据集中加载数据，此参数必须是 <code>paddle.io.Dataset</code> 或 <code>paddle.io.IterableDataset</code> 的一个子类实例。</p><p>而我的类型是<code>paddlenlp.datasets.dataset.MapDataset</code></p><p><img src="https://s1.ax1x.com/2023/08/15/pPQAQHS.png" alt="image-20230815155330435"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;记录一下自己首次组合模型的过程，希望可以为以后论文打基础。&lt;/p&gt;
&lt;p&gt;PS：由于自己是零基础，看了一下李沐的教程，感觉理论部分有点多，没</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>复现论文SpikeGPT Generative Pre-trained Language Model with Spiking Neural Networks</title>
    <link href="https://ruvikm.gitee.io/2023/07/22/%E5%A4%8D%E7%8E%B0%E8%AE%BA%E6%96%87SpikeGPT-Generative%20Pre-trained%20Language%20Model%20with%20Spiking%20Neural%20Networks/"/>
    <id>https://ruvikm.gitee.io/2023/07/22/%E5%A4%8D%E7%8E%B0%E8%AE%BA%E6%96%87SpikeGPT-Generative%20Pre-trained%20Language%20Model%20with%20Spiking%20Neural%20Networks/</id>
    <published>2023-07-22T01:28:55.000Z</published>
    <updated>2023-08-12T10:26:23.385Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下复现论文<a href="https://arxiv.org/abs/2302.13939v2">SpikeGPT: Generative Pre-trained Language Model with Spiking Neural Networks</a>的过程，论文给出了项目的<a href="https://github.com/ridgerchu/SpikeGPT">GitHub</a>地址。此博客是边跑边写边改的，尽量把顺序合理化，让人可以少走一些弯路</p><h2 id="论文概述"><a href="#论文概述" class="headerlink" title="论文概述"></a>论文概述</h2><p>利用工具，可以大概对此篇论文有如下了解</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">这篇文章介绍了SpikeGPT，这是一种基于脉冲神经网络(SNNs)的生成式语言模型。SNNs利用稀疏、事件驱动的激活方式来减少计算复杂性，提高能源效率，因此在深度学习领域有很大的潜力。虽然SNNs在计算机视觉任务上取得了成功，但在语言生成方面仍然有待进一步探索，因为它们的训练过程相对复杂。文章的作者们对Transformer模块进行了修改，消除了多头自注意力带来的二次计算复杂度，并引入循环计算，实现了逐词计算，同时保留了长程依赖关系。结果得到的SpikeGPT模型在语言生成任务上表现出竞争力，同时能耗仅为传统人工神经网络(ANNs)的五分之一。该模型还是迄今为止最大的反向传播训练的功能性SNN模型，拥有多达2.6亿个参数。这项工作为在自然语言处理任务中有效训练大规模SNNs并将Transformer架构与SNNs结合起来实现高性能和能源效率开辟了新的潜力。</span><br></pre></td></tr></table></figure><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="新建环境"><a href="#新建环境" class="headerlink" title="新建环境"></a>新建环境</h3><p>新建一个<code>Conda</code>环境</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n SpikeGPT python=3.8</span><br><span class="line">conda activate SpikeGPT</span><br></pre></td></tr></table></figure><p>然后用<code>pycharm</code>打开此项目，并切换到刚刚新建的环境</p><p>接下来就是安装环境了，由于作者没有提供具体包的版本，只能根据缺啥安装啥的原则，有什么问题之后再慢慢改</p><h3 id="安装accelerate"><a href="#安装accelerate" class="headerlink" title="安装accelerate"></a>安装accelerate</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install accelerate</span><br></pre></td></tr></table></figure><p>在安装<code>accelerate</code>的时候，自动给我装了一个torch2.0.1版本的，这个后面管，只要这个torch版本大于10.0.0就行</p><h3 id="安装Pytorch"><a href="#安装Pytorch" class="headerlink" title="安装Pytorch"></a>安装Pytorch</h3><p>根据我的<code>CUDA</code>版本，安装了如下的<code>torch</code>，具体安装细节可以参考<a href="https://ruvikm.gitee.io/2023/06/06/Win11%E9%85%8D%E7%BD%AEAnaconda-Cuda-Pytorch-Tenserflow%E7%8E%AF%E5%A2%83/">这篇博客</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install pytorch==1.11.0 torchvision==0.12.0 torchaudio==0.11.0 cudatoolkit=11.3</span><br></pre></td></tr></table></figure><h3 id="安装matplotlib"><a href="#安装matplotlib" class="headerlink" title="安装matplotlib"></a>安装matplotlib</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install matplotlib</span><br></pre></td></tr></table></figure><h3 id="安装tqdm"><a href="#安装tqdm" class="headerlink" title="安装tqdm"></a>安装tqdm</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install tqdm</span><br></pre></td></tr></table></figure><h3 id="安装transformers"><a href="#安装transformers" class="headerlink" title="安装transformers"></a>安装transformers</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install transformers</span><br></pre></td></tr></table></figure><h3 id="安装deepspeed"><a href="#安装deepspeed" class="headerlink" title="安装deepspeed"></a>安装deepspeed</h3><h4 id="错误安装方法"><a href="#错误安装方法" class="headerlink" title="错误安装方法"></a>错误安装方法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install deepspeed</span><br></pre></td></tr></table></figure><p>安装的时候报错了</p><p><img src="https://s1.ax1x.com/2023/07/22/pCbvDot.png" alt="image-20230722102232403"></p><p>换<code>conda</code>试了后，<code>conda install deepspeed</code>，也不行。</p><p>网上查了一个安装方式</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install transformers[deepspeed]</span><br></pre></td></tr></table></figure><p>还是那个错，网上查了一下</p><p><img src="https://s1.ax1x.com/2023/07/22/pCbxpY6.png" alt="image-20230722103014784"></p><p>设置一下环境变量试试</p><p><img src="https://s1.ax1x.com/2023/07/22/pCbxX38.png" alt="屏幕截图 2023-07-22 105535"></p><p>报错！！！好消息是报错变了</p><p><img src="https://s1.ax1x.com/2023/07/22/pCbxbNt.png" alt="image-20230722105444097"></p><p>去<code>github</code>看了一下，意思大概是这个库原本是在<code>linux</code>上的，在<code>window</code>上的支持还不是很好</p><p><img src="https://s1.ax1x.com/2023/07/22/pCbxy7R.png" alt="image-20230722103953254"></p><h4 id="正确安装方法"><a href="#正确安装方法" class="headerlink" title="正确安装方法"></a>正确安装方法</h4><p>网上查到一篇win10成功安装的<a href="https://zhuanlan.zhihu.com/p/636450918">博客</a>，按照博客的说法</p><p>首先安装必要组件</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq9crD.png" alt="image-20230722122822936">先把<a href="https://github.com/microsoft/DeepSpeed">官方</a>的开源的代码下载下来，解压（要用管理员权限）后</p><p>用管理员权限打开cmd，切换到解压的目录，在命令行输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">build_win.bat</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/22/pCq9A8P.png" alt="image-20230722121606679"></p><p>慢慢改错吧，先解决一个报错最多的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error: attribute <span class="string">&quot;nodiscard&quot;</span> does not take arguments</span><br></pre></td></tr></table></figure><h3 id="下载数据集"><a href="#下载数据集" class="headerlink" title="下载数据集"></a>下载数据集</h3><p>作者提供数据集<code>Enwik8</code><a href="https://data.deepai.org/enwik8.zip">下载地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下复现论文&lt;a href=&quot;https://arxiv.org/abs/2302.13939v2&quot;&gt;SpikeGPT: Generative Pre-trained Language Model with Spiking Neural Networks&lt;/a&gt;的过程，</summary>
      
    
    
    
    <category term="论文复现" scheme="https://ruvikm.gitee.io/categories/%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>安装PaddlePaddle</title>
    <link href="https://ruvikm.gitee.io/2023/07/21/%E5%AE%89%E8%A3%85PaddlePaddle/"/>
    <id>https://ruvikm.gitee.io/2023/07/21/%E5%AE%89%E8%A3%85PaddlePaddle/</id>
    <published>2023-07-21T02:23:04.000Z</published>
    <updated>2023-07-21T02:54:49.046Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下安装的过程，官方文档如下</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">https://www.paddlepaddle.org.cn/documentation/docs/zh/install/conda/windows-conda.html</span><br></pre></td></tr></table></figure><h2 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create -n paddle python=3.8</span><br><span class="line">conda activate paddle</span><br></pre></td></tr></table></figure><h2 id="查看自己安装的CUDA版本"><a href="#查看自己安装的CUDA版本" class="headerlink" title="查看自己安装的CUDA版本"></a>查看自己安装的CUDA版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/21/pCHjtOA.png" alt="image-20230721102917138"></p><p>选择适合自己的版本，我安装的是CUDA11.2的</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install paddlepaddle-gpu==2.5.0 cudatoolkit=11.2 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/Paddle/ -c conda-forge</span><br></pre></td></tr></table></figure><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line">paddle.utils.run_check()</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/21/pCHvsN6.png" alt="image-20230721105441359"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下安装的过程，官方文档如下&lt;/p&gt;
&lt;figure class=&quot;highlight tex&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https://www.paddlepaddle.org.cn/do</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>本地部署chatGPT</title>
    <link href="https://ruvikm.gitee.io/2023/07/15/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2chatGPT/"/>
    <id>https://ruvikm.gitee.io/2023/07/15/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2chatGPT/</id>
    <published>2023-07-15T01:13:30.000Z</published>
    <updated>2023-07-21T08:07:08.064Z</updated>
    
    <content type="html"><![CDATA[<p>首先打开<a href="https://github.com/ramonvc/freegpt-webui#cloning-the-repository-inbox_tray">项目网址</a>，把代码下载下来，按照其要求安装<a href="https://www.python.org/downloads/"><code>python</code></a>，<a href="https://git-scm.com/download/win"><code>git</code></a></p><p>安装完成后，检查一下自己是否安装成功，<code>Win+R</code>后输入<code>cmd</code>，在弹出来的窗口内输入<code>python</code></p><p><img src="https://s1.ax1x.com/2023/07/15/pC5VexS.png" alt="image-20230715091723681"></p><p>若和下图类似，则说明安装成功</p><p>输入<code>exit()</code>退出<code>python</code>的编辑模式。继续输入<code>git --version</code></p><p><img src="https://s1.ax1x.com/2023/07/15/pC5VQVs.png" alt="image-20230715091956265"></p><p>说明<code>git</code>也安装成功。</p><p>将下载下来的压缩包解压，并用<code>cmd</code>进入其项目文件夹，输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/15/pC5VoJP.png" alt="image-20230715093344938"></p><p><strong>安装完毕后然后开启海外全局<code>magic</code></strong>，运行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python run.py</span><br></pre></td></tr></table></figure><p>如果遇到这个问题</p><p><img src="https://s1.ax1x.com/2023/07/15/pC5ZnW6.png" alt="image-20230715094624768"></p><p>找到项目中的<code>config.json</code>文件</p><p>把<code>port</code>改成<code>8088</code></p><p><img src="https://s1.ax1x.com/2023/07/15/pC5ZMQO.png" alt="image-20230715094711628"></p><p>若出现以下界面</p><p><img src="https://s1.ax1x.com/2023/07/15/pC5ZlOe.png" alt="image-20230715094750540"></p><p>则可以打开</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">http://localhost:8088</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/15/pC5ZlOe.png" alt="image-20230715094750540"></p><p>成功部署chatGPT！</p><p><img src="https://s1.ax1x.com/2023/07/15/pC5ZI0J.png" alt="屏幕截图 2023-07-15 095407"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先打开&lt;a href=&quot;https://github.com/ramonvc/freegpt-webui#cloning-the-repository-inbox_tray&quot;&gt;项目网址&lt;/a&gt;，把代码下载下来，按照其要求安装&lt;a href=&quot;https://www.pyt</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>OSError [Errno 22] Invalid argument(已解决)</title>
    <link href="https://ruvikm.gitee.io/2023/07/12/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98OSError%20[Errno%2022]%20Invalid%20argument/"/>
    <id>https://ruvikm.gitee.io/2023/07/12/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98OSError%20[Errno%2022]%20Invalid%20argument/</id>
    <published>2023-07-12T14:31:56.000Z</published>
    <updated>2023-07-12T14:42:34.626Z</updated>
    
    <content type="html"><![CDATA[<p>最近跑别人的项目遇到一个这样的问题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OSError: [Errno 22] Invalid argument xxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/12/pCh9Ni4.png" alt="屏幕截图 2023-07-12 203923"></p><p>一开始以为是没有用管理员的权限运行，导致创建不了日志文件</p><p>后来发现是和windows的命名规则冲突了（以下来源<a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">官网地址</a>）</p><h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h3><p>以下基本规则使应用程序能够创建和处理文件和目录的有效名称，而不考虑文件系统：</p><ul><li><p>使用句点将基文件名与目录或文件名称中的扩展名分隔开。</p></li><li><p>使用反斜杠 () 分隔<em>路径</em>的<em>组件</em>。 反斜杠将文件名从路径中除以，将一个目录名与路径中的另一个目录名称分开。 不能在实际文件或目录的名称中使用反斜杠，因为它是将名称分隔成组件的保留字符。</p></li><li><p>根据需要使用反斜杠作为 <a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-volume">卷名称</a>的一部分，例如“C：\”在“C：\path\file”或“\server\share\path\file”中为通用命名约定的“\server\share” (UNC) 名称。 有关 UNC 名称的详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file#maximum-path-length-limitation">最大路径长度限制</a> 部分。</p></li><li><p>不要假定区分大小写。 例如，将 OSCAR、Oscar 和 oscar 的名称视为相同，即使某些文件系统 (（如符合 POSIX 的文件系统) 可能认为它们不同）。 请注意，NTFS 支持 POSIX 语义区分大小写，但这不是默认行为。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/FileAPI/nf-fileapi-createfilea"><strong>CreateFile</strong></a>。</p></li><li><p>(驱动器号) 的卷指定符同样不区分大小写。 例如，“D：\”和“d：\”引用同一卷。</p></li><li><p>使用当前代码页中的任何字符作为名称，包括 Unicode 字符和扩展字符集中 (128-255) 字符，但以下各项除外：</p><ul><li>以下保留字符：<ul><li>&lt;（小于）</li><li>>（大于）</li><li>:（冒号）</li><li>“（双引号）</li><li>/（正斜杠）</li><li>\（反斜杠）</li><li>| (竖线或竖线)</li><li>? （问号）</li><li>*（星号）</li></ul></li><li>整数值零，有时称为 ASCII <em>NUL</em> 字符。</li><li>整数表示形式的字符介于 1 到 31 之间，但允许这些字符的备用数据流除外。 有关文件流的详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/file-streams">文件流</a>。</li><li>目标文件系统不允许的任何其他字符。</li></ul></li><li><p>使用句点作为路径中的目录 <em>组件</em> 来表示当前目录，例如“.\temp.txt”。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file#fully-qualified-vs-relative-paths">路径</a>。</p></li><li><p>使用两个连续的句点 (。) 作为路径中的目录 <em>组件</em> 来表示当前目录的父目录，例如“.”。\temp.txt”。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file#fully-qualified-vs-relative-paths">路径</a>。</p></li><li><p>不要将以下保留名称用于文件的名称：</p><p>CON、PRN、AUX、NUL、COM0、COM1、COM2、COM3、COM4、COM5、COM6、COM7、COM8、COM9、LPT0、LPT1、LPT2、LPT3、LPT4、LPT5、LPT6、LPT7、LPT8 和 LPT9。 另请避免这些名称紧跟扩展名;例如，NUL.txt 和 NUL.tar.gz 都等效于 NUL。 有关详细信息，请参阅<a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file#win32-file-namespaces">命名空间</a>。</p></li><li><p>不要用空格或句点结束文件或目录名称。 尽管基础文件系统可能支持此类名称，但 Windows shell 和用户界面不支持。 但是，可以接受指定句点作为名称的第一个字符。 例如“.temp”。</p></li></ul><h3 id="划重点：下列符号是不能用的"><a href="#划重点：下列符号是不能用的" class="headerlink" title="划重点：下列符号是不能用的"></a><strong>划重点：下列符号是不能用的</strong></h3><ul><li>&lt;（小于）</li><li>>（大于）</li><li>:（冒号）</li><li>“（双引号）</li><li>/（正斜杠）</li><li>\（反斜杠）</li><li>| (竖线或竖线)</li><li>? （问号）</li><li>*（星号）</li></ul><p>然后我细心的观察到了这一点</p><p><img src="https://s1.ax1x.com/2023/07/12/pChpwb8.png" alt="屏幕截图 2023-07-12 222221"></p><p>很显然，<code>:</code>是不能存在的</p><p>把他换成<code>-</code>后，程序就跑起来了</p><p><img src="https://s1.ax1x.com/2023/07/12/pCh96oD.png" alt="屏幕截图 2023-07-12 222822"></p><p>类似的问题可以参考一下下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近跑别人的项目遇到一个这样的问题&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;OSError: [Errno 22] Invalid</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>word2vec工具实战</title>
    <link href="https://ruvikm.gitee.io/2023/07/04/word2vec%E5%B7%A5%E5%85%B7%E5%AE%9E%E6%88%98/"/>
    <id>https://ruvikm.gitee.io/2023/07/04/word2vec%E5%B7%A5%E5%85%B7%E5%AE%9E%E6%88%98/</id>
    <published>2023-07-04T11:35:50.000Z</published>
    <updated>2023-07-05T02:31:10.859Z</updated>
    
    <content type="html"><![CDATA[<p>最开始需要新建一个conda环境</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n word2vec python=3.8</span><br><span class="line">conda activate word2vec</span><br></pre></td></tr></table></figure><p>然后安装一下所需要的库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install numpy</span><br><span class="line">pip install scipy</span><br><span class="line">pip install gensim</span><br><span class="line">pip install jieba</span><br></pre></td></tr></table></figure><p>首先下载一下数据集<a href="https://dumps.wikimedia.org/zhwiki/20230701/zhwiki-20230701-pages-articles.xml.bz2">zhwiki-20230701-pages-articles.xml.bz2</a>，为了方便后续操作，这里需要把他转成<code>txt</code>格式的</p><p>以下是转化的文件<code>transform_to_txt.py</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 修改后的代码如下：</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> gensim.corpora <span class="keyword">import</span> WikiCorpus</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    program = os.path.basename(sys.argv[<span class="number">0</span>])</span><br><span class="line">    logger = logging.getLogger(program)</span><br><span class="line">    logging.basicConfig(<span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s: %(levelname)s: %(message)s&#x27;</span>)</span><br><span class="line">    logging.root.setLevel(level=logging.INFO)</span><br><span class="line">    logger.info(<span class="string">&quot;running %s&quot;</span> % <span class="string">&#x27; &#x27;</span>.join(sys.argv))</span><br><span class="line">    <span class="comment"># check and process input arguments</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&#x27;__doc__&#x27;</span>] % <span class="built_in">locals</span>())</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    inp, outp = sys.argv[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    space = <span class="string">&quot;&quot;</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    output = <span class="built_in">open</span>(outp, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># wiki = WikiCorpus(inp, lemmatize=False, dictionary=&#123;&#125;)</span></span><br><span class="line">    wiki = WikiCorpus(inp, dictionary=&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> text <span class="keyword">in</span> wiki.get_texts():</span><br><span class="line">        s = space.join(text)</span><br><span class="line">        <span class="comment"># s = s.decode(&#x27;utf8&#x27;) + &quot;\n&quot;</span></span><br><span class="line">        s = s.encode(<span class="string">&#x27;utf8&#x27;</span>).decode(<span class="string">&#x27;utf8&#x27;</span>) + <span class="string">&quot;\n&quot;</span></span><br><span class="line">        output.write(s)</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">10000</span> == <span class="number">0</span>):</span><br><span class="line">            logger.info(<span class="string">&quot;Saved &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot; articles&quot;</span>)</span><br><span class="line">    output.close()</span><br><span class="line">    logger.info(<span class="string">&quot;Finished Saved &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot; articles&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后将刚刚下载的数据集和此<code>Python</code>文件放在同一个目录下，并且用命令行跳转到这个目录，然后执行</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">python transform<span class="built_in">_</span>to<span class="built_in">_</span>txt.py zhwiki-20230701-pages-articles.xml.bz2 wiki.zh.text</span><br></pre></td></tr></table></figure><p>其中，第一个参数是<code>Python</code>的文件名，第二个是要处理的数据文件名，第三个是要输出的文件名</p><p>转换完之后就生成了一个txt文件</p><p><img src="https://s1.ax1x.com/2023/07/04/pCs7rX8.png" alt="image-20230704195428973"></p><p>直接浏览，可以看出这里面全是繁体字，所以下面需要把繁体转换成简体</p><p><img src="https://s1.ax1x.com/2023/07/04/pCs760g.png" alt="image-20230704195605355"></p><p>首先需要下载这个<a href="https://github.com/BYVoid/OpenCC/wiki/Download">转换工具</a>，<strong>记住要下载预编译的</strong>。</p><p>然后解压后放在一个能记住的位置，例如我是</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">G:<span class="keyword">\Lab</span><span class="keyword">\DeepLearning</span><span class="keyword">\OpenCC</span><span class="keyword">\share</span><span class="keyword">\opencc</span></span><br></pre></td></tr></table></figure><p>然后把文件夹中的<code>bin</code>目录配置到系统环境<code>path</code>里</p><p><img src="https://s1.ax1x.com/2023/07/04/pCsblqO.png" alt="屏幕截图 2023-07-04 202744"></p><p>最后验证一下是否配置成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opencc --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/04/pCsHFNd.png" alt="屏幕截图 2023-07-04 201226"></p><p>然后就可以转换啦，用<code>cmd</code>跳转到<code>wiki.zh.text</code>文件所在的目录，在命令行输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opencc -i wiki.zh.text -o test_zh.txt -c G:\Lab\DeepLearning\OpenCC\share\opencc\t2s.json</span><br></pre></td></tr></table></figure><p><code>wiki.zh.text</code>是待转换的繁体文本，<code>test_zh.txt</code>是输出的简体文本，<code>t2s.json</code>表示繁体转简体，其中这个需要换成自己的地址（<strong>地址不要有空格</strong>）</p><p><img src="https://s1.ax1x.com/2023/07/04/pCsbmGR.png" alt="image-20230704203004637"></p><p>等一会就好了</p><p><img src="https://s1.ax1x.com/2023/07/04/pCsbtJA.png" alt="image-20230704203155840"></p><p>然后就全部成了简体了，使用word2vec工具需要做的最后一步是分词</p><p>分词使用<code>jieba</code>这个库来解决，以下是分词的文件<code>participle.py</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> jieba.analyse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cut_words</span>(<span class="params">sentence</span>):</span><br><span class="line">    <span class="comment"># print sentence</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(jieba.cut(sentence)).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = codecs.<span class="built_in">open</span>(<span class="string">&#x27;test_zh.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">target = codecs.<span class="built_in">open</span>(<span class="string">&quot;zh.jian.wiki.seg_1.5G.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;open files&#x27;</span>)</span><br><span class="line">line_num = <span class="number">1</span></span><br><span class="line">line = f.readline()</span><br><span class="line"><span class="keyword">while</span> line:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---- processing &#x27;</span>, line_num, <span class="string">&#x27; article----------------&#x27;</span>)</span><br><span class="line">    line_seg = <span class="string">&quot; &quot;</span>.join(jieba.cut(line))</span><br><span class="line">    target.writelines(line_seg)</span><br><span class="line">    line_num = line_num + <span class="number">1</span></span><br><span class="line">    line = f.readline()</span><br><span class="line">f.close()</span><br><span class="line">target.close()</span><br><span class="line">exit()</span><br><span class="line"><span class="keyword">while</span> line:</span><br><span class="line">    curr = []</span><br><span class="line">    <span class="keyword">for</span> oneline <span class="keyword">in</span> line:</span><br><span class="line">        <span class="comment"># print(oneline)</span></span><br><span class="line">        curr.append(oneline)</span><br><span class="line">    after_cut = <span class="built_in">map</span>(cut_words, curr)</span><br><span class="line">    target.writelines(after_cut)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;saved&#x27;</span>, line_num, <span class="string">&#x27;articles&#x27;</span>)</span><br><span class="line">    exit()</span><br><span class="line">    line = f.readline1()</span><br><span class="line">f.close()</span><br><span class="line">target.close()</span><br></pre></td></tr></table></figure><p>其中，这一句是配置需要分词的文件<code>test_zh.txt</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = codecs.<span class="built_in">open</span>(<span class="string">&#x27;test_zh.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&quot;utf8&quot;</span>)</span><br></pre></td></tr></table></figure><p>这一句是配置需要输出的文件<code>zh.jian.wiki.seg_1.5G.txt</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">target = codecs.<span class="built_in">open</span>(<span class="string">&quot;zh.jian.wiki.seg_1.5G.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&quot;utf8&quot;</span>)</span><br></pre></td></tr></table></figure><p>将<code>participle.py</code>文件和上面输出的简体文本<code>test_zh.txt</code>放在同一个目录，用<code>cmd</code>（跳转到对应目录后输入<code>python Testjieba.py</code>）或者<code>Pycharm</code>直接运行<code>participle.py</code>文件</p><p><strong>PS：无论是<code>cmd</code>还是<code>Pycharm</code>，记得切换到<code>word2vec</code>环境</strong></p><p>经过将近一个多小时的时间，终于跑完了</p><p><img src="https://s1.ax1x.com/2023/07/04/pCsb6ij.png" alt="屏幕截图 2023-07-04 192329"></p><p>接下来就是正式使用word2vec的时候了，以下是使用word2vec的文件<code>word2vec_model.py</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> Word2Vec</span><br><span class="line"><span class="keyword">from</span> gensim.models.word2vec <span class="keyword">import</span> LineSentence</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    program = os.path.basename(sys.argv[<span class="number">0</span>])</span><br><span class="line">    logger = logging.getLogger(program)</span><br><span class="line">    logging.basicConfig(<span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s: %(levelname)s: %(message)s&#x27;</span>)</span><br><span class="line">    logging.root.setLevel(level=logging.INFO)</span><br><span class="line">    logger.info(<span class="string">&quot;running %s&quot;</span> % <span class="string">&#x27; &#x27;</span>.join(sys.argv))</span><br><span class="line">    <span class="comment"># check and process input arguments</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt; <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&#x27;__doc__&#x27;</span>] % <span class="built_in">locals</span>())</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    inp, outp1, outp2 = sys.argv[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">    model = Word2Vec(LineSentence(inp), size=<span class="number">400</span>, window=<span class="number">5</span>, min_count=<span class="number">5</span>, workers=multiprocessing.cpu_count())</span><br><span class="line">    model.save(outp1)</span><br><span class="line">    model.wv.save_word2vec_format(outp2, binary=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>将上文分好词的文件<code>zh.jian.wiki.seg_1.5G.txt</code>与<code>word2vec_model.py</code>文件也是放到同一个目录下，然后在<code>cmd</code>中执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python word2vec_model.py zh.jian.wiki.seg_1.5G.txt wiki.zh.text.model wiki.zh.text.vector</span><br></pre></td></tr></table></figure><p>其中，<code>wiki.zh.text.model</code>是生成的模型（同样记得切换环境）</p><p><img src="https://s1.ax1x.com/2023/07/04/pCsqmTg.png" alt="image-20230704205047579"></p><p>可能会报这个错，原因可能是<code>gensim</code>的版本的差异。</p><p>这样把下面这句的<code>size</code>改成<code>vector_size</code>即可</p><p>源代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Word2Vec(LineSentence(inp), size=<span class="number">400</span>, window=<span class="number">5</span>, min_count=<span class="number">5</span>, workers=multiprocessing.cpu_count())</span><br></pre></td></tr></table></figure><p>新代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Word2Vec(LineSentence(inp), vector_size=<span class="number">400</span>, window=<span class="number">5</span>, min_count=<span class="number">5</span>, workers=multiprocessing.cpu_count())</span><br></pre></td></tr></table></figure><p>然后就可以漫长的等待了！</p><p><img src="https://s1.ax1x.com/2023/07/04/pCsqB11.png" alt="image-20230704205435161"></p><p> 经过一段时间后，模型保存成功了！</p><p><img src="https://s1.ax1x.com/2023/07/04/pCsO3ZT.png" alt="屏幕截图 2023-07-04 212910"></p><p>最后测试一下模型</p><p>测试文件<code>testModel.py</code>如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> Word2Vec</span><br><span class="line"></span><br><span class="line">en_wiki_word2vec_model = Word2Vec.load(<span class="string">&#x27;wiki.zh.text.model&#x27;</span>)</span><br><span class="line"></span><br><span class="line">testwords = [<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;学术&#x27;</span>, <span class="string">&#x27;白痴&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    res = en_wiki_word2vec_model.wv.most_similar(testwords[i])</span><br><span class="line">    <span class="built_in">print</span>(testwords[i])</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><p>继续在同一个目录执行<code>testModel.py</code>文件，得到如下结果</p><p><img src="https://s1.ax1x.com/2023/07/05/pCyEdl6.png" alt="image-20230705101212390"></p><p>最后附上<a href="https://github.com/Ruvikm/Gensim_word2vec">项目完整地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最开始需要新建一个conda环境&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;conda create -n word2vec python=3</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Host文件备份</title>
    <link href="https://ruvikm.gitee.io/2023/07/03/Host%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD/"/>
    <id>https://ruvikm.gitee.io/2023/07/03/Host%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD/</id>
    <published>2023-07-03T01:39:35.000Z</published>
    <updated>2023-07-03T01:40:54.437Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span> Copyright (c) 1993-2009 Microsoft Corp.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> This is a sample HOSTS file used by Microsoft TCP/IP for Windows.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> This file contains the mappings of IP addresses to host names. Each</span><br><span class="line"><span class="params">#</span> entry should be kept on an individual line. The IP address should</span><br><span class="line"><span class="params">#</span> be placed in the first column followed by the corresponding host name.</span><br><span class="line"><span class="params">#</span> The IP address and the host name should be separated by at least one</span><br><span class="line"><span class="params">#</span> space.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Additionally, comments (such as these) may be inserted on individual</span><br><span class="line"><span class="params">#</span> lines or following the machine name denoted by a &#x27;<span class="params">#</span>&#x27; symbol.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> For example:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> 102.54.94.97 rhino.acme.com <span class="params">#</span> source server</span><br><span class="line"><span class="params">#</span> 38.25.63.10 x.acme.com <span class="params">#</span> x client host</span><br><span class="line"><span class="params">#</span> localhost name resolution is handled within DNS itself.</span><br><span class="line"><span class="params">#</span> 127.0.0.1 localhost</span><br><span class="line"><span class="params">#</span> ::1 localhost</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Github</span><br><span class="line">140.82.114.4 github.com</span><br><span class="line">199.232.69.194 github.global.ssl.fastly.net</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight tex&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;#&lt;/span&gt; Copyright (c) 1993-2009 Micr</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>复现论文《Efficient Estimation of Word Representations in Vector Space》（未跑通中）</title>
    <link href="https://ruvikm.gitee.io/2023/07/03/%E5%A4%8D%E7%8E%B0%E8%AE%BA%E6%96%87%E3%80%8AEfficient%20Estimation%20of%20Word%20Representations%20in%20Vector%20Space%E3%80%8B/"/>
    <id>https://ruvikm.gitee.io/2023/07/03/%E5%A4%8D%E7%8E%B0%E8%AE%BA%E6%96%87%E3%80%8AEfficient%20Estimation%20of%20Word%20Representations%20in%20Vector%20Space%E3%80%8B/</id>
    <published>2023-07-03T01:16:30.000Z</published>
    <updated>2023-07-04T11:34:32.836Z</updated>
    
    <content type="html"><![CDATA[<p>Word2Vec工具的出处在一篇<a href="https://arxiv.org/abs/1301.3781">论文</a>《Efficient Estimation of Word Representations in Vector Space》中</p><p>从论文中可以找到提供的<a href="https://code.google.com/p/word2vec/">开源地址</a>，但是发现跳转网页的时候会显示<code>404</code>，于是换了一种方法<a href="https://ruvikm.gitee.io/2023/07/01/%E5%AE%89%E8%A3%85Word2Vec/">安装Word2Vec</a></p><p>作者提供的开源地址中，提供了论文的<a href="https://storage.googleapis.com/google-code-archive-source/v2/code.google.com/word2vec/source-archive.zip">源码</a>，解压源码的压缩包然后用<code>Pycharm</code>打开，然后用<code>Pycharm</code>切换到<code>Word2Vec</code>环境（如果发现解压错误需要先新建一个名为<code>Word2Vec</code>的文件夹）</p><p><img src="https://s1.ax1x.com/2023/07/03/pCrmbDO.png" alt="屏幕截图 2023-07-03 095919"></p><p>打开后找到作者写的<code>README</code>文件</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Tools for computing distributed representtion of words</span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line">We provide an implementation of the Continuous Bag-of-Words (CBOW) and the Skip-gram model (SG), as well as several demo scripts.</span><br><span class="line"></span><br><span class="line">Given a text corpus, the word2vec tool learns a vector for every word in the vocabulary using the Continuous</span><br><span class="line">Bag-of-Words or the Skip-Gram neural network architectures. The user should to specify the following:</span><br><span class="line"> - desired vector dimensionality</span><br><span class="line"> - the size of the context window for either the Skip-Gram or the Continuous Bag-of-Words model</span><br><span class="line"> - training algorithm: hierarchical softmax and / or negative sampling</span><br><span class="line"> - threshold for downsampling the frequent words </span><br><span class="line"> - number of threads to use</span><br><span class="line"> - the format of the output word vector file (text or binary)</span><br><span class="line"></span><br><span class="line">Usually, the other hyper-parameters such as the learning rate do not need to be tuned for different training sets. </span><br><span class="line"></span><br><span class="line">The script demo-word.sh downloads a small (100MB) text corpus from the web, and trains a small word vector model. After the training</span><br><span class="line">is finished, the user can interactively explore the similarity of the words.</span><br><span class="line"></span><br><span class="line">More information about the scripts is provided at https://code.google.com/p/word2vec/</span><br></pre></td></tr></table></figure><p>翻译一下后</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">计算单词的分布式表示的工具</span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line">我们提供了一个连续词袋（CBOW）和跳格模型（SG）的实现，以及几个演示脚本。</span><br><span class="line"></span><br><span class="line">给定一个文本语料库，word2vec工具为词汇库中的每个词学习一个向量，使用连续词袋或跳格模式。</span><br><span class="line">字袋或跳格神经网络结构为词汇中的每个词学习一个向量。用户应该指定以下内容：</span><br><span class="line"> - 希望的向量维度</span><br><span class="line"> - Skip-Gram或Continuous Bag-of-Words模型的上下文窗口的大小</span><br><span class="line"> - 训练算法：层次化的softmax和/或负采样</span><br><span class="line"> - 对频繁出现的词进行下采样的阈值 </span><br><span class="line"> - 要使用的线程数</span><br><span class="line"> - 输出词向量文件的格式（文本或二进制）。</span><br><span class="line"></span><br><span class="line">通常情况下，其他超参数，如学习率，不需要针对不同的训练集进行调整。</span><br><span class="line"></span><br><span class="line">脚本demo-word.sh从网上下载了一个小型（100MB）文本语料库，并训练了一个小型的词向量模型。训练结束后</span><br><span class="line">训练完成后，用户可以交互式地探索这些词的相似性。</span><br><span class="line"></span><br><span class="line">关于这些脚本的更多信息，请见https://code.google.com/p/word2vec/</span><br></pre></td></tr></table></figure><p>那就先跑一下<code>demo-word.sh</code>这个脚本试试吧，首先用万能的chatGPT把其转换成<code>demo-word.bat</code>脚本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> not exist text8 (</span><br><span class="line">    powershell -Command <span class="string">&quot;&amp; &#123; Invoke-WebRequest http://mattmahoney.net/dc/text8.zip -OutFile text8.gz &#125;&quot;</span></span><br><span class="line">    powershell -Command <span class="string">&quot;&amp; &#123; Expand-Archive -Path text8.gz -DestinationPath . -Force &#125;&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">time word2vec -train text8 -output vectors.bin -cbow 1 -size 200 -window 8 -negative 25 -hs 0 -sample 1e-4 -threads 20 -binary 1 -iter 15</span><br><span class="line"></span><br><span class="line">distance vectors.bin</span><br></pre></td></tr></table></figure><p>跑一下试试吧</p><p><img src="https://s1.ax1x.com/2023/07/03/pCrmXUH.png" alt="image-20230703100224888"></p><p>按照提示改改吧</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> not exist text8 (</span><br><span class="line">    powershell -Command <span class="string">&quot;&amp; &#123; Invoke-WebRequest http://mattmahoney.net/dc/text8.zip -OutFile text8.zip &#125;&quot;</span></span><br><span class="line">    powershell -Command <span class="string">&quot;&amp; &#123; Expand-Archive -Path text8.zip -DestinationPath . -Force &#125;&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">time word2vec -train text8 -output vectors.bin -cbow 1 -size 200 -window 8 -negative 25 -hs 0 -sample 1e-4 -threads 20 -binary 1 -iter 15</span><br><span class="line"></span><br><span class="line">distance vectors.bin</span><br></pre></td></tr></table></figure><p>再跑试试</p><p><img src="https://s1.ax1x.com/2023/07/03/pCrM8Ig.png" alt="image-20230703100810359"></p><p>好像是<code>distance vectors.bin</code>不太对，按照原来的脚本改成<code>./distance vectors.bin</code>试试</p><p>跑了一下还报错，用一天一次的<code>chatGPT-4</code>转换了一下康康</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> not exist text8 (</span><br><span class="line">  powershell -Command <span class="string">&quot;Invoke-WebRequest -Uri &#x27;http://mattmahoney.net/dc/text8.zip&#x27; -OutFile &#x27;text8.gz&#x27;&quot;</span></span><br><span class="line">  gzip -d text8.gz -f</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Calculating word vectors...</span><br><span class="line">powershell -Command <span class="string">&quot;Measure-Command &#123; .\word2vec -train text8 -output vectors.bin -cbow 1 -size 200 -window 8 -negative 25 -hs 0 -sample 1e-4 -threads 20 -binary 1 -iter 15 &#125; | Select-Object TotalSeconds&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Running distance...</span><br><span class="line">.\distance vectors.bin</span><br></pre></td></tr></table></figure><p>然后把.gz换成zip试试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> not exist text8 (</span><br><span class="line">  powershell -Command <span class="string">&quot;Invoke-WebRequest -Uri &#x27;http://mattmahoney.net/dc/text8.zip&#x27; -OutFile &#x27;text8.zip&#x27;&quot;</span></span><br><span class="line">  gzip -d text8.zip -f</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Calculating word vectors...</span><br><span class="line">powershell -Command <span class="string">&quot;Measure-Command &#123; .\word2vec -train text8 -output vectors.bin -cbow 1 -size 200 -window 8 -negative 25 -hs 0 -sample 1e-4 -threads 20 -binary 1 -iter 15 &#125; | Select-Object TotalSeconds&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Running distance...</span><br><span class="line">.\distance vectors.bin</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/03/pCrM4eK.png" alt="image-20230703101439557"></p><p>居然出来一个神奇的结果，再改改删删试试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> not exist text8 (</span><br><span class="line">  powershell -Command <span class="string">&quot;Invoke-WebRequest -Uri &#x27;http://mattmahoney.net/dc/text8.zip&#x27; -OutFile &#x27;text8.zip&#x27;&quot;</span></span><br><span class="line">  zip -d text8.zip -f</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Calculating word vectors...</span><br><span class="line">powershell -Command <span class="string">&quot;Measure-Command &#123; .\word2vec\truck -train text8 -output vectors.bin -cbow 1 -size 200 -window 8 -negative 25 -hs 0 -sample 1e-4 -threads 20 -binary 1 -iter 15 &#125; | Select-Object TotalSeconds&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Running distance...</span><br><span class="line">.\distance vectors.bin</span><br></pre></td></tr></table></figure><p>好吧，还是上面那个错</p><p>又改了改</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> not exist text8 (</span><br><span class="line">  powershell -Command <span class="string">&quot;Invoke-WebRequest -Uri &#x27;http://mattmahoney.net/dc/text8.zip&#x27; -OutFile &#x27;text8.zip&#x27;&quot;</span></span><br><span class="line">  zip -d text8.zip -f</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Calculating word vectors...</span><br><span class="line">powershell -Command <span class="string">&quot;Measure-Command &#123; .\word2vec.c -train text8 -output vectors.bin -cbow 1 -size 200 -window 8 -negative 25 -hs 0 -sample 1e-4 -threads 20 -binary 1 -iter 15 &#125; | Select-Object TotalSeconds&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Running distance...</span><br><span class="line">.\distance.c vectors.bin</span><br></pre></td></tr></table></figure><p>跑一下试试</p><p><img src="https://s1.ax1x.com/2023/07/03/pCrQpFg.png" alt="image-20230703102332133"></p><p>然后还突然弹出来我的<code>vs code</code>，就是这个<code>./distance</code>怎么老报错啊</p><p>在问问万能的<code>chatGPT</code>吧</p><p><img src="https://s1.ax1x.com/2023/07/03/pCrQGm6.png" alt="image-20230703102608238"></p><p>但是好像我没有<code>distance</code>这个文件啊，搜一下康康</p><p><img src="https://s1.ax1x.com/2023/07/03/pCrUfaR.png" alt="image-20230703125901033"></p><p>好吧，看来还是有的，那就简单了，再把脚本修改一下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> not exist text8 (</span><br><span class="line">  powershell -Command <span class="string">&quot;Invoke-WebRequest -Uri &#x27;http://mattmahoney.net/dc/text8.zip&#x27; -OutFile &#x27;text8.zip&#x27;&quot;</span></span><br><span class="line">  zip -d text8.zip -f</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Calculating word vectors...</span><br><span class="line">powershell -Command <span class="string">&quot;Measure-Command &#123; .\word2vec.c -train text8 -output vectors.bin -cbow 1 -size 200 -window 8 -negative 25 -hs 0 -sample 1e-4 -threads 20 -binary 1 -iter 15 &#125; | Select-Object TotalSeconds&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Running distance...</span><br><span class="line">.\distance.c vectors.bin</span><br></pre></td></tr></table></figure><p>跑一次试试</p><p><img src="https://s1.ax1x.com/2023/07/03/pCrUoRK.png" alt="image-20230703130041541"></p><p>ohhhh这是运行完了？再康康文档对这个<code>demo</code>的解释吧</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">脚本demo-word.sh从网上下载了一个小型（100MB）文本语料库，并训练了一个小型的词向量模型。训练结束后</span><br><span class="line">训练完成后，用户可以交互式地探索这些词的相似性。</span><br></pre></td></tr></table></figure><p>好像怎么也得有一点结果吧，我感觉是本来要在cmd里运行的<code>.c文件</code>，结果却用<code>vscode</code>打开了</p><p>试试在脚本里能不能修改一下，继续求助chatGPT</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">gcc -o your_program your_program.c</span><br><span class="line">your_program.exe</span><br></pre></td></tr></table></figure><p>请注意，<code>your_program</code>应替换为您的C程序的名称，<code>your_program.c</code>应替换为您的C源代码文件的名称。</p><p>照猫画虎的改改试试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> not exist text8 (</span><br><span class="line">  powershell -Command <span class="string">&quot;Invoke-WebRequest -Uri &#x27;http://mattmahoney.net/dc/text8.zip&#x27; -OutFile &#x27;text8.zip&#x27;&quot;</span></span><br><span class="line">  zip -d text8.zip -f</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Calculating word vectors...</span><br><span class="line">powershell -Command <span class="string">&quot;Measure-Command &#123; word2vec.c -train text8 -output vectors.bin -cbow 1 -size 200 -window 8 -negative 25 -hs 0 -sample 1e-4 -threads 20 -binary 1 -iter 15 &#125; | Select-Object TotalSeconds&quot;</span></span><br><span class="line">word2vec.exe</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Running distance...</span><br><span class="line">gcc -o distance distance.c </span><br><span class="line">vectors.bin</span><br><span class="line">distance.exe</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/03/pCraKQU.png" alt="image-20230703130956790"></p><p>emmmm意料之中,还是不能自己改啊，继续用chatGPT逐句改吧</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> not exist text8 (</span><br><span class="line">  powershell -Command <span class="string">&quot;Invoke-WebRequest -Uri &#x27;http://mattmahoney.net/dc/text8.zip&#x27; -OutFile &#x27;text8.zip&#x27;&quot;</span></span><br><span class="line">  zip -d text8.zip -f</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Calculating word vectors...</span><br><span class="line">gcc -o word2vec word2vec.c</span><br><span class="line">time ./word2vec -train text8 -output vectors.bin -cbow 1 -size 200 -window 8 -negative 25 -hs 0 -sample 1e-4 -threads 20 -binary 1 -iter 15</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Running distance...</span><br><span class="line">gcc -o distance distance.c</span><br><span class="line">./distance vectors.bin</span><br></pre></td></tr></table></figure><p>跑一跑试试</p><p><img src="https://s1.ax1x.com/2023/07/03/pCraTkn.png" alt="image-20230703132032334"></p><p>感觉是用gcc编译运行了，但是好像是输入的时间变了又不对了。试试自己能不能把两个结合一下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> not exist text8 (</span><br><span class="line">  powershell -Command <span class="string">&quot;Invoke-WebRequest -Uri &#x27;http://mattmahoney.net/dc/text8.zip&#x27; -OutFile &#x27;text8.zip&#x27;&quot;</span></span><br><span class="line">  zip -d text8.zip -f</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Calculating word vectors...</span><br><span class="line"><span class="string">&quot;Measure-Command &#123;</span></span><br><span class="line"><span class="string">gcc -o word2vec word2vec.c</span></span><br><span class="line"><span class="string">--train text8 ^</span></span><br><span class="line"><span class="string">    --output vectors.bin ^</span></span><br><span class="line"><span class="string">    --cbow 1 ^ </span></span><br><span class="line"><span class="string">    --size 200 ^</span></span><br><span class="line"><span class="string">    --window 8 ^</span></span><br><span class="line"><span class="string">    --negative 2 ^</span></span><br><span class="line"><span class="string">    --hs 0 ^</span></span><br><span class="line"><span class="string">    --sample 1e-4 ^</span></span><br><span class="line"><span class="string">    --threads 20 ^</span></span><br><span class="line"><span class="string">    --binary 1 ^</span></span><br><span class="line"><span class="string">    --iter 15 ^</span></span><br><span class="line"><span class="string">&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Running distance...</span><br><span class="line">gcc -o distance distance.c</span><br><span class="line">--output vectors.bin </span><br></pre></td></tr></table></figure><p>好吧，还是崩了。那就直接用<code>visual studio</code>跑一下代码试试吧</p><p>ps：如果显示找不到启动项可以试试<a href="https://blog.csdn.net/qq_46070108/article/details/128761974">这个方法</a></p><p><img src="https://s1.ax1x.com/2023/07/03/pCrysRs.png" alt="image-20230703152429717"></p><p>打扰了…找一个视频吧，我记得哔哩哔哩大学有使用这个工具的教程</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Word2Vec工具的出处在一篇&lt;a href=&quot;https://arxiv.org/abs/1301.3781&quot;&gt;论文&lt;/a&gt;《Efficient Estimation of Word Representations in Vector Space》中&lt;/p&gt;
&lt;p&gt;从论</summary>
      
    
    
    
    <category term="论文复现" scheme="https://ruvikm.gitee.io/categories/%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>安装Word2Vec</title>
    <link href="https://ruvikm.gitee.io/2023/07/01/%E5%AE%89%E8%A3%85Word2Vec/"/>
    <id>https://ruvikm.gitee.io/2023/07/01/%E5%AE%89%E8%A3%85Word2Vec/</id>
    <published>2023-07-01T08:21:49.000Z</published>
    <updated>2023-07-01T15:01:00.814Z</updated>
    
    <content type="html"><![CDATA[<p>由于最近需要用到一个预处理的数据集，方法在<a href="https://arxiv.org/abs/1301.3781">这篇论文</a>《Efficient Estimation of Word Representations in Vector Space》里，于是打算尝试能不能复现一下，论文提供了<a href="https://code.google.com/archive/p/word2vec/">代码地址</a>，但是当我打开下载的时候，却发现是404</p><p><img src="https://s1.ax1x.com/2023/07/01/pCB5ZT0.png" alt="image-20230701163100641"></p><p>于是经过一番搜索，找到了最新的<a href="https://pypi.org/project/word2vec/">地址</a>（应该是吧</p><p>先创建一下新的虚拟环境</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n word2vec python=3.8</span><br><span class="line">conda activate word2vec</span><br></pre></td></tr></table></figure><p>然后安装<code>numpy</code>、<code>scipy</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install numpy</span><br><span class="line">pip install scipy</span><br></pre></td></tr></table></figure><p>安装<a href="https://visualstudio.microsoft.com/zh-hans/vs/">Microsoft Visual C++ 14.0</a></p><p>下载下来是一个安装器，然后进行如下操作</p><p><img src="https://s1.ax1x.com/2023/07/01/pCBoUQe.png" alt="屏幕截图 2023-07-01 165446"></p><p>然后</p><p><img src="https://s1.ax1x.com/2023/07/01/pCBodLd.png" alt="屏幕截图 2023-07-01 165358"></p><p>最后安装有点麻烦的<code>gcc</code>，首先使用清华镜像下载<a href="http://files.1f0.de/mingw/mingw-w64-gcc-12.2-stable-r38.7z">mingw-w64-gcc</a>，然后解压的位置选一个自己能记住的位置，比如我的就是</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">G:<span class="keyword">\Program</span> Files<span class="keyword">\MinGW</span>-w64</span><br></pre></td></tr></table></figure><p>然后把<code>bin</code>目录添加到系统变量里</p><p>例如我的路径就是</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">G:<span class="keyword">\Program</span> Files<span class="keyword">\MinGW</span>-w64<span class="keyword">\mingw</span>-w64-gcc-12.2-stable-r38<span class="keyword">\bin</span></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/01/pCBTy7R.png" alt="屏幕截图 2023-07-01 172554"></p><p>最后测试一下时候配置成功</p><p>在<code>D盘</code>根目录先新建一个<code>helloword.c</code>的文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用<code>cmd</code>到<code>D盘</code>根目录</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">cd/d D:</span><br></pre></td></tr></table></figure><p>用gcc编译</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">gcc helloword.c</span><br></pre></td></tr></table></figure><p><strong>如果没报错说明其实已经配置好了，想看文件运行结果的可以继续输入</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.exe</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/01/pCB7EgU.png" alt="image-20230701173710147"></p><p>这样，<code>word2vec</code>所需的组件就算全部安装完了，下面正式开始安装<code>word2vec</code>（在conda那个命令窗口哦，希望不要报错！）</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">pip install word2vec</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/01/pCB7w5t.png" alt="image-20230701174216784"></p><p>如果出现这个问题，重启一下试试。本人就是重启完莫名安装成功了，可能是刚刚有的组件需要重启吧</p><p><img src="https://s1.ax1x.com/2023/07/01/pCDCOPS.png" alt="image-20230701225337075"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于最近需要用到一个预处理的数据集，方法在&lt;a href=&quot;https://arxiv.org/abs/1301.3781&quot;&gt;这篇论文&lt;/a&gt;《Efficient Estimation of Word Representations in Vector Space》里，于是</summary>
      
    
    
    
    <category term="论文复现" scheme="https://ruvikm.gitee.io/categories/%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Win11转移conda环境——从C盘转移到D盘</title>
    <link href="https://ruvikm.gitee.io/2023/06/28/Win11%E8%BD%AC%E7%A7%BBconda%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94%E4%BB%8EC%E7%9B%98%E8%BD%AC%E7%A7%BB%E5%88%B0D%E7%9B%98/"/>
    <id>https://ruvikm.gitee.io/2023/06/28/Win11%E8%BD%AC%E7%A7%BBconda%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94%E4%BB%8EC%E7%9B%98%E8%BD%AC%E7%A7%BB%E5%88%B0D%E7%9B%98/</id>
    <published>2023-06-28T01:55:51.000Z</published>
    <updated>2023-07-14T03:12:32.576Z</updated>
    
    <content type="html"><![CDATA[<p>原本就是将<code>Anaconda</code>安装到了C盘，结果发现环境他还是默认安装到了C盘，就打算再转移一下</p><p>conda版本为</p><p><img src="https://gitee.com/Ruvikm/pic/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-28%20095709.png" alt="屏幕截图 2023-06-28 095709"></p><p>首先找到Win11下面的环境位置</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">C:<span class="keyword">\Users</span><span class="keyword">\用</span>户名<span class="keyword">\.</span>conda<span class="keyword">\envs</span></span><br></pre></td></tr></table></figure><p>比如我的就是</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">C:<span class="keyword">\Users</span><span class="keyword">\Arona</span><span class="keyword">\.</span>conda<span class="keyword">\envs</span></span><br></pre></td></tr></table></figure><p>找到D盘安装<code>Anaconda</code>的位置</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">D:<span class="keyword">\ProgramData</span><span class="keyword">\anaconda</span>3<span class="keyword">\envs</span></span><br></pre></td></tr></table></figure><p>C盘的将<code>envs</code>文件夹剪切过去，环境迁移一半就完成了</p><p>测试了一下，如果新建一个环境，默认还会装在C盘</p><p><img src="https://gitee.com/Ruvikm/pic/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-28%20101113.png" alt="屏幕截图 2023-06-28 101113"></p><p>于是要修改一下环境的默认安装位置</p><p>找到用户目录下的<code>.condarc</code>文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">explorer %USERPROFILE%</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Ruvikm/pic/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-28%20101811.png" alt="屏幕截图 2023-06-28 101811"></p><p>用<code>Visual Studio Code</code>打开</p><p>加入这段话</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">envs<span class="built_in">_</span>dirs:</span><br><span class="line">  - D:<span class="keyword">\ProgramData</span><span class="keyword">\anaconda</span>3<span class="keyword">\envs</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Ruvikm/pic/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-28%20102057.png" alt="屏幕截图 2023-06-28 102057"></p><p>这样默认就会安装到D盘了</p><p>测试一下，新建一个名为<code>test1</code>的环境</p><p><img src="https://gitee.com/Ruvikm/pic/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-28%20102249.png" alt="屏幕截图 2023-06-28 102249"></p><p>如果发现地址还没变的话，可以继续以下操作</p><p>找到<code>Anaconda</code>的文件夹，右键属性—安全，把users下面的权限全部打钩就行</p><p><img src="https://gitee.com/Ruvikm/pic/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-28%20102811.png" alt="屏幕截图 2023-06-28 102811"></p><p>应用过程中可能还会出现这种错误</p><p><img src="https://gitee.com/Ruvikm/pic/raw/master/img/image-20230628103929133.png" alt="image-20230628103929133"></p><p>可以按照这个<a href="https://blog.csdn.net/qq_37653414/article/details/103462173">博客</a>的方法来解决，那个图比较清楚</p><p><img src="https://gitee.com/Ruvikm/pic/raw/master/img/image-20230628104526618.png" alt="image-20230628104526618"></p><p>等待一段时间</p><p>然后再回到上述操作，把users下面的权限全部打钩，再等待亿段时间</p><p><img src="https://gitee.com/Ruvikm/pic/raw/master/img/image-20230628104915818.png" alt="image-20230628104915818"></p><p>完成后最后测试一下，新建一个名为test2的环境</p><p><img src="https://gitee.com/Ruvikm/pic/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-28%20105049.png" alt="屏幕截图 2023-06-28 105049"></p><p>成功！</p><p>补充一下：</p><p>发现刚刚上述只是把环境迁移了，下载的缓存还是留在C盘</p><p>找到刚刚用户目录的.<code>condarc</code>文件，再加入几句话</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">pkgs<span class="built_in">_</span>dirs:</span><br><span class="line">  - D:<span class="keyword">\ProgramData</span><span class="keyword">\pkgs</span></span><br></pre></td></tr></table></figure><p>保存查看一下，输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda info</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/06/28/pCdNtKI.png" alt="image-20230628115703963"></p><p>说明配置成功，接下来把C盘的<code>pkgs</code>文件夹剪切到D盘刚刚的目录下就行了</p><p><img src="https://s1.ax1x.com/2023/06/28/pCdNqqx.png" alt="image-20230628115948908"></p><p>完事！</p><p>补充：</p><p>之后跑项目遇到了这个问题</p><p><img src="https://s1.ax1x.com/2023/07/14/pC41RGd.png" alt="屏幕截图 2023-07-05 155524"></p><p>这个原因是之前<code>pycharm</code>保存的环境还默认在C盘，没有自动更新环境的位置，这时候重新加载一下就好了</p><p><img src="https://s1.ax1x.com/2023/07/14/pC41Iqf.png" alt="image-20230714111213354"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原本就是将&lt;code&gt;Anaconda&lt;/code&gt;安装到了C盘，结果发现环境他还是默认安装到了C盘，就打算再转移一下&lt;/p&gt;
&lt;p&gt;conda版本为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/Ruvikm/pic/raw/master/img/</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
