<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ruvikm</title>
  <icon>https://www.gravatar.com/avatar/710ecfc7f4f0bd22cb3d5ec44d498105</icon>
  <subtitle>Nia~</subtitle>
  <link href="https://ruvikm.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://ruvikm.gitee.io/"/>
  <updated>2024-04-27T08:59:03.435Z</updated>
  <id>https://ruvikm.gitee.io/</id>
  
  <author>
    <name>Ruvikm</name>
    <email>ruvikm@126.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实习规划</title>
    <link href="https://ruvikm.gitee.io/2024/04/27/%E5%AE%9E%E4%B9%A0%E8%A7%84%E5%88%92/"/>
    <id>https://ruvikm.gitee.io/2024/04/27/%E5%AE%9E%E4%B9%A0%E8%A7%84%E5%88%92/</id>
    <published>2024-04-27T08:57:02.000Z</published>
    <updated>2024-04-27T08:59:03.435Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="169fbf894317b657214b8fe189f1d938f36230aa167e9b8290bd75c409eabdb9">f666a1e82130d441cf5f17739ffab407d3700cc5340db38aca8cc539ab20da66955efd2229a88f228c2b043e435c632234ba58b9599b5db4b315db24ea1b712ffda270aa7ecfeb9bb15204a9e2b665faa99d7dc1f44755898b8a4c13ef5c4e75693ff484b9043ddbf7e02452aa852453a1f2169c2e78244c91f9cedc486857f58ddebe03739017a0f0c8fad7829e6c863ad8de560ae7df1b4c3021031958502fbd651fe5815aaabc24e907a929795c4cc6aa6eb605c57f320585bc5f219625ad8530e074ccd933d19870b1bdfa1467c5fbf33a97f221a58b62387520c75882ee34f7e690b3ccec362968080bb4ecc7cb9b5a1bafcc33d7ab4eafb2a10e7c1778d8ea3533b9950a89ef536912202a357ce2e072b2b506317d66fcd16da30fcd87fbc0edbb024941f7a8380396bced2240b475c4427508876650eba8d00fd37da9dfad6ed5f01fa4fe0f2307421d01166d99dab9bdee0762d8c6a098f5562149d2f15452c3ea62f8878c4532cd504ae42ae8d1cb84d61e5c72428f30cc65623d2a87bbe0538162ed46374407381efd5302c80883113b7da2d20cf8c5ae63217a28438c22d5caa540c4ba41673fed7060520746472c3a2b8144984bff025db8b4899edfd0b0351d156b6510f8ddb0cd165a9dfc76b2882c07576f8374ad8eaa7e6780ee5d27ba29b237f0ee0227face9e6dc28239c9776cc5b4f1bb2303988dfe685117e7398dc531721f653f1c68209e8d1149c59fadaa530c9ed4ab00e37f5682a81ee3fcca8fe4ef8ad2d46d79c4d88df1a1d8fa7b29a8b257ce9665c3d582d2cb449a717d82788e2f00fb96a1fb24a277c0fddf331c13be24aac49cbcb4c00b8784ade7c0b847b519767eba7992ff4885ff87d0706ea42fcbfb82534a8b1afce4ba3733f92f96c5a6bec26cef9086acd289280e958155b740ec413e5ecfa65e0d9a95dd31c115943a1e8c0da8c45cca9e0862aa44d0fe3cc8eb28cbe972096a3297384fb3ae1e0a56a91260f3a4410e7d417784d425bb7fe803bc7ebd73b4f93205cd4ca02a4742604fa85d6f47966372808ff9f9f29156737989aaaefbde90d9c1d9902c898d11b93f9bc3a9af60c172ae29d29b046f994d8b297c0a6427aa9347988003aa69d6e9a61983ac9a7807cd5390b7afa16c61d8ab3f940629af963d3530deea92c448c60a40f73e5dd967b06bacf6ecf86c238c23cf0a07b222ab9b12ff3b39341b9f78e30fe703ec5e087dd2511ffcd77deba839cf22fbd139be374a10c3fb2c2a2dca5335859d39c7d051b01dda3280122f481621d5d464206ac66a6ff10f2eb24f473ab5df37b4ee05ef2c071eea001842ac1e6620f4f67f1ccd3486bb234122ab2f4b9772c3e11e3bf8f94bf454a0f32c0f3fd8e3db9ba8e6b9dfe56e6d9b323125eb205b94d417b4aba9ed1c868ad172e77f55e2d870eb789d4e180afff26b50f3d2b0c98fa30cd7b835481752f1f1aaa53fc66a5cd42e3fc5e0d5883222901b1ab3bc4e3dab2ef372ed7e284aa0adbebf9f32adeb893539a21b6948fa21d778de6f8101041b7433c7148f9fb3e45c6c4ec0eb0c7ac8ada2ebf891743d3f6890f7d98b3784f3948c6376003ebfb7b754e923caf1f026475ab7b17e5f12f5259783da9628503130c9a7b480854e61cc632e08b748ac49442ecf052ec4c2d70173d803d40d6809372e8a98b08103d54e73c37812cd984a8620592700c5ff180aaf1d24b7e5cb50a7a165c107899ea755517084ae52f79ec15fbe27d3e3244f9e80bce20f836892869eadb96ae9b077f885bfda65130481af9bc05bf878125385bbd779c34721e93db5908fe4c2d0bd9b3a2848afc01e81e1b946bff595d6e22d300f7a5a29dddcecfa065a0bdb47e9b02095b7c04e8f0fc359484e00b66cb5f15b86675234bfaf4fd85b89c8e038f4dfd3601f42688b21c4eb81944b0e1cd8e3e79e5dbb9c4afc4dffc043ad601879cfbab35474003959296db2f1db84256cec6884a91c6297137ccc1ae47509574b2b00e2b8bc3bdca647fb10610d5aec4bb73f4db006aaf8e75b95b9021eb6de8794c0f62565df31d177b4bf44d2a4be836ea73f280c1f88a62d339d44fd677e9b499518928bc15db6f95cb55f039c221f137385de5f328624a84b3b3ca97b3015da55b7efadd603ca54a48d3ba7ea5001707b5dce7c708f57313917a688b6594c4fa1524d7737fa55e49df0767201c9b97959e8c2486b2b898f4ab2ad2c693456e292c2b1f047e902c531cda78811b1a80cf3ecfb0a7b42c6a225fc205012012378a323016a49798416098885d2477bc42136c03f5f32cab550178da78e9b2d619152728ef3813651bb753e097539178dcf4a6d434fb6bf050073f9d2c978e42a70e54206b81ab863da22dd45df38d1154fe9a12bec7f971b6613e523b86b0f5a5509508f477c882a3ac1fc466b3ad764ce2bcd8eec4e8ff73697157f3c90e889c9dad10d664f82c3d44dae39bd68696348e8a107dbd5c44b33a4e7095cc8ccb2bb929b8dafdcd90d22fba4a460ecbb0165cd034c285d21f4aa6114accbca3f9d40429800976c7b6cfe5b86bc09406c865d8a7d38780cd871e04e71f93a764e66099325223716d150e58b0b771dede2ff1ac971b9db39da2ab4fafa9094b3a2d9d80cc58f2b09537b9bea48d0647e1b1da1ff49f73b6a1aa7a257ccee95e13b136f5d9a935b80015f9e1b908d8a9c4607a1adb06bb0a1be22724dc10155c028ec746b0ab25dada915eef1468e49734aace49f86416a4ce34f13d69e31bda8e95ebb265feb732bb2167e98d934033ac9eddb504da9c039ef66b21dffd4127b62204f3424579abb859500dd0414cb1dd6770b242bafe5adc10f61441c58271fec5718598182eeab1b8cf675e03c73226d68b1fb577e776a37d5edab4bd1592d310f2a51d2426bb8c048f89cc535194cf9dca54fba75a2997166d783fc96f777db3aa2bbeb00811ce9cd70640ae53945174bd13cca8846ad4ae76448c79dd7e4fc9c4be39896c7ad4af19cd3d973e867eb5cf5bc60d8837287c8cbc08942ca428e3c6c9b98f131c2b4c53bb4cf6881f5c2f2714ea67f4b4dc375d68cb46d4ddb27fe0c7f98ec0fd5812d4c3c22efef3bf575360a804ed6bebb877982d360c6e6e8e5d3f7365b4bf0f61d7d07046d7a661e72fe3ccf3662551601e26f614262c756050189a7d2c3890b68b72866c99889a41a624212000fc669d95b3137bd5e89852f0c65ee64401fd2eb364e6babcdd6703532734a6e6c242a710f1104e53228ad8769e9824ca6e02b433bd9d1aadc0204673ffde93d56703ee508cfff4958e9550216097e60c4f02591c840127729b9e8bb8d7812958b66ed989e2e7b0a9c92e2cbd61b0a26ae5b396da92dc31ed50d98d685770f91c9d3b26dca7b435e75222ed915d9018d692f10b98e64b562a6733fb1bdb3c978115f7dec574750f04bf3f726bcc9b3476f87089536c46d97fd80618d4b6dff3ebedb5150fa4e833d06e4195da64423b107fa214b3aa94c1979d94085dc6dbdffe0160398d8afa6050dcc29edc052fee7f6133cdef42a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="人生规划" scheme="https://ruvikm.gitee.io/categories/%E4%BA%BA%E7%94%9F%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>学校GPU平台使用教程(优化版)</title>
    <link href="https://ruvikm.gitee.io/2024/04/01/%E5%AD%A6%E6%A0%A1GPU%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E6%94%B9%E8%BF%9B%E7%89%88/"/>
    <id>https://ruvikm.gitee.io/2024/04/01/%E5%AD%A6%E6%A0%A1GPU%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E6%94%B9%E8%BF%9B%E7%89%88/</id>
    <published>2024-04-01T11:10:22.000Z</published>
    <updated>2024-04-01T11:20:04.095Z</updated>
    
    <content type="html"><![CDATA[<p>首先连接内网登录<a href="http://paas.183-175-12-11.nip.io:30080/">平台</a></p><p>一般使用的话，直接找到<code>开发环境</code>一栏，创建环境。然后通过<code>Pycharm</code>中的<code>ssh</code>连接</p><p><img src="https://s1.ax1x.com/2023/08/28/pPaw2X6.png" alt="屏幕截图 2023-08-28 221321"></p><p>在<code>Pycharm</code>中，找到工具—部署—配置</p><p><img src="https://s1.ax1x.com/2023/08/28/pPad5zq.png" alt="image-20230828220300678"></p><p>点击<code>+</code>后选择<code>SFTP</code></p><p><img src="https://s1.ax1x.com/2023/08/28/pPaw5Ae.png" alt="屏幕截图 2023-08-28 221526"></p><p>在<code>SSH配置</code>那里后点击后面<code>...</code></p><p><img src="https://s1.ax1x.com/2023/08/28/pPawbct.png" alt="屏幕截图 2023-08-28 092517"></p><p>进入后填写主机名和用户名，这里详细讲一下</p><p>例如平台给的ssh连接是</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ssh://root@paas.xxx-xxx-xx-xx.nip.io:xxxxx</span><br></pre></td></tr></table></figure><p>这里用户名就需要填写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root</span><br></pre></td></tr></table></figure><p>主机名填写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">paas.xxx-xxx-xx-xx.nip.io</span><br></pre></td></tr></table></figure><p>端口号填写<code>xxxxx</code></p><p>然后填写创建环境时设置的密码</p><p><img src="https://s1.ax1x.com/2023/08/28/pPawjHS.png" alt="屏幕截图 2023-08-28 092917"></p><p>这一步完事以后，点击确定，返回到之前的页面，点击<code>映射</code></p><p><img src="https://s1.ax1x.com/2023/08/30/pPd7RaD.png" alt="屏幕截图 2023-08-30 145658"></p><p>配置好本机的地址和远程的地址，点击确认</p><p><img src="https://s1.ax1x.com/2023/08/30/pPd7LdS.png" alt="image-20230830145937224"></p><p>之后选择工具—部署—选项</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdHIkF.png" alt="QQ截图20230830150656"></p><p>可以根据自己习惯决定是否配置一下</p><p>之后就可以用Pycharm作为修改代码和文件传输的工具了</p><p>由于Pycharm自带的终端个人认为并不好用，所以可以使用Xshell软件使用终端操作，Xshell的配置同上</p><p><img src="https://s21.ax1x.com/2024/04/01/pF7gw01.png" alt></p><p>由于已经在里面安装了Anaconda，所以每次跑一个项目的时候新建一个虚拟环境即可</p><h3 id="切换环境"><a href="#切换环境" class="headerlink" title="切换环境"></a>切换环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate cu118py310</span><br></pre></td></tr></table></figure><h3 id="查看并删除环境"><a href="#查看并删除环境" class="headerlink" title="查看并删除环境"></a>查看并删除环境</h3><h4 id="查看环境列表"><a href="#查看环境列表" class="headerlink" title="查看环境列表"></a>查看环境列表</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda info --<span class="built_in">env</span></span><br></pre></td></tr></table></figure><h4 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda remove -n 环境名 --all</span><br><span class="line"></span><br><span class="line">eg:conda remove -n code --all</span><br></pre></td></tr></table></figure><h3 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n 环境名 python=版本号</span><br><span class="line"></span><br><span class="line">eg:conda create -n ChineseBERT python=3.8</span><br></pre></td></tr></table></figure><h3 id="退出当前环境"><a href="#退出当前环境" class="headerlink" title="退出当前环境"></a>退出当前环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate base</span><br></pre></td></tr></table></figure><h3 id="查看当前环境已安装的包"><a href="#查看当前环境已安装的包" class="headerlink" title="查看当前环境已安装的包"></a>查看当前环境已安装的包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先连接内网登录&lt;a href=&quot;http://paas.183-175-12-11.nip.io:30080/&quot;&gt;平台&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一般使用的话，直接找到&lt;code&gt;开发环境&lt;/code&gt;一栏，创建环境。然后通过&lt;code&gt;Pycharm&lt;/code&gt;中的&lt;co</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>客户端服务端跨平台移植，并添加线程</title>
    <link href="https://ruvikm.gitee.io/2024/03/31/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%A7%BB%E6%A4%8D/"/>
    <id>https://ruvikm.gitee.io/2024/03/31/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%A7%BB%E6%A4%8D/</id>
    <published>2024-03-31T12:14:57.000Z</published>
    <updated>2024-04-01T10:57:31.602Z</updated>
    
    <content type="html"><![CDATA[<p>客户端代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">//uni std</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVALID_SOCKET  (SOCKET)(~0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_ERROR            (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span><span class="comment">//C++标准线程库</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> g_bRun = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region 结构体定义</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CMD</span> &#123;</span><br><span class="line">CMD_LOGIN,</span><br><span class="line">CMD_LOGOUT,</span><br><span class="line">CMD_ERROR,</span><br><span class="line">CMD_LOGIN_RESULT,</span><br><span class="line">CMD_LOGOUT_RESULT,</span><br><span class="line">CMD_NEW_USER_JOIN</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> &#123;</span><br><span class="line"><span class="type">short</span> dataLength;</span><br><span class="line"><span class="type">short</span> cmd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader &#123;<span class="comment">//DataPackage</span></span><br><span class="line"><span class="built_in">Login</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(Login);</span><br><span class="line">cmd = CMD_LOGIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> userName[<span class="number">32</span>];</span><br><span class="line"><span class="type">char</span> PassWord[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">LoginResult</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(LoginResult);</span><br><span class="line">cmd = CMD_LOGIN_RESULT;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">Logout</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(Logout);</span><br><span class="line">cmd = CMD_LOGOUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> userName[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">LogoutResult</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(LogoutResult);</span><br><span class="line">cmd = CMD_LOGOUT_RESULT;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">NewUserJoin</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(NewUserJoin);</span><br><span class="line">cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">sock = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataPackage</span> &#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> endregion</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processor</span><span class="params">(SOCKET _cSock)</span> </span>&#123;</span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="type">char</span> szRecv[<span class="number">4096</span>] = &#123;&#125;;</span><br><span class="line"><span class="comment">// 5 接收客户端数据</span></span><br><span class="line"><span class="type">int</span> nLen = <span class="built_in">recv</span>(_cSock, szRecv, <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">DataHeader* header = (DataHeader*)szRecv;</span><br><span class="line"><span class="keyword">if</span> (nLen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;与服务器断开连接，任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (header-&gt;cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> CMD_LOGIN_RESULT: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">LoginResult* login = (LoginResult*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到服务端消息：CMD_LOGIN_RESULT, 数据长度：&quot;</span> &lt;&lt; login-&gt;dataLength &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CMD_LOGOUT_RESULT: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">LogoutResult* logout = (LogoutResult*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到服务端消息：CMD_LOGOUT_RESULT, 数据长度：&quot;</span> &lt;&lt; logout-&gt;dataLength &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CMD_NEW_USER_JOIN: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">NewUserJoin* userJoin = (NewUserJoin*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到服务端消息：CMD_LOGOUT_RESULT, 数据长度：&quot;</span> &lt;&lt; userJoin-&gt;dataLength &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cmdThread</span><span class="params">(SOCKET sock)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">char</span> cmdBuf[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">cin &gt;&gt; cmdBuf;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; cmdBuf &lt;&lt; endl;*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(cmdBuf, <span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;退出cmdThread线程&quot;</span> &lt;&lt; endl;</span><br><span class="line">g_bRun = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(cmdBuf, <span class="string">&quot;login&quot;</span>)) &#123;</span><br><span class="line">Login login;</span><br><span class="line"><span class="built_in">strcpy</span>(login.userName, <span class="string">&quot;lyd&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(login.PassWord, <span class="string">&quot;lydmm&quot;</span>);</span><br><span class="line"><span class="built_in">send</span>(sock, (<span class="type">const</span> <span class="type">char</span>*)&amp;login, <span class="built_in">sizeof</span>(Login), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(cmdBuf, <span class="string">&quot;logout&quot;</span>)) &#123;</span><br><span class="line">Logout logout;</span><br><span class="line"><span class="built_in">strcpy</span>(logout.userName, <span class="string">&quot;lyd&quot;</span>);</span><br><span class="line"><span class="built_in">send</span>(sock, (<span class="type">const</span> <span class="type">char</span>*)&amp;logout, <span class="built_in">sizeof</span>(Logout), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;不支持的命令...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="comment">//启动Windows socket 2.x环境</span></span><br><span class="line">WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA dat;</span><br><span class="line"><span class="built_in">WSAStartup</span>(ver, &amp;dat);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN32</span></span></span><br><span class="line"><span class="comment">// 用Socket API 建立一个简易的TCP服务端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 建立一个socket</span></span><br><span class="line">SOCKET _sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == _sock) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;建立Socket失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;建立Socket成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 连接服务器 connect</span></span><br><span class="line">sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">_sin.sin_family = AF_INET;</span><br><span class="line">_sin.sin_port = <span class="built_in">htons</span>(<span class="number">4567</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="comment">/*_sin.sin_addr.S_un.S_addr = inet_addr(&quot;192.168.88.130&quot;);*/</span></span><br><span class="line">_sin.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">_sin.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.88.130&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//_sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line"><span class="type">int</span>  ret = <span class="built_in">connect</span>(_sock, (sockaddr*)&amp;_sin, <span class="built_in">sizeof</span>(sockaddr_in));</span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == ret) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;连接服务器失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;连接服务器成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(cmdThread, _sock)</span></span>;</span><br><span class="line">t1.<span class="built_in">detach</span>();</span><br><span class="line"><span class="keyword">while</span> (g_bRun) &#123;</span><br><span class="line"></span><br><span class="line">fd_set fdReads;</span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdReads);</span><br><span class="line"><span class="built_in">FD_SET</span>(_sock, &amp;fdReads);</span><br><span class="line">timeval t = &#123; <span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">select</span>(_sock + <span class="number">1</span>, &amp;fdReads, <span class="number">0</span>, <span class="number">0</span>, &amp;t);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;select任务结束&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(_sock, &amp;fdReads)) &#123;</span><br><span class="line"><span class="built_in">FD_CLR</span>(_sock, &amp;fdReads);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">processor</span>(_sock)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;select任务结束2...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程thread</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;空闲时间处理其他业务 ...&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//仅仅适用于Windows</span></span><br><span class="line"><span class="comment">// Sleep(1000);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="comment">// 7 关闭套接字closesocket</span></span><br><span class="line"><span class="built_in">closesocket</span>(_sock);</span><br><span class="line"><span class="comment">// 8 清除windows socket环境</span></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">close</span>(_sock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN32</span></span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;客户端已退出,任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//保留界面</span></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">//uni std</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVALID_SOCKET  (SOCKET)(~0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_ERROR            (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span><span class="comment">//C++标准线程库</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region 结构体定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CMD</span> &#123;</span><br><span class="line">CMD_LOGIN,</span><br><span class="line">CMD_LOGOUT,</span><br><span class="line">CMD_ERROR,</span><br><span class="line">CMD_LOGIN_RESULT,</span><br><span class="line">CMD_LOGOUT_RESULT,</span><br><span class="line">CMD_NEW_USER_JOIN</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> &#123;</span><br><span class="line"><span class="type">short</span> dataLength;</span><br><span class="line"><span class="type">short</span> cmd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader &#123;<span class="comment">//DataPackage</span></span><br><span class="line"><span class="built_in">Login</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(Login);</span><br><span class="line">cmd = CMD_LOGIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> userName[<span class="number">32</span>];</span><br><span class="line"><span class="type">char</span> PassWord[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">LoginResult</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(LoginResult);</span><br><span class="line">cmd = CMD_LOGIN_RESULT;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">Logout</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(Logout);</span><br><span class="line">cmd = CMD_LOGOUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> userName[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">LogoutResult</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(LogoutResult);</span><br><span class="line">cmd = CMD_LOGOUT_RESULT;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">NewUserJoin</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(NewUserJoin);</span><br><span class="line">cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">sock = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataPackage</span> &#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> endregion</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;SOCKET&gt; g_clients;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processor</span><span class="params">(SOCKET _cSock)</span> </span>&#123;</span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="type">char</span> szRecv[<span class="number">4096</span>] = &#123;&#125;;</span><br><span class="line"><span class="comment">// 5 接收客户端数据</span></span><br><span class="line"><span class="type">int</span> nLen = (<span class="type">int</span>)<span class="built_in">recv</span>(_cSock, szRecv, <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">DataHeader* header = (DataHeader*)szRecv;</span><br><span class="line"><span class="keyword">if</span> (nLen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;客户端&lt; socket = &quot;</span> &lt;&lt; _cSock &lt;&lt; <span class="string">&quot; &gt;已退出，任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (header-&gt;cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> CMD_LOGIN: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">Login* login = (Login*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到客户端&lt;Socket = &quot;</span> &lt;&lt; _cSock &lt;&lt; <span class="string">&quot;&gt;请求：CMD_LOGIN, 数据长度：&quot;</span> &lt;&lt; login-&gt;dataLength &lt;&lt; <span class="string">&quot; ,userName =  &quot;</span> &lt;&lt; login-&gt;userName &lt;&lt; <span class="string">&quot; PassWord = &quot;</span> &lt;&lt; login-&gt;PassWord &lt;&lt; endl;</span><br><span class="line"><span class="comment">//忽略判断用户密码是否正确</span></span><br><span class="line">LoginResult ret;</span><br><span class="line"><span class="built_in">send</span>(_cSock, (<span class="type">char</span>*)&amp;ret, <span class="built_in">sizeof</span>(LoginResult), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CMD_LOGOUT: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">Logout* logout = (Logout*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到客户端&lt;Socket = &quot;</span> &lt;&lt; _cSock &lt;&lt; <span class="string">&quot;&gt;请求：CMD_LOGOUT, 数据长度：&quot;</span> &lt;&lt; logout-&gt;dataLength &lt;&lt; <span class="string">&quot; ,userName =  &quot;</span> &lt;&lt; logout-&gt;userName &lt;&lt; endl;</span><br><span class="line"><span class="comment">//忽略判断用户密码是否正确</span></span><br><span class="line">LogoutResult ret;</span><br><span class="line"><span class="built_in">send</span>(_cSock, (<span class="type">char</span>*)&amp;ret, <span class="built_in">sizeof</span>(ret), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: &#123;</span><br><span class="line">DataHeader header = &#123; <span class="number">0</span>,CMD_ERROR &#125;;</span><br><span class="line"><span class="built_in">send</span>(_cSock, (<span class="type">char</span>*)&amp;header, <span class="built_in">sizeof</span>(header), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="comment">//启动Windows socket 2.x环境</span></span><br><span class="line">WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA dat;</span><br><span class="line"><span class="built_in">WSAStartup</span>(ver, &amp;dat);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN32</span></span></span><br><span class="line"><span class="comment">// 用Socket API 建立一个简易的TCP服务端 1 建立一个socket 套接字</span></span><br><span class="line">SOCKET _sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="comment">// 2 bind 绑定用于接受客户端连接的网络接口</span></span><br><span class="line">sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">_sin.sin_family = AF_INET;</span><br><span class="line">_sin.sin_port = <span class="built_in">htons</span>(<span class="number">4567</span>);<span class="comment">// host to net unsigned short</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">_sin.sin_addr.S_un.S_addr = INADDR_ANY;<span class="comment">//inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">_sin.sin_addr.s_addr = INADDR_ANY;<span class="comment">//inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(_sock, (sockaddr*)&amp;_sin, <span class="built_in">sizeof</span>(_sin)) == SOCKET_ERROR) &#123;</span><br><span class="line"><span class="comment">//绑定错误</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;绑定网络端口失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;绑定网络端口成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 listen 监听网络端口</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">listen</span>(_sock, <span class="number">5</span>)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;监听网络端口失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;监听网络端口成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// 伯克利套接字 BSD socket</span></span><br><span class="line">fd_set fdRead; <span class="comment">//描述符(Socket) 集合</span></span><br><span class="line">fd_set fdWrite;</span><br><span class="line">fd_set fdExp;</span><br><span class="line"><span class="comment">//清理集合</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdRead);</span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdWrite);</span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdExp);</span><br><span class="line"><span class="comment">//将描述符(socket)加入集合</span></span><br><span class="line"><span class="built_in">FD_SET</span>(_sock, &amp;fdRead);</span><br><span class="line"><span class="built_in">FD_SET</span>(_sock, &amp;fdWrite);</span><br><span class="line"><span class="built_in">FD_SET</span>(_sock, &amp;fdExp);</span><br><span class="line">SOCKET maxSock = _sock;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = (<span class="type">int</span>)g_clients.<span class="built_in">size</span>() - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line"><span class="built_in">FD_SET</span>(g_clients[n], &amp;fdRead);</span><br><span class="line"><span class="keyword">if</span> (maxSock &lt; g_clients[n]) &#123;</span><br><span class="line">maxSock = g_clients[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//nfds 是一个整数值，是指fd_set集合中所有描述符(socket)的范围，而不是数量</span></span><br><span class="line"><span class="comment">//既是所有文件描述符最大值+1，在Windows中这个参数可以写0</span></span><br><span class="line">timeval t = &#123; <span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span>  ret = <span class="built_in">select</span>(maxSock + <span class="number">1</span>, &amp;fdRead, &amp;fdWrite, &amp;fdExp, &amp;t);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;select任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断描述符(socket)是否在集合中</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(_sock, &amp;fdRead)) &#123;</span><br><span class="line"><span class="built_in">FD_CLR</span>(_sock, &amp;fdRead);</span><br><span class="line"><span class="comment">//4 accept 等待接受客户端连接</span></span><br><span class="line">sockaddr_in clientAddr = &#123;&#125;;</span><br><span class="line"><span class="type">int</span> nAddrLen = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line">SOCKET _cSock = INVALID_SOCKET;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">_cSock = <span class="built_in">accept</span>(_sock, (sockaddr*)&amp;clientAddr, &amp;nAddrLen);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">_cSock = <span class="built_in">accept</span>(_sock, (sockaddr*)&amp;clientAddr, (<span class="type">socklen_t</span>*)&amp;nAddrLen);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN32</span></span></span><br><span class="line"><span class="keyword">if</span> (_cSock == INVALID_SOCKET) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;接受到无效客户端SOCKET...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 新客户端加入，群发</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = (<span class="type">int</span>)g_clients.<span class="built_in">size</span>() - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line">NewUserJoin userJoin;</span><br><span class="line"><span class="built_in">send</span>(g_clients[n], (<span class="type">const</span> <span class="type">char</span>*)&amp;userJoin, <span class="built_in">sizeof</span>(NewUserJoin), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">g_clients.<span class="built_in">push_back</span>(_cSock);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;新客户端加入：socket = &quot;</span> &lt;&lt; (<span class="type">int</span>)_cSock &lt;&lt; <span class="string">&quot;, IP = &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = (<span class="type">int</span>)g_clients.<span class="built_in">size</span>() - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(g_clients[n], &amp;fdRead)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">processor</span>(g_clients[n]) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">auto</span> iter = g_clients.<span class="built_in">begin</span>() + n; <span class="comment">//std::vector&lt;SOCKET&gt;::iterator</span></span><br><span class="line"><span class="keyword">if</span> (iter != g_clients.<span class="built_in">end</span>()) &#123;</span><br><span class="line">g_clients.<span class="built_in">erase</span>(iter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;空闲时间处理其他业务 ...&quot; &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = (<span class="type">int</span>)g_clients.<span class="built_in">size</span>() - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line"><span class="built_in">closesocket</span>(g_clients[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6 关闭套接字closesocket</span></span><br><span class="line"><span class="comment">//7 清除windows socket环境</span></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = (<span class="type">int</span>)g_clients.<span class="built_in">size</span>() - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line"><span class="built_in">close</span>(g_clients[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN32</span></span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;服务器已退出,任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//保留界面</span></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/04/01/pF72K3D.png" alt="image-20240331210407460"></p><p><img src="https://s21.ax1x.com/2024/04/01/pF72QjH.png" alt="Screenshot 2024-03-31 204407"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;客户端代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;if</summary>
      
    
    
    
    
    <category term="C++socket项目" scheme="https://ruvikm.gitee.io/tags/C-socket%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>复现KnowLog模型</title>
    <link href="https://ruvikm.gitee.io/2024/03/31/%E5%A4%8D%E7%8E%B0KnowLog%E6%A8%A1%E5%9E%8B/"/>
    <id>https://ruvikm.gitee.io/2024/03/31/%E5%A4%8D%E7%8E%B0KnowLog%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-03-31T01:52:08.000Z</published>
    <updated>2024-03-31T13:05:57.429Z</updated>
    
    <content type="html"><![CDATA[<p>这次要复现的一个项目是<strong><a href="https://github.com/LeaperOvO/KnowLog">KnowLog</a></strong>，首先创建一个虚拟环境</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create KnowLog -n python=3.8</span><br><span class="line">conda activate KnowLog</span><br></pre></td></tr></table></figure><p>然后来到项目的根目录，安装项目所需的环境</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>之后尝试运行训练的部分</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python KnowLog_pretrain.py --pretrain_data ./datasets/pre-train/all_log.json --abbr ./datasets/pre-train/abbr.json --base_model bert-base-uncased</span><br></pre></td></tr></table></figure><p>毫无意外的会出报错，提示少了什么包，这时候提示缺什么用pip安装即可</p><p>再安装完这些包之后，再次尝试训练，出现了下面这个错</p><p><img src="https://s21.ax1x.com/2024/03/31/pF7ZiLT.png" alt="image-20240331100215828"></p><p>查了一下是python关于SSLError的错误，尝试降级版本解决</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install urllib3==1.25.11</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/03/31/pF7ZkeU.png" alt="image-20240331101640666"></p><p>成功解决问题，开启魔法可以正常下载了</p><p><img src="https://s21.ax1x.com/2024/03/31/pF7ZAwF.png" alt="image-20240331101821967"></p><p>但是发现下载一半又断开连接了，可能是这种下载方式不支持断点续传，于是打算先把预训练模型下载到本地试试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">huggingface-cli download --resume-download google-bert/bert-base-uncased --local-dir bert-base-uncased</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/03/31/pF7ZEo4.png" alt="image-20240331104044658"></p><p>下好了之后再次尝试跑一下，应该是下了CPU版的torch，重新安装一下吧</p><p><img src="https://s21.ax1x.com/2024/03/31/pF7ZeY9.png" alt="image-20240331104118085"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install pytorch==1.10.1 torchvision==0.11.2 torchaudio==0.10.1 cudatoolkit=11.3</span><br></pre></td></tr></table></figure><p>再次尝试训练，跑通了！！！</p><p><img src="https://s21.ax1x.com/2024/03/31/pF7ZuS1.png" alt="image-20240331110908244"></p><p>但是一直卡在34%了…重启运行了一下代码，把代理开了开（可能是代理的原因？）就可以继续往下跑了，但是好像跑不动，之后在GPU服务器上跑一下试试</p><p><img src="https://s21.ax1x.com/2024/03/31/pF7ZKQx.png" alt="image-20240331112852208"></p><p>尝试直接验证一下模型</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python KnowLog_finetune_single.py --train_data ./datasets/tasks/MC/hw_switch_train.json --dev_data ./datasets/tasks/MC/hw_switch_dev.json --test_data ./datasets/tasks/MC/hw_switch_test.json</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/03/31/pF7Z3wD.png" alt="image-20240331113220505"></p><p>也跑通了，之后在服务器上完整的跑一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这次要复现的一个项目是&lt;strong&gt;&lt;a href=&quot;https://github.com/LeaperOvO/KnowLog&quot;&gt;KnowLog&lt;/a&gt;&lt;/strong&gt;，首先创建一个虚拟环境&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="论文复现" scheme="https://ruvikm.gitee.io/categories/%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>客户端服务器升为select模型</title>
    <link href="https://ruvikm.gitee.io/2024/03/02/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8D%87%E7%BA%A7%E4%B8%BAselect%E6%A8%A1%E5%9E%8B/"/>
    <id>https://ruvikm.gitee.io/2024/03/02/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8D%87%E7%BA%A7%E4%B8%BAselect%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-03-02T02:17:20.000Z</published>
    <updated>2024-03-02T02:21:39.656Z</updated>
    
    <content type="html"><![CDATA[<p>服务端</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//只有在WIN里可以</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region 结构体定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CMD</span> &#123;</span><br><span class="line">CMD_LOGIN,</span><br><span class="line">CMD_LOGOUT,</span><br><span class="line">CMD_ERROR,</span><br><span class="line">CMD_LOGIN_RESULT,</span><br><span class="line">CMD_LOGOUT_RESULT,</span><br><span class="line">CMD_NEW_USER_JOIN</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> &#123;</span><br><span class="line"><span class="type">short</span> dataLength;</span><br><span class="line"><span class="type">short</span> cmd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader &#123;<span class="comment">//DataPackage</span></span><br><span class="line"><span class="built_in">Login</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(Login);</span><br><span class="line">cmd = CMD_LOGIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> userName[<span class="number">32</span>];</span><br><span class="line"><span class="type">char</span> PassWord[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">LoginResult</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(LoginResult);</span><br><span class="line">cmd = CMD_LOGIN_RESULT;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">Logout</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(Logout);</span><br><span class="line">cmd = CMD_LOGOUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> userName[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">LogoutResult</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(LogoutResult);</span><br><span class="line">cmd = CMD_LOGOUT_RESULT;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">NewUserJoin</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(NewUserJoin);</span><br><span class="line">cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">sock = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataPackage</span> &#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> endregion</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;SOCKET&gt; g_clients;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processor</span><span class="params">(SOCKET _cSock)</span> </span>&#123;</span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="type">char</span> szRecv[<span class="number">4096</span>] = &#123;&#125;;</span><br><span class="line"><span class="comment">// 5 接收客户端数据</span></span><br><span class="line"><span class="type">int</span> nLen = <span class="built_in">recv</span>(_cSock, szRecv, <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">DataHeader* header = (DataHeader*)szRecv;</span><br><span class="line"><span class="keyword">if</span> (nLen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;客户端&lt; socket = &quot;</span> &lt;&lt; _cSock &lt;&lt; <span class="string">&quot; &gt;已退出，任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (header-&gt;cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> CMD_LOGIN: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">Login* login = (Login*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到客户端&lt;Socket = &quot;</span> &lt;&lt; _cSock &lt;&lt; <span class="string">&quot;&gt;请求：CMD_LOGIN, 数据长度：&quot;</span> &lt;&lt; login-&gt;dataLength &lt;&lt; <span class="string">&quot; ,userName =  &quot;</span> &lt;&lt; login-&gt;userName &lt;&lt; <span class="string">&quot; PassWord = &quot;</span> &lt;&lt; login-&gt;PassWord &lt;&lt; endl;</span><br><span class="line"><span class="comment">//忽略判断用户密码是否正确</span></span><br><span class="line">LoginResult ret;</span><br><span class="line"><span class="built_in">send</span>(_cSock, (<span class="type">char</span>*)&amp;ret, <span class="built_in">sizeof</span>(LoginResult), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CMD_LOGOUT: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">Logout* logout = (Logout*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到客户端&lt;Socket = &quot;</span> &lt;&lt; _cSock &lt;&lt; <span class="string">&quot;&gt;请求：CMD_LOGOUT, 数据长度：&quot;</span> &lt;&lt; logout-&gt;dataLength &lt;&lt; <span class="string">&quot; ,userName =  &quot;</span> &lt;&lt; logout-&gt;userName &lt;&lt; endl;</span><br><span class="line"><span class="comment">//忽略判断用户密码是否正确</span></span><br><span class="line">LogoutResult ret;</span><br><span class="line"><span class="built_in">send</span>(_cSock, (<span class="type">char</span>*)&amp;ret, <span class="built_in">sizeof</span>(ret), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: &#123;</span><br><span class="line">DataHeader header = &#123; <span class="number">0</span>,CMD_ERROR &#125;;</span><br><span class="line"><span class="built_in">send</span>(_cSock, (<span class="type">char</span>*)&amp;header, <span class="built_in">sizeof</span>(header), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//启动Windows socket 2.x环境</span></span><br><span class="line">WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA dat;</span><br><span class="line"><span class="built_in">WSAStartup</span>(ver, &amp;dat);</span><br><span class="line"><span class="comment">// 用Socket API 建立一个简易的TCP服务端 1 建立一个socket 套接字</span></span><br><span class="line">SOCKET _sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="comment">// 2 bind 绑定用于接受客户端连接的网络接口</span></span><br><span class="line">sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">_sin.sin_family = AF_INET;</span><br><span class="line">_sin.sin_port = <span class="built_in">htons</span>(<span class="number">4567</span>);<span class="comment">// host to net unsigned short</span></span><br><span class="line">_sin.sin_addr.S_un.S_addr = INADDR_ANY;<span class="comment">//inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(_sock, (sockaddr*)&amp;_sin, <span class="built_in">sizeof</span>(_sin)) == SOCKET_ERROR) &#123;</span><br><span class="line"><span class="comment">//绑定错误</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;绑定网络端口失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;绑定网络端口成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 listen 监听网络端口</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">listen</span>(_sock, <span class="number">5</span>)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;监听网络端口失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;监听网络端口成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// 伯克利套接字 BSD socket</span></span><br><span class="line">fd_set fdRead; <span class="comment">//描述符(Socket) 集合</span></span><br><span class="line">fd_set fdWrite;</span><br><span class="line">fd_set fdExp;</span><br><span class="line"><span class="comment">//清理集合</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdRead);</span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdWrite);</span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdExp);</span><br><span class="line"><span class="comment">//将描述符(socket)加入集合</span></span><br><span class="line"><span class="built_in">FD_SET</span>(_sock, &amp;fdRead);</span><br><span class="line"><span class="built_in">FD_SET</span>(_sock, &amp;fdWrite);</span><br><span class="line"><span class="built_in">FD_SET</span>(_sock, &amp;fdExp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = (<span class="type">int</span>)g_clients.<span class="built_in">size</span>() - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line"><span class="built_in">FD_SET</span>(g_clients[n], &amp;fdRead);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//nfds 是一个整数值，是指fd_set集合中所有描述符(socket)的范围，而不是数量</span></span><br><span class="line"><span class="comment">//既是所有文件描述符最大值+1，在Windows中这个参数可以写0</span></span><br><span class="line">timeval t = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span>  ret = <span class="built_in">select</span>(_sock + <span class="number">1</span>, &amp;fdRead, &amp;fdWrite, &amp;fdExp, &amp;t);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;select任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断描述符(socket)是否在集合中</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(_sock, &amp;fdRead)) &#123;</span><br><span class="line"><span class="built_in">FD_CLR</span>(_sock, &amp;fdRead);</span><br><span class="line"><span class="comment">//4 accept 等待接受客户端连接</span></span><br><span class="line">sockaddr_in clientAddr = &#123;&#125;;</span><br><span class="line"><span class="type">int</span> nAddrLen = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line">SOCKET _cSock = INVALID_SOCKET;</span><br><span class="line">_cSock = <span class="built_in">accept</span>(_sock, (sockaddr*)&amp;clientAddr, &amp;nAddrLen);</span><br><span class="line"><span class="keyword">if</span> (_cSock == INVALID_SOCKET) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;接受到无效客户端SOCKET...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 新客户端加入，群发</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = (<span class="type">int</span>)g_clients.<span class="built_in">size</span>() - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line">NewUserJoin userJoin;</span><br><span class="line"><span class="built_in">send</span>(g_clients[n], (<span class="type">const</span> <span class="type">char</span>*)&amp;userJoin, <span class="built_in">sizeof</span>(NewUserJoin), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">g_clients.<span class="built_in">push_back</span>(_cSock);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;新客户端加入：socket = &quot;</span> &lt;&lt; (<span class="type">int</span>)_cSock &lt;&lt; <span class="string">&quot;, IP = &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> n = <span class="number">0</span>; n &lt; fdRead.fd_count; n++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">processor</span>(fdRead.fd_array[n]) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">auto</span> iter = <span class="built_in">find</span>(g_clients.<span class="built_in">begin</span>(), g_clients.<span class="built_in">end</span>(), fdRead.fd_array[n]);</span><br><span class="line"><span class="keyword">if</span> (iter != g_clients.<span class="built_in">end</span>()) &#123;</span><br><span class="line">g_clients.<span class="built_in">erase</span>(iter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试中间select函数最后一个参数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;空闲时间处理其他业务 ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> n = g_clients.<span class="built_in">size</span>() - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line"><span class="built_in">closesocket</span>(g_clients[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6 关闭套接字closesocket</span></span><br><span class="line"><span class="comment">//7 清除windows socket环境</span></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;服务器已退出,任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//保留界面</span></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//只有在WIN里可以</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region 结构体定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CMD</span> &#123;</span><br><span class="line">CMD_LOGIN,</span><br><span class="line">CMD_LOGOUT,</span><br><span class="line">CMD_ERROR,</span><br><span class="line">CMD_LOGIN_RESULT,</span><br><span class="line">CMD_LOGOUT_RESULT,</span><br><span class="line">CMD_NEW_USER_JOIN</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> &#123;</span><br><span class="line"><span class="type">short</span> dataLength;</span><br><span class="line"><span class="type">short</span> cmd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader &#123;<span class="comment">//DataPackage</span></span><br><span class="line"><span class="built_in">Login</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(Login);</span><br><span class="line">cmd = CMD_LOGIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> userName[<span class="number">32</span>];</span><br><span class="line"><span class="type">char</span> PassWord[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">LoginResult</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(LoginResult);</span><br><span class="line">cmd = CMD_LOGIN_RESULT;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">Logout</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(Logout);</span><br><span class="line">cmd = CMD_LOGOUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> userName[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">LogoutResult</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(LogoutResult);</span><br><span class="line">cmd = CMD_LOGOUT_RESULT;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">NewUserJoin</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(NewUserJoin);</span><br><span class="line">cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">sock = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataPackage</span> &#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> endregion</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processor</span><span class="params">(SOCKET _cSock)</span> </span>&#123;</span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="type">char</span> szRecv[<span class="number">4096</span>] = &#123;&#125;;</span><br><span class="line"><span class="comment">// 5 接收客户端数据</span></span><br><span class="line"><span class="type">int</span> nLen = <span class="built_in">recv</span>(_cSock, szRecv, <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">DataHeader* header = (DataHeader*)szRecv;</span><br><span class="line"><span class="keyword">if</span> (nLen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;与服务器断开连接，任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (header-&gt;cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> CMD_LOGIN_RESULT: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">LoginResult* login = (LoginResult*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到服务端消息：CMD_LOGIN_RESULT, 数据长度：&quot;</span> &lt;&lt; login-&gt;dataLength &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CMD_LOGOUT_RESULT: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">LogoutResult* logout = (LogoutResult*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到服务端消息：CMD_LOGOUT_RESULT, 数据长度：&quot;</span> &lt;&lt; logout-&gt;dataLength &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CMD_NEW_USER_JOIN: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">NewUserJoin* userJoin = (NewUserJoin*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到服务端消息：CMD_LOGOUT_RESULT, 数据长度：&quot;</span> &lt;&lt; userJoin-&gt;dataLength &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//启动Windows socket 2.x环境</span></span><br><span class="line">WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA dat;</span><br><span class="line"><span class="built_in">WSAStartup</span>(ver, &amp;dat);</span><br><span class="line"><span class="comment">// 用Socket API 建立一个简易的TCP服务端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 建立一个socket</span></span><br><span class="line">SOCKET _sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == _sock) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;建立Socket失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;建立Socket成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 连接服务器 connect</span></span><br><span class="line">sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">_sin.sin_family = AF_INET;</span><br><span class="line">_sin.sin_port = <span class="built_in">htons</span>(<span class="number">4567</span>);</span><br><span class="line">_sin.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">connect</span>(_sock, (sockaddr*)&amp;_sin, <span class="built_in">sizeof</span>(sockaddr_in));</span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == ret) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;连接服务器失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;连接服务器成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">fd_set fdReads;</span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdReads);</span><br><span class="line"><span class="built_in">FD_SET</span>(_sock,&amp;fdReads);</span><br><span class="line">timeval t = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">select</span>(_sock, &amp;fdReads, <span class="number">0</span>, <span class="number">0</span>, &amp;t);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;select任务结束&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(_sock, &amp;fdReads)) &#123;</span><br><span class="line"><span class="built_in">FD_CLR</span>(_sock, &amp;fdReads);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">processor</span>(_sock)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;select任务结束2...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;空闲时间处理其他业务 ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">Login login;</span><br><span class="line"><span class="built_in">strcpy</span>(login.userName, <span class="string">&quot;lyd&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(login.PassWord, <span class="string">&quot;lyd&quot;</span>);</span><br><span class="line"><span class="built_in">send</span>(_sock, (<span class="type">const</span> <span class="type">char</span>*)&amp;login, <span class="built_in">sizeof</span>(Login), <span class="number">0</span>);</span><br><span class="line"><span class="comment">//仅仅适用于Windows</span></span><br><span class="line"><span class="comment">// Sleep(1000);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7 关闭套接字closesocket</span></span><br><span class="line"><span class="built_in">closesocket</span>(_sock);</span><br><span class="line"><span class="comment">// 8 清除windows socket环境</span></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;客户端已退出,任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//保留界面</span></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s11.ax1x.com/2024/03/02/pF0yFOS.png" alt="image-20240302101949530"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;服务端&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;defin</summary>
      
    
    
    
    
    <category term="C++socket项目" scheme="https://ruvikm.gitee.io/tags/C-socket%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>nginx反向代理出错</title>
    <link href="https://ruvikm.gitee.io/2024/01/26/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%87%BA%E9%94%99/"/>
    <id>https://ruvikm.gitee.io/2024/01/26/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%87%BA%E9%94%99/</id>
    <published>2024-01-26T13:24:54.000Z</published>
    <updated>2024-01-26T14:07:24.191Z</updated>
    
    <content type="html"><![CDATA[<p>使用yum安装好了nginx</p><h2 id="问题再现"><a href="#问题再现" class="headerlink" title="问题再现"></a>问题再现</h2><p>进入路径配置好了<code>nginx.conf</code>文件</p><p><img src="https://s11.ax1x.com/2024/01/26/pFnwVDP.png" alt="QQ截图20240126212909"></p><p>验证<code>nginx.conf</code>文件是否有语法错误</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nginx -t</span><br></pre></td></tr></table></figure><p>重载nginx服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure><p>然后启动程序，发现nginx报错</p><p><img src="https://s11.ax1x.com/2024/01/26/pFnwmE8.png" alt="img"></p><p>在终端可以尝试输入了这样一句话</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setsebool -P httpd_can_network_connect <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>解释：可能是SELinux的原因，它会基于最小权限原则默认拦截了 Nginx 的请求</p><p><img src="https://s11.ax1x.com/2024/01/26/pFnwnUS.png" alt="image-20240126213917121"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用yum安装好了nginx&lt;/p&gt;
&lt;h2 id=&quot;问题再现&quot;&gt;&lt;a href=&quot;#问题再现&quot; class=&quot;headerlink&quot; title=&quot;问题再现&quot;&gt;&lt;/a&gt;问题再现&lt;/h2&gt;&lt;p&gt;进入路径配置好了&lt;code&gt;nginx.conf&lt;/code&gt;文件&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/tags/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>在虚拟机Centos 7中配置Redis环境</title>
    <link href="https://ruvikm.gitee.io/2024/01/08/%E9%85%8D%E7%BD%AERedis%E7%8E%AF%E5%A2%83/"/>
    <id>https://ruvikm.gitee.io/2024/01/08/%E9%85%8D%E7%BD%AERedis%E7%8E%AF%E5%A2%83/</id>
    <published>2024-01-08T12:05:08.000Z</published>
    <updated>2024-01-08T13:04:38.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载fedora的epel仓库</span></span><br><span class="line">sudo yum install epel-release</span><br><span class="line"><span class="comment"># 安装redis数据库</span></span><br><span class="line">sudo yum install redis</span><br></pre></td></tr></table></figure><p>测试是否安装成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动redis</span></span><br><span class="line">service redis start</span><br><span class="line"><span class="comment">#查看redis进程</span></span><br><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure><p><img src="https://s11.ax1x.com/2024/01/08/pFSvcQg.png" alt="image-20240108203745982"></p><h2 id="配置Redis"><a href="#配置Redis" class="headerlink" title="配置Redis"></a>配置Redis</h2><p><strong>以需求为远程连接Redis为例</strong></p><p>开始配置之前，先关闭Redis服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#关闭redis</span></span><br><span class="line">service redis stop</span><br></pre></td></tr></table></figure><h4 id="打开配置文件"><a href="#打开配置文件" class="headerlink" title="打开配置文件"></a>打开配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/redis.conf</span><br></pre></td></tr></table></figure><p>进入编辑器后，输入<code>/</code>+<code>搜索的内容</code>然后回车进行搜索，按<code>n</code>键查找下一个(eg:修改端口号时输入/port)，按<code>i</code>进入到插入模式进行修改，修改完后按<code>Esc</code>退出插入模式</p><h4 id="修改端口号（按照需求修改）"><a href="#修改端口号（按照需求修改）" class="headerlink" title="修改端口号（按照需求修改）"></a>修改端口号（按照需求修改）</h4><p><img src="https://s11.ax1x.com/2024/01/08/pFSvmM4.png" alt="image-20240108202709064"></p><h4 id="修改默认密码（建议修改）"><a href="#修改默认密码（建议修改）" class="headerlink" title="修改默认密码（建议修改）"></a>修改默认密码（建议修改）</h4><p><img src="https://s11.ax1x.com/2024/01/08/pFSvnsJ.png" alt="image-20240108202554924"></p><h4 id="取消只允许在本机连接redis"><a href="#取消只允许在本机连接redis" class="headerlink" title="取消只允许在本机连接redis"></a>取消只允许在本机连接redis</h4><p><img src="https://s11.ax1x.com/2024/01/08/pFSzuU1.png" alt="image-20240108202958241"></p><p>将<code>bind 127.0.0.1</code>注释掉</p><p>然后输入<code>:wq</code>保存并退出</p><h4 id="设置Redis开机自启"><a href="#设置Redis开机自启" class="headerlink" title="设置Redis开机自启"></a>设置Redis开机自启</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig redis on</span><br></pre></td></tr></table></figure><h2 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h2><p>在linux下的防火墙中开放6379端口（如果上面更换了端口号就按自己的来）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=6379/tcp --permanent</span><br></pre></td></tr></table></figure><p>重启防火墙</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart firewalld</span><br></pre></td></tr></table></figure><h2 id="使用可视化软件连接Redis"><a href="#使用可视化软件连接Redis" class="headerlink" title="使用可视化软件连接Redis"></a>使用可视化软件连接Redis</h2><p>下载可视化软件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://gitee.com/qishibo/AnotherRedisDesktopManager/releases</span><br></pre></td></tr></table></figure><p>查看自己ip地址</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p><img src="https://s11.ax1x.com/2024/01/08/pFSzK4x.png" alt="屏幕截图 2024-01-08 204612"></p><p>配置远程连接，地址为上面的箭头所指的ip地址，密码为刚刚配置Redis时配置的</p><p><img src="https://s11.ax1x.com/2024/01/08/pFSzQC6.png" alt="屏幕截图 2024-01-08 205033"></p><p>连接成功</p><p><img src="https://s11.ax1x.com/2024/01/08/pFSzl8K.png" alt="屏幕截图 2024-01-08 205120"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装Redis&quot;&gt;&lt;a href=&quot;#安装Redis&quot; class=&quot;headerlink&quot; title=&quot;安装Redis&quot;&gt;&lt;/a&gt;安装Redis&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/tags/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>建立一个简易的TCP客户端与服务端</title>
    <link href="https://ruvikm.gitee.io/2023/12/15/%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    <id>https://ruvikm.gitee.io/2023/12/15/%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF/</id>
    <published>2023-12-15T10:19:52.000Z</published>
    <updated>2024-03-02T02:21:36.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a>TCP服务端</h2><p>分为一下六步：</p><ol><li>建立一个socket 套接字</li><li>bind 绑定用于接受客户端连接的网络接口</li><li>listen 监听网络端口</li><li>accept 等待接受客户端连接</li><li>send 向客户端发送一条数据</li><li>关闭套接字closesocket</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//只有在WIN里可以</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//启动Windows socket 2.x环境</span></span><br><span class="line">WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA dat;</span><br><span class="line"><span class="built_in">WSAStartup</span>(ver, &amp;dat);</span><br><span class="line"><span class="comment">// 用Socket API 建立一个简易的TCP服务端</span></span><br><span class="line"><span class="comment">// 1 建立一个socket 套接字</span></span><br><span class="line">SOCKET _sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="comment">// 2 bind 绑定用于接受客户端连接的网络接口</span></span><br><span class="line">sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">_sin.sin_family = AF_INET;</span><br><span class="line">_sin.sin_port = <span class="built_in">htons</span>(<span class="number">4567</span>);<span class="comment">// host to net unsigned short</span></span><br><span class="line">_sin.sin_addr.S_un.S_addr = INADDR_ANY;<span class="comment">//inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(_sock, (sockaddr*)&amp;_sin, <span class="built_in">sizeof</span>(_sin)) == SOCKET_ERROR) &#123;</span><br><span class="line"><span class="comment">//绑定错误</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;绑定网络端口失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;绑定网络端口成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 listen 监听网络端口</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">listen</span>(_sock, <span class="number">5</span>)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;监听网络端口失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;监听网络端口成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4 accept 等待接受客户端连接</span></span><br><span class="line">sockaddr_in clientAddr = &#123;&#125;;</span><br><span class="line"><span class="type">int</span> nAddrLen = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line">SOCKET _cSock = INVALID_SOCKET;</span><br><span class="line"><span class="type">char</span> msgBuf[] = <span class="string">&quot;Hello ,I&#x27;m Server.&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">_cSock = <span class="built_in">accept</span>(_sock, (sockaddr*)&amp;clientAddr, &amp;nAddrLen);</span><br><span class="line"><span class="keyword">if</span> (_cSock == INVALID_SOCKET) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;接受到无效客户端SOCKET...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;新客户端加入：IP =&quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr) &lt;&lt; endl;</span><br><span class="line"><span class="comment">//5 send 向客户端发送一条数据</span></span><br><span class="line"><span class="built_in">send</span>(_cSock, msgBuf, <span class="built_in">strlen</span>(msgBuf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6 关闭套接字closesocket</span></span><br><span class="line"><span class="built_in">closesocket</span>(_sock);</span><br><span class="line"><span class="comment">//7 清除windows socket环境</span></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="comment">//保留界面</span></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP服务端-1"><a href="#TCP服务端-1" class="headerlink" title="TCP服务端"></a>TCP服务端</h2><p>分为四步：</p><ol><li>建立一个socket</li><li>连接服务器 connect</li><li>接受服务器信息 recv</li><li>关闭套接字closesocket</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//只有在WIN里可以</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//启动Windows socket 2.x环境</span></span><br><span class="line">WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA dat;</span><br><span class="line"><span class="built_in">WSAStartup</span>(ver, &amp;dat);</span><br><span class="line"><span class="comment">// 用Socket API 建立一个简易的TCP服务端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 建立一个socket</span></span><br><span class="line">SOCKET _sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == _sock) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;建立Socket失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;建立Socket成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 连接服务器 connect</span></span><br><span class="line">sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">_sin.sin_family = AF_INET;</span><br><span class="line">_sin.sin_port = <span class="built_in">htons</span>(<span class="number">4567</span>);</span><br><span class="line">_sin.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">connect</span>(_sock, (sockaddr*)&amp;_sin, <span class="built_in">sizeof</span>(sockaddr_in));</span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == ret) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;连接Socket失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;连接Socket成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 接受服务器信息 recv</span></span><br><span class="line"><span class="type">char</span> recvBuf[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line"><span class="type">int</span> nlen = <span class="built_in">recv</span>(_sock, recvBuf, <span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (nlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;接收到数据为：&quot;</span> &lt;&lt; recvBuf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4 关闭套接字closesocket</span></span><br><span class="line"><span class="built_in">closesocket</span>(_sock);</span><br><span class="line"><span class="comment">// 5 清除windows socket环境</span></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="comment">//保留界面</span></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><strong>服务端</strong></p><p><img src="https://s11.ax1x.com/2023/12/15/pi41BFK.png" alt="屏幕截图 2023-12-15 181558"></p><p><strong>客户端</strong></p><p><img src="https://s11.ax1x.com/2023/12/15/pi41DJO.png" alt="屏幕截图 2023-12-15 181602"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TCP服务端&quot;&gt;&lt;a href=&quot;#TCP服务端&quot; class=&quot;headerlink&quot; title=&quot;TCP服务端&quot;&gt;&lt;/a&gt;TCP服务端&lt;/h2&gt;&lt;p&gt;分为一下六步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立一个socket 套接字&lt;/li&gt;
&lt;li&gt;bind 绑定用于</summary>
      
    
    
    
    
    <category term="C++socket项目" scheme="https://ruvikm.gitee.io/tags/C-socket%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>JZ22 链表中倒数最后k个结点</title>
    <link href="https://ruvikm.gitee.io/2023/11/20/JZ22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8Ek%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://ruvikm.gitee.io/2023/11/20/JZ22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8Ek%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2023-11-20T08:08:47.000Z</published>
    <updated>2023-11-20T15:19:06.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>输入一个长度为 n 的链表，设链表中的元素的值为 a_i ，返回该链表中倒数第k个节点。</p><p>如果该链表长度小于k，请返回一个长度为 0 的链表。</p><p>数据范围：</p><script type="math/tex; mode=display">0 \leq n \leq 10^5,0 \leq a_i \leq 10^9,0 \leq k \leq 10^9</script><p>要求：空间复杂度 <em>O</em>(n)，时间复杂度 O<em>(</em>n)</p><p>进阶：空间复杂度O(1)，时间复杂度 O(n)</p><p>例如输入{1,2,3,4,5},2时，对应的链表结构如下图所示：</p><p><img src="https://z1.ax1x.com/2023/11/20/piap43j.png" alt="img"></p><p>其中蓝色部分为该链表的最后2个结点，所以返回倒数第2个结点（也即结点值为4的结点）即可，系统会打印后面所有的节点来比较。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">&#123;1,2,3,4,5&#125;,2</span><br><span class="line">返回值：</span><br><span class="line">&#123;4,5&#125;</span><br><span class="line">说明：</span><br><span class="line">返回倒数第2个节点4，系统会打印后面所有的节点来比较。 </span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">&#123;2&#125;,8</span><br><span class="line">返回值：</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>首先求出链表的长度<code>n</code>，从题目的倒数第<code>k</code>个结点，推出是正数的第<code>n - k</code>个结点。若<code>n - k &lt; 0</code>，则返回空值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param pHead ListNode类</span></span><br><span class="line"><span class="comment">     * @param k int整型</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pHead, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode* p = pHead;</span><br><span class="line">        <span class="keyword">for</span> (; p != <span class="literal">nullptr</span>; p = p-&gt;next, len++);</span><br><span class="line">        <span class="type">int</span> step = len - k;</span><br><span class="line">        <span class="keyword">if</span> (step &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (step--) &#123;</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>用一个栈处理，由于栈是后进先出的，所以正好符合题意的倒数。倒数第k个结点就意味着栈需要弹出k次即可。</p><p>这里有一个细节，栈都弹完了，k还是大于等于0的，则应该返回空值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param pHead ListNode类</span></span><br><span class="line"><span class="comment">     * @param k int整型</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pHead, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        stack&lt;ListNode*&gt; st;</span><br><span class="line">        ListNode* res;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(pHead);</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (k-- &amp;&amp; !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;输入一个长度为 n 的链表，设链表中的元素的值为 a_i ，返回该链表中倒数第k个节点。&lt;/p&gt;
&lt;p&gt;如果该链表长度小于k，请返回一个长度</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>jz23 链表中环的入口结点</title>
    <link href="https://ruvikm.gitee.io/2023/11/20/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/"/>
    <id>https://ruvikm.gitee.io/2023/11/20/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/</id>
    <published>2023-11-20T02:33:18.000Z</published>
    <updated>2023-11-20T07:26:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。</p><p>数据范围： n≤10000，1&lt;=结点值&lt;=10000</p><p>要求：空间复杂度 O<em>(1)，时间复杂度 O</em>(<em>n</em>)</p><p>例如，输入{1,2},{3,4,5}时，对应的环形链表如下图所示：</p><p><img src="https://z1.ax1x.com/2023/11/20/piU6lqS.png" alt="img"></p><p>可以看到环的入口结点的结点值为3，所以返回结点值为3的结点。</p><h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>输入分为2段，第一段是入环前的链表部分，第二段是链表环的部分，后台会根据第二段是否为空将这两段组装成一个无环或者有环单链表</p><h3 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h3><p>返回链表的环的入口结点即可，我们后台程序会打印这个结点对应的结点值；若没有，则返回对应编程语言的空结点即可。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2&#125;,&#123;3,4,5&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回环形链表入口结点，我们后台程序会打印该环形链表入口结点对应的结点值，即3   </span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1&#125;,&#123;&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;null&quot;</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">没有环，返回对应编程语言的空结点，后台程序会打印&quot;null&quot;   </span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;,&#123;2&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环的部分只有一个结点，所以返回该环形链表入口结点，后台程序打印该结点对应的结点值，即2 </span><br></pre></td></tr></table></figure><h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>如果不考虑空间复杂度，可以使用一个大小为10000的数组<code>a</code>存放各个结点的值，每当遍历到一个节点V的时候，就把<code>a[v-val]++</code></p><p>因为存在换，所以当第一个<code>a[v-val] == 2</code>的时候，即为环的入口结点</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vt</span><span class="params">(<span class="number">10000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(pHead != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            vt[pHead-&gt;val]++;</span><br><span class="line">            <span class="keyword">if</span>(vt[pHead-&gt;val] == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>可以使用快慢指针，快指针<code>fast</code>每次走两步，慢指针<code>slow</code>每次走一步。这样如果有环存在的话，在环中，快慢指针的距离，每移动一次距离就会减一，这样如果它们相遇的话，就一定可以判断链表中有没有环。</p><p>那么如何判断环的入口点是在哪里呢？我们假设环前面的节点有a个，环中的节点有b个，慢指针走的长度为S_dis</p><p>快指针走的路线为F_dis。当两个指针相遇时，依据题意可以等于以下两个等式</p><script type="math/tex; mode=display">F_{dis} = 2  S_{dis}(因为快指针每次走的步数是慢指针的两倍)</script><script type="math/tex; mode=display">F_{dis} = a + nb(当两者相遇时，快指针一定已经绕环走了n圈)</script><p>联立可得</p><script type="math/tex; mode=display">2  S_{dis} = a + nb</script><p>可以得出</p><script type="math/tex; mode=display">a = S_{dis} = nb</script><script type="math/tex; mode=display">F_{dis} = 2nb</script><p>所以当两个指针相遇的时候，将快指针移到链表头部重新往后走，这次一次走一步。慢指针保持原来的位置，继续向后走，也是一次走一步，当两个指针相遇的时候，即是环的入口处。（这时候快指针刚好走完<code>a = nb</code>的长度到达环的入口处）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = pHead;</span><br><span class="line">        ListNode* fast = pHead;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = slow -&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">//如果指向空就说明没有环</span></span><br><span class="line">            <span class="keyword">if</span> (slow == <span class="literal">nullptr</span> || fast == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。&lt;/p&gt;
&lt;p&gt;数据范围： n≤10000，1&amp;lt;=结</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JZ52 两个链表的第一个公共结点</title>
    <link href="https://ruvikm.gitee.io/2023/11/19/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/"/>
    <id>https://ruvikm.gitee.io/2023/11/19/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/</id>
    <published>2023-11-19T11:13:13.000Z</published>
    <updated>2023-11-19T13:01:02.734Z</updated>
    
    <content type="html"><![CDATA[<p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p><p>数据范围： n≤1000<br>要求：空间复杂度 O<em>(1)，时间复杂度 )</em>O<em>(</em>n)</p><p>例如，输入{1,2,3},{4,5},{6,7}时，两个无环的单向链表的结构如下图所示：</p><p><img src="https://z1.ax1x.com/2023/11/19/piUE2Pf.png" alt="img"></p><p>可以看到它们的第一个公共结点的结点值为6，所以返回结点值为6的结点。</p><h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>输入分为是3段，第一段是第一个链表的非公共部分，第二段是第二个链表的非公共部分，第三段是第一个链表和第二个链表的公共部分。 后台会将这3个参数组装为两个链表，并将这两个链表对应的头节点传入到函数FindFirstCommonNode里面，用户得到的输入只有pHead1和pHead2。</p><h3 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h3><p>返回传入的pHead1和pHead2的第一个公共结点，后台会打印以该节点为头节点的链表。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;6,7&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一个参数&#123;1,2,3&#125;代表是第一个链表非公共部分，第二个参数&#123;4,5&#125;代表是第二个链表非公共部分，最后的&#123;6,7&#125;表示的是2个链表的公共部分</span><br><span class="line">这3个参数最后在后台会组装成为2个两个无环的单链表，且是有公共节点的          </span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1&#125;,&#123;2,3&#125;,&#123;&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2个链表没有公共节点 ,返回null，后台打印&#123;&#125;       </span><br></pre></td></tr></table></figure><h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>首先先求出两个链表的长度，让长度长一点的指针先往前走几步（走的步数 = 两链表长度差），然后让两个指针分别指向两个链表，当两个指针相等的时候几个返回当前指向的结点</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span> || pHead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> len1 = <span class="number">0</span>, len2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ListNode* p = pHead1; p != <span class="literal">nullptr</span>; p = p-&gt;next, len1++);</span><br><span class="line">        <span class="keyword">for</span> (ListNode* p = pHead2; p != <span class="literal">nullptr</span>; p = p-&gt;next, len2++);</span><br><span class="line">        <span class="type">int</span> step = <span class="built_in">abs</span>(len2 - len1);</span><br><span class="line"><span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line"><span class="keyword">while</span>(step--)&#123;</span><br><span class="line">pHead1 = pHead1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(step--)&#123;</span><br><span class="line">pHead2 = pHead2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(pHead1 != pHead2)&#123;</span><br><span class="line">pHead1 = pHead1-&gt;next;</span><br><span class="line">pHead2 = pHead2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> pHead1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>用两个指针分别指向两个链表，让其循环移动，当指向同一个结点的时候即为公共结点</p><p><img src="https://z1.ax1x.com/2023/11/19/piUES4f.png" alt="微信图片_20231119204317"></p><p>也就是说，当指针1走完{1,2,3,6,7}的时候，让它指向{4,5}。同理，当指针2走完{4,5,6,7}的时候，让它指向{1,2,3}</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="literal">nullptr</span> ||pHead2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">ListNode * H1 = pHead1, * H2 = pHead2;</span><br><span class="line"><span class="keyword">while</span>(H1 != H2)&#123;</span><br><span class="line">H1 = (H1 == <span class="literal">nullptr</span>) ? pHead2 : H1-&gt;next;</span><br><span class="line">H2 = (H2 == <span class="literal">nullptr</span>) ? pHead1 : H2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> H1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）&lt;/p&gt;
&lt;p&gt;数据范围： n≤1000&lt;br&gt;要求：空间复杂度 O&lt;em&gt;(1)，时间复杂度 )&lt;/em&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>jz25 合并两个排序的链表</title>
    <link href="https://ruvikm.gitee.io/2023/11/18/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>https://ruvikm.gitee.io/2023/11/18/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2023-11-18T02:35:51.000Z</published>
    <updated>2023-11-19T13:00:46.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p>数据范围： 0≤10000≤<em>n</em>≤1000，−1000≤节点值≤1000−1000≤节点值≤1000<br>要求：空间复杂度 <em>O</em>(1)，时间复杂度 <em>O</em>(<em>n</em>)</p><p>如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6}，转换过程如下图所示：</p><p><img src="https://z1.ax1x.com/2023/11/19/piUEyVI.png" alt="09DD8C2662B96CE14928333F055C5580"></p><p>或输入{-1,2,4},{1,3,4}时，合并后的链表为{-1,1,2,3,4,4}，所以对应的输出为{-1,1,2,3,4,4}，转换过程如下图所示：</p><p><img src="https://z1.ax1x.com/2023/11/19/piUE6at.png" alt="8266E4BFEDA1BD42D8F9794EB4EA0A13"></p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,3,5&#125;,&#123;2,4,6&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3,4,5,6&#125;</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;,&#123;&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;-1,2,4&#125;,&#123;1,3,4&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;-1,1,2,3,4,4&#125;</span><br></pre></td></tr></table></figure><h1 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h1><p>可以使用虚拟头结点，可以再新建一个链表，然后把两个链表的结点从小到大依次插入到新链表中即可。使用双指针分别指向两个链表，然后每次将较小的结点放在虚拟头结点后面，然后指针（刚刚较小的）放后移动，另一个指针不动</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param pHead1 ListNode类</span></span><br><span class="line"><span class="comment">     * @param pHead2 ListNode类</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span> (pHead2 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        ListNode* p = pHead2, *q = pHead1;</span><br><span class="line">        ListNode* newHead;</span><br><span class="line">        newHead = p-&gt;val &lt;= q-&gt;val ? p : q;</span><br><span class="line">        ListNode *res = newHead;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt;= q-&gt;val) &#123;</span><br><span class="line">                ListNode* tmp = p-&gt;next;</span><br><span class="line">                ListNode* node = p;</span><br><span class="line">                newHead-&gt;next = node;</span><br><span class="line">                newHead = node;</span><br><span class="line">                p = tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ListNode* tmp = q-&gt;next;</span><br><span class="line">                ListNode* node = q;</span><br><span class="line">                newHead-&gt;next = node;</span><br><span class="line">                newHead = node;</span><br><span class="line">                q = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            newHead-&gt;next = p;</span><br><span class="line">            newHead = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            newHead-&gt;next = q;</span><br><span class="line">            newHead = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本来打算将一个链表插入到另一个链表之中的，但是太复杂了，一直没有AC</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。&lt;/p&gt;
&lt;p&gt;数据范围： 0≤10000≤&lt;em</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JZ24 反转链表</title>
    <link href="https://ruvikm.gitee.io/2023/11/16/JZ24%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://ruvikm.gitee.io/2023/11/16/JZ24%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2023-11-16T10:48:55.000Z</published>
    <updated>2023-11-19T12:58:52.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个单链表的头结点<code>pHead</code>(该头节点是有值的，比如在下图，它的<code>val</code>是1)，长度为n，反转该链表后，返回新链表的表头。</p><p>数据范围： 0≤10000≤<em>n</em>≤1000</p><p>要求：空间复杂度 O<em>(1) ，时间复杂度 O</em>(<em>n</em>) 。</p><p>如当输入链表{1,2,3}时，</p><p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。</p><p>以上转换过程如下图所示：</p><p><img src="https://z1.ax1x.com/2023/11/19/piUEBKH.png" alt="4A47A0DB6E60853DEDFCFDF08A5CA249"></p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;3,2,1&#125;</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空链表则输出空                 </span><br></pre></td></tr></table></figure><h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>使用栈当做中转站，把每个节点倒过来，然后重新拼成一个新链表</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param head ListNode类</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        stack&lt;ListNode*&gt; st;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tail = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        ListNode* res = tail;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ListNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            tail-&gt;next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后的节点为原来的头结点，需要将其的下一个节点设为空，否则会构成环</span></span><br><span class="line">        tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://z1.ax1x.com/2023/11/16/pit8EWR.png" alt="构成环"></p><p><strong>题目细节</strong></p><p>结点3为<code>tail</code>变量，经过<code>while</code>循环，会使用尾插法将结点1和2都插入到3后面，这期间，结点2和3和<code>next</code>指针都经过了处理，而最后一个结点1的<code>next</code>指针（结点1的<code>next</code>原本是指向结点2的）却没有处理，因为此时已经跳出了<code>while</code>循环。如果不将结点1的下一个结点置为空，则会在结点1和2之间形成环，程序输出会如下：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">3,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...</span><br></pre></td></tr></table></figure><h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>使用两个结点求解，将摘下来的每一个结点使用头插法插入到新的链表中，如图画了程序两步的情况</p><p><img src="https://z1.ax1x.com/2023/11/17/pit5oeP.png" alt="反转链表"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *int val;</span></span><br><span class="line"><span class="comment"> *struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ListNode* newHead = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* tmp = head-&gt;next;</span><br><span class="line">            head-&gt;next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>扩展思维</strong></p><p>其实用<code>vector</code>容器顺序存放各个结点，然后出来的时候使用头插法新建链表也可以，这样分离结点的时候可能不太容易出错</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param head ListNode类</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        vector&lt;ListNode*&gt; vt;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">//分离结点</span></span><br><span class="line">            ListNode* tmp = head-&gt;next;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            vt.<span class="built_in">push_back</span>(head);</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新建链表</span></span><br><span class="line">        ListNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node : vt) &#123;</span><br><span class="line">            node-&gt;next = res;</span><br><span class="line">            res = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样也可以不使用<code>vector</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param head ListNode类</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* tmp = head-&gt;next;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            ListNode* node = head;</span><br><span class="line"></span><br><span class="line">            node-&gt;next = res;</span><br><span class="line">            res = node;</span><br><span class="line"></span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>tip：之前头插法一直记错了，如果头结点没有数据的话，可以使用下面的操作</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">node-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = node;</span><br></pre></td></tr></table></figure><p>但是如果头结点有值，就要用下列的插入</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">node-&gt;next = head；</span><br><span class="line">head = node;</span><br></pre></td></tr></table></figure><h2 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h2><p>原地反转，用三个指针逆置</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *int val;</span></span><br><span class="line"><span class="comment"> *struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ListNode* p = head-&gt;next, *pre = head;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//第一个结点的next指针要预先处理，循环只能处理后面结点的next指针</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* tmp = p-&gt;next;</span><br><span class="line">            <span class="comment">//反转</span></span><br><span class="line">            p-&gt;next = pre;</span><br><span class="line"></span><br><span class="line">            pre = p;</span><br><span class="line">            p = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法4"><a href="#解法4" class="headerlink" title="解法4"></a>解法4</h2><p>使用递归解决</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param head ListNode类</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* cur_next = head-&gt;next;</span><br><span class="line">        ListNode* newHead = <span class="built_in">ReverseList</span>(cur_next);</span><br><span class="line">        cur_next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;给定一个单链表的头结点&lt;code&gt;pHead&lt;/code&gt;(该头节点是有值的，比如在下图，它的&lt;code&gt;val&lt;/code&gt;是1)，长度为</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://ruvikm.gitee.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>JZ6 从尾到头打印链表</title>
    <link href="https://ruvikm.gitee.io/2023/11/15/JZ6%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://ruvikm.gitee.io/2023/11/15/JZ6%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</id>
    <published>2023-11-15T12:15:13.000Z</published>
    <updated>2023-11-19T12:58:04.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</p><p>如输入{1,2,3}的链表如下图:</p><p><img src="https://z1.ax1x.com/2023/11/19/piUE8bR.png" alt="103D87B58E565E87DEFA9DD0B822C55F"></p><p>返回一个数组为[3,2,1]</p><p>0 &lt;= 链表长度 &lt;= 10000</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[3,2,1]</span><br></pre></td></tr></table></figure><h2 id="算法思路1"><a href="#算法思路1" class="headerlink" title="算法思路1"></a>算法思路1</h2><p>主要考察翻转数组的操作，把链表的数据放到数组里，然后在数组里操作，一个比较简单的操作是调用C++的库函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vt;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            vt.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(vt.<span class="built_in">begin</span>(),vt.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> vt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="算法思路2"><a href="#算法思路2" class="headerlink" title="算法思路2"></a>算法思路2</h2><p>使用递归的方式解决，递归出口是链表循环到末尾，每次递归做的事就是把当前结点的值放到<code>vector</code>容器中，由于递归到末尾才会开始存放结点（<code>res.push_back(head-&gt;val);</code>）的值，时间顺序正好为从后往前的存放，符合题目要求的逆序</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(ListNode* head,vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">reverse</span>(head-&gt;next,res);</span><br><span class="line">            res.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">reverse</span>(head,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。&lt;/p&gt;
&lt;p&gt;如输入{1,2,3}的链表如下图:&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://ruvikm.gitee.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Win11配置多个CUDA环境</title>
    <link href="https://ruvikm.gitee.io/2023/09/30/Win11%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AACUDA%E7%8E%AF%E5%A2%83/"/>
    <id>https://ruvikm.gitee.io/2023/09/30/Win11%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AACUDA%E7%8E%AF%E5%A2%83/</id>
    <published>2023-09-30T01:25:18.000Z</published>
    <updated>2023-09-30T04:13:35.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>由于跑项目发现需要配置不同版本的Pytorch，而不同版本的Pytorch又对应不同版本的CUDA，于是有了在Win上装多个CUDA的打算</p><p>默认已经在电脑上装了一个CUDA</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqY5Bd.png" alt="屏幕截图 2023-09-30 112423"></p><p>现在开始下载第二个CUDA版本，前面下载的操作和普通安装的几乎一样</p><h2 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h2><p><a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA下载链接</a></p><p>下载自己需要的CUDA版本，以我自己要安装的为例</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqlwXn.png" alt="屏幕截图 2023-09-30 095614"></p><p><img src="https://z1.ax1x.com/2023/09/30/pPqlD00.png" alt="屏幕截图 2023-09-30 095815"></p><p>下载打开exe文件进行安装，第一步不用管，直接点击确认</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqlWc9.png" alt="屏幕截图 2023-09-30 100402"></p><p>后面选择自定义安装，只选择安装CUDA</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqlfXR.png" alt="屏幕截图 2023-09-30 100534"></p><p>其他一路下一步就可以了</p><h2 id="安装cuDNN"><a href="#安装cuDNN" class="headerlink" title="安装cuDNN"></a>安装cuDNN</h2><p><a href="https://developer.nvidia.com/rdp/cudnn-archive">cuDNN下载链接</a></p><p>PS：下载需要登录一下账号</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqlchF.png" alt="屏幕截图 2023-09-30 100047"></p><p>下载下来后，把压缩包解压，得到如下文件</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqlq9e.png" alt="image-20230930100746137"></p><p>将<strong>bin，include文件夹中的文件</strong>，分别复制到下列地址对应的文件夹下（CUDA的安装地址，以我的地址为例），遇到提示，为全部选择覆盖和替换。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.7</span><br></pre></td></tr></table></figure><p>需要注意的是，lib文件夹里的所有文件，需要复制到</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.7\lib\x64</span><br></pre></td></tr></table></figure><p>至此，安装工作就做完了，可以看到电脑上已经有两个CUDA版本了</p><p><img src="https://z1.ax1x.com/2023/09/30/pPq3dZq.png" alt="image-20230930101157014"></p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>由于CUDA11.7是后面安装的，所以可以看到系统把之前的环境覆盖了</p><p><img src="https://z1.ax1x.com/2023/09/30/pPq3rJU.png" alt="屏幕截图 2023-09-30 103109"></p><p>以作者在为例，系统变量的PATH里配置一下路径</p><p><strong>CUDA_11.7</strong></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%CUDA_PATH_V11_7%\lib\x64</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_7%\include</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_7%\extras\CUPTI\lib64</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_7%\bin</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_7%\libnvvp</span></span><br></pre></td></tr></table></figure><p><strong>CUDA_11.0</strong></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%CUDA_PATH_V11_0%\lib\x64</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_0%\include</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_0%\extras\CUPTI\lib64</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_0%\bin</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_0%\libnvvp</span></span><br></pre></td></tr></table></figure><p>配置好如下：</p><p><img src="https://z1.ax1x.com/2023/09/30/pPq3yz4.jpg" alt="微信截图_20230930105036"></p><p>配置好之后，默认CUDA版本是11.7的，如果要切换到11.0版本的，只需要把下面的五条整体上移到CUDA_11.7配置的前面</p><p><img src="https://z1.ax1x.com/2023/09/30/pPq3cQJ.jpg" alt="微信截图_20230930105411"></p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="测试CUDA11-7"><a href="#测试CUDA11-7" class="headerlink" title="测试CUDA11.7"></a>测试CUDA11.7</h3><p>首先验证CUDA_11.7是否配置成功</p><p><img src="https://z1.ax1x.com/2023/09/30/pPq8upF.png" alt="image-20230930105601201"></p><p>测试Pytorch是否可以调用显卡</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.cuda.is_available()</span><br><span class="line">torch.cuda.get_device_name(<span class="number">0</span>)</span><br><span class="line">torch.version.cuda</span><br></pre></td></tr></table></figure><p><img src="https://z1.ax1x.com/2023/09/30/pPqYiOH.png" alt="image-20230930120418607"></p><h3 id="测试CUDA11-0"><a href="#测试CUDA11-0" class="headerlink" title="测试CUDA11.0"></a>测试CUDA11.0</h3><p>先把系统变量里Path里相关路径上移</p><p><img src="https://z1.ax1x.com/2023/09/30/pPq8ZkV.jpg" alt="微信截图_20230930110409"></p><p><strong>然后重启！重启！重启！</strong></p><p>验证CUDA_11.7是否配置成功</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqGkge.png" alt="image-20230930112425329"></p><p>测试Pytorch是否可以调用显卡</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqYkmd.png" alt="image-20230930112626663"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>切换CUDA的时候除了要修改系统变量Path中的路径顺序，一定要记得重启！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;由于跑项目发现需要配置不同版本的Pytorch，而不同版本的Pytorch又对应不同版本的CUDA，于是有了在Win上装多个CUDA的打算&lt;</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>学校GPU平台使用教程</title>
    <link href="https://ruvikm.gitee.io/2023/08/28/%E5%AD%A6%E6%A0%A1GPU%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://ruvikm.gitee.io/2023/08/28/%E5%AD%A6%E6%A0%A1GPU%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2023-08-28T01:18:54.000Z</published>
    <updated>2024-04-01T11:09:52.725Z</updated>
    
    <content type="html"><![CDATA[<p>首先连接内网登录<a href="http://paas.183-175-12-11.nip.io:30080/">平台</a></p><p>一般使用的话，直接找到<code>开发环境</code>一栏，创建环境。然后通过<code>Pycharm</code>中的<code>ssh</code>连接</p><p><img src="https://s1.ax1x.com/2023/08/28/pPaw2X6.png" alt="屏幕截图 2023-08-28 221321"></p><p>在<code>Pycharm</code>中，找到工具—部署—配置</p><p><img src="https://s1.ax1x.com/2023/08/28/pPad5zq.png" alt="image-20230828220300678"></p><p>点击<code>+</code>后选择<code>SFTP</code></p><p><img src="https://s1.ax1x.com/2023/08/28/pPaw5Ae.png" alt="屏幕截图 2023-08-28 221526"></p><p>在<code>SSH配置</code>那里后点击后面<code>...</code></p><p><img src="https://s1.ax1x.com/2023/08/28/pPawbct.png" alt="屏幕截图 2023-08-28 092517"></p><p>进入后填写主机名和用户名，这里详细讲一下</p><p>例如平台给的ssh连接是</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ssh://root@paas.xxx-xxx-xx-xx.nip.io:xxxxx</span><br></pre></td></tr></table></figure><p>这里用户名就需要填写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root</span><br></pre></td></tr></table></figure><p>主机名填写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">paas.xxx-xxx-xx-xx.nip.io</span><br></pre></td></tr></table></figure><p>端口号填写<code>xxxxx</code></p><p>然后填写创建环境时设置的密码</p><p><img src="https://s1.ax1x.com/2023/08/28/pPawjHS.png" alt="屏幕截图 2023-08-28 092917"></p><p>这一步完事以后，点击确定，返回到之前的页面，点击<code>映射</code></p><p><img src="https://s1.ax1x.com/2023/08/30/pPd7RaD.png" alt="屏幕截图 2023-08-30 145658"></p><p>配置好本机的地址和远程的地址，点击确认</p><p><img src="https://s1.ax1x.com/2023/08/30/pPd7LdS.png" alt="image-20230830145937224"></p><p>之后选择工具—部署—选项</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdHIkF.png" alt="QQ截图20230830150656"></p><p>可以根据自己习惯决定是否配置一下</p><p>然后找到工具—启动SSH会话，选择刚刚配置的SSH</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdbmtg.png" alt="屏幕截图 2023-08-30 151730"></p><p>然后输入</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.executable)</span><br></pre></td></tr></table></figure><p>记住输出的地址，比如我的就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usr/bin/python</span><br></pre></td></tr></table></figure><p>最后，找到项目—项目XXXX—Python解释器，找到添加解释器—SSH</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdHj0K.png" alt="image-20230830151124394"></p><p>选择刚刚配置的SSH服务器，然后下一步</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdbHUS.png" alt="屏幕截图 2023-08-30 152226"></p><p>点击下一步</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdbO3j.png" alt="image-20230830152644100"></p><p>然后选择<code>现有</code></p><p>把刚刚的地址输入到<code>解释器</code>里</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdqSbV.png" alt="image-20230830152826067"></p><p>点击确定就完事了</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdqtqP.png" alt="image-20230830152939492"></p><p>之后用<code>工具</code>—<code>SSH会话</code>配合，就可以用学校的GPU跑程序了</p><p>tips：后期可以在服务器上安装<code>Anaconda</code>，然后把新建的虚拟环境中python路径配置到上述图片的<code>解释器</code>中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook --ip 0.0.0.0 --allow-root</span><br></pre></td></tr></table></figure><p>再补充一下，之前用conda的操作可能是麻烦了，服务器里自带好多python的环境，每个环境里也有很多自带的包</p><p><img src="https://z1.ax1x.com/2023/10/04/pPOHyIe.png" alt="屏幕截图 2023-10-04 204942"></p><p>选择例如选择python3.6后</p><p><img src="https://z1.ax1x.com/2023/10/04/pPOHgGd.png" alt="屏幕截图 2023-10-04 211210"></p><p>之后就《愉快》的调参吧，附一张成功用学校GPU跑代码的图片</p><p><img src="https://z1.ax1x.com/2023/10/04/pPOHqRs.png" alt="image-20231004211915616"></p><p> <strong>10.19继续补充一下</strong><br>有的项目跑起来需要运行作者的<code>run.sh</code>文件，这时候需要切换到项目的目录然后运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash run.sh</span><br></pre></td></tr></table></figure><p>但是环境默认是python2.7版本的，项目跑不起来，这时候需要切换python的环境</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whereis python</span><br><span class="line">rm /usr/bin/python</span><br><span class="line">ln -s /usr/bin/python3.6 /usr/bin/python</span><br></pre></td></tr></table></figure><p><img src="https://z1.ax1x.com/2023/10/19/piitih6.png" alt="image-20231019153231564"></p><p>还有一种方法，比如需要切换的环境在</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usr/bin/python3.6</span><br></pre></td></tr></table></figure><p>这时候需要在<code>.sh</code>文件中开头加上</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env python3.6</span></span><br></pre></td></tr></table></figure><p>可以在后面查看python环境</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python --version</span><br></pre></td></tr></table></figure><p><img src="https://z1.ax1x.com/2023/10/19/piir6K0.png" alt="image-20231019163749724"></p><p>这时候就切换了</p><p>2024-4-1补充</p><p>其实可以用Pycharm上传文件，然后用Xshell跑代码，Xshell配置和之前的大差不差</p><p><img src="https://s21.ax1x.com/2024/04/01/pF7gw01.png" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先连接内网登录&lt;a href=&quot;http://paas.183-175-12-11.nip.io:30080/&quot;&gt;平台&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一般使用的话，直接找到&lt;code&gt;开发环境&lt;/code&gt;一栏，创建环境。然后通过&lt;code&gt;Pycharm&lt;/code&gt;中的&lt;co</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>使用蓝牙外设却不小心把台式机电脑蓝牙关了</title>
    <link href="https://ruvikm.gitee.io/2023/08/12/%E4%BD%BF%E7%94%A8%E8%93%9D%E7%89%99%E5%A4%96%E8%AE%BE%E5%8D%B4%E4%B8%8D%E5%B0%8F%E5%BF%83%E6%8A%8A%E5%8F%B0%E5%BC%8F%E6%9C%BA%E7%94%B5%E8%84%91%E8%93%9D%E7%89%99%E5%85%B3%E4%BA%86/"/>
    <id>https://ruvikm.gitee.io/2023/08/12/%E4%BD%BF%E7%94%A8%E8%93%9D%E7%89%99%E5%A4%96%E8%AE%BE%E5%8D%B4%E4%B8%8D%E5%B0%8F%E5%BF%83%E6%8A%8A%E5%8F%B0%E5%BC%8F%E6%9C%BA%E7%94%B5%E8%84%91%E8%93%9D%E7%89%99%E5%85%B3%E4%BA%86/</id>
    <published>2023-08-12T09:43:40.000Z</published>
    <updated>2023-08-12T10:54:07.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>今天犯了一个贼SB的错误，起因是蓝牙键盘突然就不能输入了（虽然是连接状态，但是按什么键都没有反应）</p><p>原来我的解决方法就是重启一下电脑，但是那会电脑开了贼多的软件。我就想重启也太麻烦了，既然重启的本质也是重启蓝牙，那我要不直接就把蓝牙重启算了，当时想到这里啊，我心中一阵狂喜，觉得我真TMD是个天才</p><p>于是我兴冲冲的找到系统设置—蓝牙，把蓝牙关了，然后当我准备开启蓝牙的时候，我傻眼了，艹，我外设都是蓝牙连接的啊，这TM开不开了</p><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><h3 id="尝试用带USB接收器的鼠标"><a href="#尝试用带USB接收器的鼠标" class="headerlink" title="尝试用带USB接收器的鼠标"></a>尝试用带USB接收器的鼠标</h3><p>我的鼠标不仅可以蓝牙连接，还可以用USB接收器连接，我心想这不是轻轻松松简简单单。于是给鼠标换了一个连接方式，插入了USB接收器。但是奇怪的事情发生了，无论我怎么动鼠标，鼠标的指针就是纹丝不动。我怀疑难道是关了蓝牙功能，连这个都影响到了吗</p><h3 id="尝试用有线设备"><a href="#尝试用有线设备" class="headerlink" title="尝试用有线设备"></a>尝试用有线设备</h3><p>虽然心中有一丝紧张，但是我感觉这不就是个小事嘛，那要不找个有线的外设不就可以了。于是翻箱倒柜，刨出来家里的古董有线键盘，插入了电脑前面的USB口。</p><p>但是，重量级来了，无论按什么键，都没有反应，让我一度以为是不是键盘寄了。然后我把键盘插到了笔记本上，发现还是可以用的，灯也是亮的（但是刚刚插在台式机上灯就没亮）</p><p>前面不行，后面总可以吧，肯定么得问题（Flag立的飞起）我买的主板可是有7个USB插口呢！！！这么想着我钻到桌子下面，吸着尘土，一个一个试着USB口，结果是全都不能用。当时心态就发生了一丝变化，我看着屏幕，屏幕看着我，但是感觉我们之间隔了一个不可逾越的鸿沟，那个鸿沟就是USB口。</p><h3 id="尝试远程软件"><a href="#尝试远程软件" class="headerlink" title="尝试远程软件"></a>尝试远程软件</h3><p>我逐渐意识到了问题的严重性，但我灵机一动，心想不还有远程软件么，用手机作为输入不就解决了。</p><p>我再次满怀希望的打开手机远程操作APP，在“我的设备”里寻找台式机，但是，咚咚咚！！！设备显示是离线状态，这我才想起来之前为了优化开机，把这个软件的开机自启给关了，我又傻眼了。</p><h3 id="分析现状"><a href="#分析现状" class="headerlink" title="分析现状"></a>分析现状</h3><p>现在的问题是，台式机蓝牙关了，但是我的常用外设都是蓝牙连接的，没有有线功能。我有一个有线键盘，但是台式机的USB口不知道为什么全不能用了，这就意味着即使我有有线鼠标理论上也没有用。远程软件也没有开启，不用通过手机远程把蓝牙打开。</p><h3 id="扣电池"><a href="#扣电池" class="headerlink" title="扣电池"></a>扣电池</h3><p>和卖主板的客服沟通后，建议我扣主板电池试试。关机后，等待5min后（为了放干净电），我把电池扣了下来，又等了3min左右装了上去。奇迹发生了，USB口能用了！！！于是我用键盘操作（一路按tab键）这找到了蓝牙的开关按钮，</p><p><img src="https://s1.ax1x.com/2023/08/12/pPu8BIP.png" alt="屏幕截图 2023-08-12 181458"></p><p>按空格打开了蓝牙的开关，至此，终于是解决了！！！</p><p>PS：如果不知道用空格是确认，当时用键盘打开我的远程软件其实也解决了</p><h2 id="反思及预防"><a href="#反思及预防" class="headerlink" title="反思及预防"></a>反思及预防</h2><p>三思而后行啊，<del>以及中午不能睡时间太长</del></p><h3 id="关闭蓝牙功能影响USB接收器的使用吗"><a href="#关闭蓝牙功能影响USB接收器的使用吗" class="headerlink" title="关闭蓝牙功能影响USB接收器的使用吗"></a>关闭蓝牙功能影响USB接收器的使用吗</h3><p>之后又专门把蓝牙关了，使用带USB接收器的鼠标连接，发现可以正常使用。看来问题就出在USB接口上了</p><h3 id="为什么USB接口不能用"><a href="#为什么USB接口不能用" class="headerlink" title="为什么USB接口不能用"></a>为什么USB接口不能用</h3><p>然后网上查到了USB口之前为什么不能用的原因及解决方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了省电，Windows默认情况下会在不使用USB控制器时将其关闭，在需要时再将其重新开启。但有时候Windows不会自动开启。</span><br><span class="line">1、右键单击开始菜单，打开设备管理器。</span><br><span class="line">2、双击展开“通用串行总线控制器”一栏。</span><br><span class="line">3、双击列表中的第一个“USB根集线器”。</span><br><span class="line">4、点击切换到“电源管理”标签页。</span><br><span class="line">5、取消勾选“允许计算机关闭此设备以节省电源”，点击“确定”。</span><br><span class="line">6、对通用串行总线控制器列表中的每个“USB根集线器”重复步骤3-5。</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/08/12/pPu8haq.png" alt="image-20230812182055614"></p><p>按照教程把上面一个一个都关了就好了</p><h3 id="打开远程软件的自启"><a href="#打开远程软件的自启" class="headerlink" title="打开远程软件的自启"></a>打开远程软件的自启</h3><p>由于也没啥重要的东西，就把软件自启打开了。再也不想为了一点优化差点坑死自己了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;今天犯了一个贼SB的错误，起因是蓝牙键盘突然就不能输入了（虽然是连接状态，但是按什么键都没有反应）&lt;/p&gt;
&lt;p&gt;原来我的解决方法就是重启一</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>拼模型尝试</title>
    <link href="https://ruvikm.gitee.io/2023/08/12/%E6%8B%BC%E6%A8%A1%E5%9E%8B%E5%B0%9D%E8%AF%95/"/>
    <id>https://ruvikm.gitee.io/2023/08/12/%E6%8B%BC%E6%A8%A1%E5%9E%8B%E5%B0%9D%E8%AF%95/</id>
    <published>2023-08-12T02:40:48.000Z</published>
    <updated>2023-08-15T07:53:48.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>记录一下自己首次组合模型的过程，希望可以为以后论文打基础。</p><p>PS：由于自己是零基础，看了一下李沐的教程，感觉理论部分有点多，没看完可能<code>deadline</code>都到了。唐老师的人工智能课也看了看，总感觉不是特别系统，都是一个一个项目，于是我打算效率亿点点，需要什么先学什么。</p><p>我需要跑的一个模型是这样的架构</p><p><img src="https://s1.ax1x.com/2023/08/12/pPuCZes.png" alt="模型架构"></p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>客观分析一下我遇到的这个问题</p><p><strong>1.目标问题</strong></p><p>把这个架构跑通$\rightarrow$</p><p>从中文电子病历提取有用信息$\rightarrow$</p><p>进行医疗大数据挖掘、临床辅助决策系统、AI 电子病历质控系统构建等的基础工作</p><p><strong>2.方法问题</strong></p><p>寻找相似的项目或者使用了相似模型架构的项目，把他们的模型删删改改</p><p>删改可能需要借助到模型的官方文档，例如<a href="https://paddlenlp.readthedocs.io/zh/latest/index.html">PaddleNLP文档</a>，或者<a href="https://pytorch-cn.readthedocs.io/zh/latest/">PyTorch文档</a></p><p>然后多借鉴一些博客的方法</p><p><strong>3.执行问题</strong></p><p>先安装一下paddle，然后尝试先把网上的项目跑通，在看懂的基础上进行修改</p><h2 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h2><h3 id="安装paddleNLP"><a href="#安装paddleNLP" class="headerlink" title="安装paddleNLP"></a>安装paddleNLP</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认前提是已经安装好了paddle(2.5.1)，我之前已经安装完，现在直接进入这个环境(CUDA 11.0)</span></span><br><span class="line">conda activate paddle</span><br><span class="line"><span class="comment"># 安装PaddleNLP 换成阿里云的镜像安装会快很多</span></span><br><span class="line">pip install --upgrade paddlenlp&gt;=2.0.0rc -i https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure><p>验证安装</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> paddlenlp</span><br></pre></td></tr></table></figure><p>没有error应该就是安装好了</p><h3 id="复现别人项目"><a href="#复现别人项目" class="headerlink" title="复现别人项目"></a>复现别人项目</h3><p>首先找到一个使用了类似框架的项目——<a href="https://aistudio.baidu.com/aistudio/projectdetail/1761182">中文命名实体识别-Bi-GRU+CRF</a>，然后把代码以<code>.py</code>的格式下载下来,用PyCharm打开</p><p>打开后项目结构如下</p><p><img src="https://s1.ax1x.com/2023/08/13/pPKFcad.png" alt="image-20230813171608656"></p><p>开始一步一步跑了</p><p>首先遇到的一个问题，<code>UnicodeDecodeError: &#39;gbk&#39; codec can&#39;t decode byte 0xa8 in position 2: illegal multibyte sequence</code></p><p><img src="https://s1.ax1x.com/2023/08/13/pPKFoqg.png" alt="image-20230813172211506"></p><p>加一个<code>encoding</code>属性就可以了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">open</span>(<span class="string">&#x27;data/train.txt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)):</span><br></pre></td></tr></table></figure><p>往下跑的时候又出现了一个错，<code>ValueError: not enough values to unpack (expected 2, got 1)</code></p><p><img src="https://s1.ax1x.com/2023/08/13/pPK0js0.png" alt="image-20230813205507724"></p><p>经过调试发现，<code>word_vocab = load_dict(&#39;./conf/word.dic&#39;)</code>这句就不会报错，只有前一句报错，于是我对比了两个数据集，发现了原因</p><p><code>word.dic</code>数据集（部分）</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">0a</span><br><span class="line">1e</span><br><span class="line">2i</span><br><span class="line">3n</span><br><span class="line">4o</span><br><span class="line">5s</span><br></pre></td></tr></table></figure><p><code>tag.dic</code>数据集（部分）</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">B-PER</span><br><span class="line">I-PER</span><br><span class="line">B-ORG</span><br><span class="line">I-ORG</span><br></pre></td></tr></table></figure><p>问题就出现在函数<code>load_dict</code>的这句话上</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_dict</span>(<span class="params">dict_path</span>):</span><br><span class="line">    vocab = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(dict_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>):</span><br><span class="line">    //这句有问题，第一个数据集一行有两个参数，但是第二个数据集只有一个参数</span><br><span class="line">        value, key = line.strip(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;\t&#x27;</span>)  </span><br><span class="line">        vocab[key] = <span class="built_in">int</span>(value)</span><br><span class="line">    <span class="keyword">return</span> vocab</span><br></pre></td></tr></table></figure><p>于是我分开写了两个函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_word_dict</span>(<span class="params">dict_path</span>):</span><br><span class="line">    vocab = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(dict_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>):</span><br><span class="line">        value, key = line.strip(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        vocab[key] = <span class="built_in">int</span>(value)</span><br><span class="line">    <span class="keyword">return</span> vocab</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_tag_dict</span>(<span class="params">dict_path</span>):</span><br><span class="line">    vocab = &#123;&#125;</span><br><span class="line">    key = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(dict_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>):</span><br><span class="line">        value = line.strip(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        vocab[key] = value</span><br><span class="line">        key += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> vocab</span><br></pre></td></tr></table></figure><p>后面的调用在改一下就行了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">label_vocab = load_tag_dict(<span class="string">&#x27;./conf/tag.dic&#x27;</span>) </span><br><span class="line">word_vocab = load_word_dict(<span class="string">&#x27;./conf/word.dic&#x27;</span>)</span><br></pre></td></tr></table></figure><p>按照同样的逻辑，把前面单元格里的代码改一下就行，但是发现还有错误</p><p><img src="https://s1.ax1x.com/2023/08/13/pPKBYef.png" alt="image-20230813211023632"></p><p>发现上下两个代码块其实意思差不多，把上面代码块里的<code>load_dataset</code>函数替换掉下面的就行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_dataset</span>(<span class="params">datafiles</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">data_path</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(data_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            word_list = []</span><br><span class="line">            tag_list = []</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                <span class="keyword">if</span> line != <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">                    word, tag = line.strip(<span class="string">&#x27;\n&#x27;</span>).split()</span><br><span class="line">                    word_list.append(word)</span><br><span class="line">                    tag_list.append(tag)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">yield</span> word_list, tag_list</span><br><span class="line">                    word_list = []</span><br><span class="line">                    tag_list = []</span><br><span class="line">            <span class="comment"># next(fp)</span></span><br><span class="line">            <span class="comment"># for line in fp.readlines():</span></span><br><span class="line">            <span class="comment">#     words, labels = line.strip(&#x27;\n&#x27;).split(&#x27;\t&#x27;)</span></span><br><span class="line">            <span class="comment">#     words = words.split(&#x27;\002&#x27;)</span></span><br><span class="line">            <span class="comment">#     labels = labels.split(&#x27;\002&#x27;)</span></span><br><span class="line">            <span class="comment">#     yield words, labels</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(datafiles, <span class="built_in">str</span>):</span><br><span class="line">        <span class="keyword">return</span> MapDataset(<span class="built_in">list</span>(read(datafiles)))</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(datafiles, <span class="built_in">list</span>) <span class="keyword">or</span> <span class="built_in">isinstance</span>(datafiles, <span class="built_in">tuple</span>):</span><br><span class="line">        <span class="keyword">return</span> [MapDataset(<span class="built_in">list</span>(read(datafile))) <span class="keyword">for</span> datafile <span class="keyword">in</span> datafiles]</span><br></pre></td></tr></table></figure><p>之后好多代码块都没有报错，直到需要训练的时候，遇到了这个</p><p><img src="https://s1.ax1x.com/2023/08/13/pPKsRk8.png" alt="image-20230813220554458"></p><p>网上查了好长时间也不知道怎么解决，以为是版本<code>paddle</code>太高了，降级完但是出现了更多的错，弄了好半天也没成功，最后又装回<code>2.5.1</code>版本的了。后来看到网上说很可能是dataset类型的原因，官方API要求的类型如下</p><p><strong>dataset</strong> (Dataset) - <code>DataLoader</code> 从此参数给定数据集中加载数据，此参数必须是 <code>paddle.io.Dataset</code> 或 <code>paddle.io.IterableDataset</code> 的一个子类实例。</p><p>而我的类型是<code>paddlenlp.datasets.dataset.MapDataset</code></p><p><img src="https://s1.ax1x.com/2023/08/15/pPQAQHS.png" alt="image-20230815155330435"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;记录一下自己首次组合模型的过程，希望可以为以后论文打基础。&lt;/p&gt;
&lt;p&gt;PS：由于自己是零基础，看了一下李沐的教程，感觉理论部分有点多，没</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>复现论文SpikeGPT Generative Pre-trained Language Model with Spiking Neural Networks</title>
    <link href="https://ruvikm.gitee.io/2023/07/22/%E5%A4%8D%E7%8E%B0%E8%AE%BA%E6%96%87SpikeGPT-Generative%20Pre-trained%20Language%20Model%20with%20Spiking%20Neural%20Networks/"/>
    <id>https://ruvikm.gitee.io/2023/07/22/%E5%A4%8D%E7%8E%B0%E8%AE%BA%E6%96%87SpikeGPT-Generative%20Pre-trained%20Language%20Model%20with%20Spiking%20Neural%20Networks/</id>
    <published>2023-07-22T01:28:55.000Z</published>
    <updated>2023-08-12T10:26:23.385Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下复现论文<a href="https://arxiv.org/abs/2302.13939v2">SpikeGPT: Generative Pre-trained Language Model with Spiking Neural Networks</a>的过程，论文给出了项目的<a href="https://github.com/ridgerchu/SpikeGPT">GitHub</a>地址。此博客是边跑边写边改的，尽量把顺序合理化，让人可以少走一些弯路</p><h2 id="论文概述"><a href="#论文概述" class="headerlink" title="论文概述"></a>论文概述</h2><p>利用工具，可以大概对此篇论文有如下了解</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">这篇文章介绍了SpikeGPT，这是一种基于脉冲神经网络(SNNs)的生成式语言模型。SNNs利用稀疏、事件驱动的激活方式来减少计算复杂性，提高能源效率，因此在深度学习领域有很大的潜力。虽然SNNs在计算机视觉任务上取得了成功，但在语言生成方面仍然有待进一步探索，因为它们的训练过程相对复杂。文章的作者们对Transformer模块进行了修改，消除了多头自注意力带来的二次计算复杂度，并引入循环计算，实现了逐词计算，同时保留了长程依赖关系。结果得到的SpikeGPT模型在语言生成任务上表现出竞争力，同时能耗仅为传统人工神经网络(ANNs)的五分之一。该模型还是迄今为止最大的反向传播训练的功能性SNN模型，拥有多达2.6亿个参数。这项工作为在自然语言处理任务中有效训练大规模SNNs并将Transformer架构与SNNs结合起来实现高性能和能源效率开辟了新的潜力。</span><br></pre></td></tr></table></figure><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="新建环境"><a href="#新建环境" class="headerlink" title="新建环境"></a>新建环境</h3><p>新建一个<code>Conda</code>环境</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n SpikeGPT python=3.8</span><br><span class="line">conda activate SpikeGPT</span><br></pre></td></tr></table></figure><p>然后用<code>pycharm</code>打开此项目，并切换到刚刚新建的环境</p><p>接下来就是安装环境了，由于作者没有提供具体包的版本，只能根据缺啥安装啥的原则，有什么问题之后再慢慢改</p><h3 id="安装accelerate"><a href="#安装accelerate" class="headerlink" title="安装accelerate"></a>安装accelerate</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install accelerate</span><br></pre></td></tr></table></figure><p>在安装<code>accelerate</code>的时候，自动给我装了一个torch2.0.1版本的，这个后面管，只要这个torch版本大于10.0.0就行</p><h3 id="安装Pytorch"><a href="#安装Pytorch" class="headerlink" title="安装Pytorch"></a>安装Pytorch</h3><p>根据我的<code>CUDA</code>版本，安装了如下的<code>torch</code>，具体安装细节可以参考<a href="https://ruvikm.gitee.io/2023/06/06/Win11%E9%85%8D%E7%BD%AEAnaconda-Cuda-Pytorch-Tenserflow%E7%8E%AF%E5%A2%83/">这篇博客</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install pytorch==1.11.0 torchvision==0.12.0 torchaudio==0.11.0 cudatoolkit=11.3</span><br></pre></td></tr></table></figure><h3 id="安装matplotlib"><a href="#安装matplotlib" class="headerlink" title="安装matplotlib"></a>安装matplotlib</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install matplotlib</span><br></pre></td></tr></table></figure><h3 id="安装tqdm"><a href="#安装tqdm" class="headerlink" title="安装tqdm"></a>安装tqdm</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install tqdm</span><br></pre></td></tr></table></figure><h3 id="安装transformers"><a href="#安装transformers" class="headerlink" title="安装transformers"></a>安装transformers</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install transformers</span><br></pre></td></tr></table></figure><h3 id="安装deepspeed"><a href="#安装deepspeed" class="headerlink" title="安装deepspeed"></a>安装deepspeed</h3><h4 id="错误安装方法"><a href="#错误安装方法" class="headerlink" title="错误安装方法"></a>错误安装方法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install deepspeed</span><br></pre></td></tr></table></figure><p>安装的时候报错了</p><p><img src="https://s1.ax1x.com/2023/07/22/pCbvDot.png" alt="image-20230722102232403"></p><p>换<code>conda</code>试了后，<code>conda install deepspeed</code>，也不行。</p><p>网上查了一个安装方式</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install transformers[deepspeed]</span><br></pre></td></tr></table></figure><p>还是那个错，网上查了一下</p><p><img src="https://s1.ax1x.com/2023/07/22/pCbxpY6.png" alt="image-20230722103014784"></p><p>设置一下环境变量试试</p><p><img src="https://s1.ax1x.com/2023/07/22/pCbxX38.png" alt="屏幕截图 2023-07-22 105535"></p><p>报错！！！好消息是报错变了</p><p><img src="https://s1.ax1x.com/2023/07/22/pCbxbNt.png" alt="image-20230722105444097"></p><p>去<code>github</code>看了一下，意思大概是这个库原本是在<code>linux</code>上的，在<code>window</code>上的支持还不是很好</p><p><img src="https://s1.ax1x.com/2023/07/22/pCbxy7R.png" alt="image-20230722103953254"></p><h4 id="正确安装方法"><a href="#正确安装方法" class="headerlink" title="正确安装方法"></a>正确安装方法</h4><p>网上查到一篇win10成功安装的<a href="https://zhuanlan.zhihu.com/p/636450918">博客</a>，按照博客的说法</p><p>首先安装必要组件</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq9crD.png" alt="image-20230722122822936">先把<a href="https://github.com/microsoft/DeepSpeed">官方</a>的开源的代码下载下来，解压（要用管理员权限）后</p><p>用管理员权限打开cmd，切换到解压的目录，在命令行输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">build_win.bat</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/22/pCq9A8P.png" alt="image-20230722121606679"></p><p>慢慢改错吧，先解决一个报错最多的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error: attribute <span class="string">&quot;nodiscard&quot;</span> does not take arguments</span><br></pre></td></tr></table></figure><h3 id="下载数据集"><a href="#下载数据集" class="headerlink" title="下载数据集"></a>下载数据集</h3><p>作者提供数据集<code>Enwik8</code><a href="https://data.deepai.org/enwik8.zip">下载地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下复现论文&lt;a href=&quot;https://arxiv.org/abs/2302.13939v2&quot;&gt;SpikeGPT: Generative Pre-trained Language Model with Spiking Neural Networks&lt;/a&gt;的过程，</summary>
      
    
    
    
    <category term="论文复现" scheme="https://ruvikm.gitee.io/categories/%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>安装PaddlePaddle</title>
    <link href="https://ruvikm.gitee.io/2023/07/21/%E5%AE%89%E8%A3%85PaddlePaddle/"/>
    <id>https://ruvikm.gitee.io/2023/07/21/%E5%AE%89%E8%A3%85PaddlePaddle/</id>
    <published>2023-07-21T02:23:04.000Z</published>
    <updated>2023-07-21T02:54:49.046Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下安装的过程，官方文档如下</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">https://www.paddlepaddle.org.cn/documentation/docs/zh/install/conda/windows-conda.html</span><br></pre></td></tr></table></figure><h2 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create -n paddle python=3.8</span><br><span class="line">conda activate paddle</span><br></pre></td></tr></table></figure><h2 id="查看自己安装的CUDA版本"><a href="#查看自己安装的CUDA版本" class="headerlink" title="查看自己安装的CUDA版本"></a>查看自己安装的CUDA版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/21/pCHjtOA.png" alt="image-20230721102917138"></p><p>选择适合自己的版本，我安装的是CUDA11.2的</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install paddlepaddle-gpu==2.5.0 cudatoolkit=11.2 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/Paddle/ -c conda-forge</span><br></pre></td></tr></table></figure><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line">paddle.utils.run_check()</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/21/pCHvsN6.png" alt="image-20230721105441359"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下安装的过程，官方文档如下&lt;/p&gt;
&lt;figure class=&quot;highlight tex&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https://www.paddlepaddle.org.cn/do</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
