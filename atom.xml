<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ruvikm</title>
  <icon>https://www.gravatar.com/avatar/710ecfc7f4f0bd22cb3d5ec44d498105</icon>
  <subtitle>Nia~</subtitle>
  <link href="https://ruvikm.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://ruvikm.gitee.io/"/>
  <updated>2024-05-03T12:05:24.036Z</updated>
  <id>https://ruvikm.gitee.io/</id>
  
  <author>
    <name>Ruvikm</name>
    <email>ruvikm@126.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Centos 7常用操作记录</title>
    <link href="https://ruvikm.gitee.io/2024/05/03/Centos%207%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    <id>https://ruvikm.gitee.io/2024/05/03/Centos%207%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/</id>
    <published>2024-05-03T11:08:37.000Z</published>
    <updated>2024-05-03T12:05:24.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h2><h3 id="搜索某一个进程-以进程Server为例"><a href="#搜索某一个进程-以进程Server为例" class="headerlink" title="搜索某一个进程(以进程Server为例)"></a>搜索某一个进程(以进程Server为例)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep 进程名 <span class="comment"># 根据进程名查看进程信息</span></span><br><span class="line"></span><br><span class="line">netstat -tunlp | grep 端口号 <span class="comment"># 根据端口查看对应进程，查看占用8080端口的进程id</span></span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep Server</span><br><span class="line"></span><br><span class="line">netstat -tunlp | grep 8080</span><br></pre></td></tr></table></figure><h3 id="关闭进程"><a href="#关闭进程" class="headerlink" title="关闭进程"></a>关闭进程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 端口号</span><br></pre></td></tr></table></figure><p>举例：例如要关闭端口号为8088的进程</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 8088</span><br></pre></td></tr></table></figure><h2 id="防火墙相关"><a href="#防火墙相关" class="headerlink" title="防火墙相关"></a>防火墙相关</h2><h3 id="放行端口"><a href="#放行端口" class="headerlink" title="放行端口"></a>放行端口</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=4568/tcp --permanent   <span class="comment"># 开放4568端口</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public --remove-port=4567/tcp --permanent  <span class="comment">#关闭4567端口</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --reload   <span class="comment"># 配置立即生效</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进程相关&quot;&gt;&lt;a href=&quot;#进程相关&quot; class=&quot;headerlink&quot; title=&quot;进程相关&quot;&gt;&lt;/a&gt;进程相关&lt;/h2&gt;&lt;h3 id=&quot;搜索某一个进程-以进程Server为例&quot;&gt;&lt;a href=&quot;#搜索某一个进程-以进程Server为例&quot; class</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>客户端升级封装EasyTcpClient，同时与多个服务端进行网络通信</title>
    <link href="https://ruvikm.gitee.io/2024/04/28/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8D%87%E7%BA%A7%E5%B0%81%E8%A3%85EasyTcpClient%EF%BC%8C%E5%90%8C%E6%97%B6%E4%B8%8E%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    <id>https://ruvikm.gitee.io/2024/04/28/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8D%87%E7%BA%A7%E5%B0%81%E8%A3%85EasyTcpClient%EF%BC%8C%E5%90%8C%E6%97%B6%E4%B8%8E%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</id>
    <published>2024-04-28T14:54:33.000Z</published>
    <updated>2024-04-28T15:05:34.673Z</updated>
    
    <content type="html"><![CDATA[<p>封装客户端操作<code>EasyTcpClient.hpp</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> EasyTcpClient.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EasyTcpClient.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">//uni std</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVALID_SOCKET  (SOCKET)(~0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_ERROR            (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MessageHeader.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span><span class="comment">//C++标准线程库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EasyTcpClient</span></span><br><span class="line">&#123;</span><br><span class="line">SOCKET _sock;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">EasyTcpClient</span>() &#123;</span><br><span class="line">_sock = INVALID_SOCKET;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虚构析函数</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">EasyTcpClient</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化Socket</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//启动Win Socket 2.x环境</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA dat;</span><br><span class="line"><span class="built_in">WSAStartup</span>(ver, &amp;dat);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN32</span></span></span><br><span class="line"><span class="comment">// 1 建立一个socket</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsRun</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;socket = &quot;</span> &lt;&lt; (<span class="type">int</span>)_sock &lt;&lt; <span class="string">&quot;&gt; 关闭旧连接...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br><span class="line">_sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsRun</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;socket = &quot;</span> &lt;&lt; (<span class="type">int</span>)_sock &lt;&lt; <span class="string">&quot;&gt;建立Socket失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;socket = &quot;</span> &lt;&lt; (<span class="type">int</span>)_sock &lt;&lt; <span class="string">&quot;&gt;建立Socket成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接服务器</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsRun</span>()) &#123;</span><br><span class="line"><span class="built_in">InitSocket</span>();</span><br><span class="line">&#125;</span><br><span class="line">sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">_sin.sin_family = AF_INET;</span><br><span class="line">_sin.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">_sin.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(ip);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">_sin.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;socket = &quot;</span> &lt;&lt; (<span class="type">int</span>)_sock &lt;&lt; <span class="string">&quot;&gt; 正在连接服务器&lt;port:&quot;</span> &lt;&lt; port &lt;&lt; <span class="string">&quot;&gt;...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span>  ret = <span class="built_in">connect</span>(_sock, (sockaddr*)&amp;_sin, <span class="built_in">sizeof</span>(sockaddr_in));</span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == ret) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;socket = &quot;</span> &lt;&lt; (<span class="type">int</span>)_sock &lt;&lt; <span class="string">&quot;&gt; 连接服务器&lt;port:&quot;</span> &lt;&lt; port &lt;&lt; <span class="string">&quot;&gt;失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;socket = &quot;</span> &lt;&lt; (<span class="type">int</span>)_sock &lt;&lt; <span class="string">&quot;&gt; 连接服务器&lt;port:&quot;</span> &lt;&lt; port &lt;&lt; <span class="string">&quot;&gt;成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭套接字closesocket</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsRun</span>()) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="built_in">closesocket</span>(_sock);</span><br><span class="line"><span class="comment">// 清除windows socket环境</span></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">close</span>(_sock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN32</span></span></span><br><span class="line">_sock = INVALID_SOCKET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相应网络请求</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnNetMsg</span><span class="params">(DataHeader* header)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (header-&gt;cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> CMD_LOGIN_RESULT: &#123;</span><br><span class="line"></span><br><span class="line">LoginResult* login = (LoginResult*)header;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;socket = &quot;</span> &lt;&lt; (<span class="type">int</span>)_sock &lt;&lt; <span class="string">&quot;&gt;收到服务端消息：CMD_LOGIN_RESULT, 数据长度：&quot;</span> &lt;&lt; login-&gt;dataLength &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CMD_LOGOUT_RESULT: &#123;</span><br><span class="line">LogoutResult* logout = (LogoutResult*)header;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;socket = &quot;</span> &lt;&lt; (<span class="type">int</span>)_sock &lt;&lt; <span class="string">&quot;&gt;收到服务端消息：CMD_LOGOUT_RESULT, 数据长度：&quot;</span> &lt;&lt; logout-&gt;dataLength &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CMD_NEW_USER_JOIN: &#123;</span><br><span class="line">NewUserJoin* userJoin = (NewUserJoin*)header;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;socket = &quot;</span> &lt;&lt; (<span class="type">int</span>)_sock &lt;&lt; <span class="string">&quot;&gt;收到服务端消息：CMD_LOGOUT_RESULT, 数据长度：&quot;</span> &lt;&lt; userJoin-&gt;dataLength &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受数据 处理粘包 拆分包</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET _cSock)</span> </span>&#123;</span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="type">char</span> szRecv[<span class="number">4096</span>] = &#123;&#125;;</span><br><span class="line"><span class="comment">// 5 接收客户端数据</span></span><br><span class="line"><span class="type">int</span> nLen = <span class="built_in">recv</span>(_cSock, szRecv, <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">DataHeader* header = (DataHeader*)szRecv;</span><br><span class="line"><span class="keyword">if</span> (nLen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;socket = &quot;</span> &lt;&lt; (<span class="type">int</span>)_sock &lt;&lt; <span class="string">&quot;&gt;与服务器断开连接，任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">OnNetMsg</span>(header);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询网络数据</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsRun</span>()) &#123;</span><br><span class="line">fd_set fdReads;</span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdReads);</span><br><span class="line"><span class="built_in">FD_SET</span>(_sock, &amp;fdReads);</span><br><span class="line">timeval t = &#123; <span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">select</span>(_sock + <span class="number">1</span>, &amp;fdReads, <span class="number">0</span>, <span class="number">0</span>, &amp;t);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;socket = &quot;</span> &lt;&lt; (<span class="type">int</span>)_sock &lt;&lt; <span class="string">&quot;&gt;select任务结束1...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">Close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(_sock, &amp;fdReads)) &#123;</span><br><span class="line"><span class="built_in">FD_CLR</span>(_sock, &amp;fdReads);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">RecvData</span>(_sock)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;socket = &quot;</span> &lt;&lt; (<span class="type">int</span>)_sock &lt;&lt; <span class="string">&quot;&gt;select任务结束2...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">Close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否在工作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _sock != INVALID_SOCKET;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SendData</span><span class="params">(DataHeader* header)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">IsRun</span>() &amp;&amp; header)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">send</span>(_sock, (<span class="type">const</span> <span class="type">char</span>*)header, header-&gt;dataLength, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> SOCKET_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>封装消息头<code>MessageHeader.hpp</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MessageHeader.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MessageHeader.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _MessageHeader.hpp</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region 结构体定义</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CMD</span> &#123;</span><br><span class="line">CMD_LOGIN,</span><br><span class="line">CMD_LOGOUT,</span><br><span class="line">CMD_ERROR,</span><br><span class="line">CMD_LOGIN_RESULT,</span><br><span class="line">CMD_LOGOUT_RESULT,</span><br><span class="line">CMD_NEW_USER_JOIN</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> &#123;</span><br><span class="line"><span class="type">short</span> dataLength;</span><br><span class="line"><span class="type">short</span> cmd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader &#123;<span class="comment">//DataPackage</span></span><br><span class="line"><span class="built_in">Login</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(Login);</span><br><span class="line">cmd = CMD_LOGIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> userName[<span class="number">32</span>];</span><br><span class="line"><span class="type">char</span> PassWord[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">LoginResult</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(LoginResult);</span><br><span class="line">cmd = CMD_LOGIN_RESULT;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">Logout</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(Logout);</span><br><span class="line">cmd = CMD_LOGOUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> userName[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">LogoutResult</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(LogoutResult);</span><br><span class="line">cmd = CMD_LOGOUT_RESULT;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">NewUserJoin</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(NewUserJoin);</span><br><span class="line">cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">sock = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataPackage</span> &#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> endregion</span></span><br></pre></td></tr></table></figure><p>重构客户端代码<code>Client.cpp</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">﻿<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EasyTcpClient.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cmdThread</span><span class="params">(EasyTcpClient *client)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">char</span> cmdBuf[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">cin &gt;&gt; cmdBuf;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; cmdBuf &lt;&lt; endl;*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(cmdBuf, <span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;退出cmdThread线程&quot;</span> &lt;&lt; endl;</span><br><span class="line">client-&gt;<span class="built_in">Close</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(cmdBuf, <span class="string">&quot;login&quot;</span>)) &#123;</span><br><span class="line">Login login;</span><br><span class="line"><span class="built_in">strcpy</span>(login.userName, <span class="string">&quot;lyd&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(login.PassWord, <span class="string">&quot;lydmm&quot;</span>);</span><br><span class="line">client-&gt;<span class="built_in">SendData</span>(&amp;login);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(cmdBuf, <span class="string">&quot;logout&quot;</span>)) &#123;</span><br><span class="line">Logout logout;</span><br><span class="line"><span class="built_in">strcpy</span>(logout.userName, <span class="string">&quot;lyd&quot;</span>);</span><br><span class="line">client-&gt;<span class="built_in">SendData</span>(&amp;logout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;不支持的命令...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> Local_ip[] = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> Local_port = <span class="number">4568</span>;</span><br><span class="line">EasyTcpClient client;</span><br><span class="line">client.<span class="built_in">Connect</span>(Local_ip, Local_port);</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(cmdThread, &amp;client)</span></span>;</span><br><span class="line">t1.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> Centos_ip[] = <span class="string">&quot;192.168.88.130&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> Centos_port = <span class="number">4567</span>;</span><br><span class="line">EasyTcpClient client2;</span><br><span class="line">client2.<span class="built_in">Connect</span>(Centos_ip, Centos_port);</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(cmdThread, &amp;client2)</span></span>;</span><br><span class="line">t2.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动UI线程</span></span><br><span class="line"><span class="keyword">while</span> (client.<span class="built_in">IsRun</span>() || client2.<span class="built_in">IsRun</span>()) &#123;</span><br><span class="line">client.<span class="built_in">OnRun</span>();</span><br><span class="line">client2.<span class="built_in">OnRun</span>();</span><br><span class="line">&#125;</span><br><span class="line">client.<span class="built_in">Close</span>();</span><br><span class="line">client2.<span class="built_in">Close</span>();</span><br><span class="line"><span class="comment">//保留界面</span></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/04/28/pkibI00.png" alt="image-20240428230519330"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;封装客户端操作&lt;code&gt;EasyTcpClient.hpp&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="个人项目" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="C++socket项目" scheme="https://ruvikm.gitee.io/tags/C-socket%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>备战2026校招</title>
    <link href="https://ruvikm.gitee.io/2024/04/27/%E5%A4%87%E6%88%982026%E6%A0%A1%E6%8B%9B/"/>
    <id>https://ruvikm.gitee.io/2024/04/27/%E5%A4%87%E6%88%982026%E6%A0%A1%E6%8B%9B/</id>
    <published>2024-04-27T09:13:38.000Z</published>
    <updated>2024-04-28T15:06:47.864Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="3b9793d73b82b290e20f8c248d726f96aad294091a8caf910dae698177693778">f666a1e82130d441cf5f17739ffab4075a317a77dcaf23bc89a4de7efe3e46fd9fc0c225d48c6459f3db75904f4be4952784bf5f3518b0c714f38b191e71c538dde3d37e320351f8d7236960031ee5d83769f2b257d7efbdae9e5cfb7b80884b894813f3d99e69540821da3b283457bc5f3e3f98fd907a88c19a25cc782aace7ab92ae26341344a3c876d7fb9c05f35b33c9d24ce824858203e66c674cdb8c090fe8519232ac8626ba938607c7d0e536a061249cdfe8827d1bd12ed397ba1ce003355efb532a1324f31a186e6401e3508a7289065ad0abc1cdc5d7a8fd0cc5e28d0221f2b7e87aaaabb0d3371cd1b8429e64e669e21dc8149c5001fe18667c824aad9ed09de0a15183b328829c43565bc21931ade4d928967bbb380d180dbfd614c1fce594c961ab93d2faee6e88b01a04616b882fa1e227bba57f37a3ec492704e959518edb5b04476ec4cc0f7f50f3e07ad2a601172087dd140b7b34e9fbd72fa669acdb57133c202a99255ba9e53f8aace3500ecaf46c8be036823d02be6d41ec649c13a3b08301ee52ede9cf55d88e365641a82cfef0412a55599fa0537f9be53efcde9f974253eacc468de17b775a284a45c09cbcd68a7952576df5b1992f36072fc1545a2c85df5ebde3800a190294a85493a220ffe95e4d7f37f500e985ccd7169f2ccbc254fe4f44b7b60c2d57e040966c2884c8f2a46fb833cdad0e8c2d508c9dcd190e32bfbcf3ff1ec9d3cb69d930d195ca4d77da7ac6e45ec5c5d6280cbfeb6224ff21720b6431c34b4537d446d11bd7190aa6f0bcc971de0317e7752baeac263d3a44b15e1256d272b90e719440c8b30cc2d88ef9e3a1e8ba089d6abdd05d6495a2d00c26c8c9c2fd25c3a8f0a80ad1a454060bb0c3c796926eea7a8b86cd266fb47030c27d29f60331898f59c7b91abe46396d089aeaf2d9f6c30cb77b7bdcb17f236e0c8dbc5a804f2beaf7b28447be4e71585464ad073b3c2a1fadb0919e582cd1be0479390f14f9f62e38e4cadabaa6ac8bb77604c233887f780992e3c5bb2b291904a45551ecac804e854d3229a515a983092935aa1fa61914ea3cd1e98972cbc46b446416c9efa52778c94949bc89d140ac7e72fbe0510389d3eb4e7ce485dcff6ff5db78621b9736994a0145b7e30eecb0d772206f36f13f26dce32afb780b5ffc05f839a68194d81c0c0d17bf55384687fab19a7d6989d59ed14aac2e74c58b78b00e0b48e2776e5bae4a53643053ebe5dcd35153f94a442c167cdc23c90976c4d4c57bb8f9a3663f8c22a537dae72276ee01a8aed7220e5e0960f3318f527a3a416614b00e17c55c4948e39770189cc0a4f79c8613e1ca28b26021f69533fa1651e02b9c7c4bd0c3d98351046f7d68413647b5be3e8c7f3d2119a799f4db78ad9f2b2e4b2e104e625d1a423adbed5dd2e607d075d785d9b82978711cc10dad9b87c0c3a35cae8d9682531a0837488673ea887668451e21bc33458d761715b81390ef9339a9097096beeac710e95176ae5606cd85c45a76fb84775998b39e1a227b415777b6f3f0306a32658a91fb12c9b79180e2d37154b16a27fdcf42fe18256ff5c0402709e34832bbcda71b95d2ed207aa6cee950a71056f1e9816a4dd723d1276ab8911463d262fade38bb4671254d94335dd64b0be549d728fe0e7e8fa6a3f9c0ce255e6b22fa328e47668191f7d294bba415a70c89d61e6629bdabacf39a44c3cb4e054d5372f6b76a29542de7c18d852633caa0d10b55f4ac10ad8b407beabd44caee2b256f20b8d05625457b3eb06dd92ce232628f1228bd15a0f9eda1d0d4e0b71c92c4f2a3725681bc6a05f39718759d2a1a8c9f1f1b415bbd991e9ebe34dbd92842e5f3381204bcddd1c32cfdeb1dfdd0c3b2194604eaa5427711eff818ecbaff73458b4d5020884ce3cc9a3f8bdafee184093dcb885068d1435337e93f160de621cf9027c3915166354bb4b3e953505280ee2b577bcc9a17d99b4659bfac1a0c290fcb615fb0d6eb9048bea026bea55f9698b910a134e51abd7afb8d6378b98170facd9948e24858bcb0467c65f29b88f0d0c1f353f4c030ed589b9a02182e87523fbde031c06cb84f1bd4450a90cd9ae5c2cafdb2fff3a577c61c61291d8537d27710e41d9231c797ab04b00b07ec1d7ec493906f02548cd626ca553a5278b9686cd106a3f2dcbfd3e047aa510073cef2307bb6f204b6f876b84ce9375ad5951b926579b1159b39984cc03bd9511129fa0e0ca8ab5413bcecb46abb6ee9c4e307728ced56b6f1a3be062ca0245c811c04961dfd1a427355f10b1554e791cdc4b806ea84e56799084540e26aa727a99d67c625901bda66ced1b8b25d4de92ff57ae7a56260206f720476555134a310128181a0b4f0cee4ada63a5cda31a4f97309d0a1081484550ade1983a1f411911aacf3a30b32b9b70f5b72a6e8e15c4bae1f9e272c3f4064df21e64f1b9a072a390bd8d184bf45fa337e11b1bfabcf6e5b8ef2bb9e94b65490b3b856458a0b791015d683ee0ddc19395baa654c5850cd5863bbbd417c250f6dddce3a2032dc8c9cafd6410d93504da26e458fa4d309ee7f0b251a87ef724cd8d601cd97f7837da90f9358862af94da959e0dc7f7a3d3bf52ab6213439863e26832cc8013e276e18d9ad3dca11278c1bc6d13f036cb31bd75b84ffa7d873dd0c36a5c90bda94c00f625274b50262260c7bca15278114f527550b51762b6924d2235973654ba73e90a708cf4adb0dac0cc8d51f19a86a6d8c13ebeee090b5aed20129048f187e3f49d3f51b32372a6223c0d52707d0f4c809016a5ab8778a5ed6f05c0f05e4f439ddcdadab57bc4c58f1c608c268156b7a2e4e4060a45e93e89df0d15d705fd6740aa857fb38b6c341fa65ff92d8969f68363d16cfde59480ae9d5d9db26b00eace0f03787017b8abf5cb5035e3fe6965efd674603dc9d59feee4ad462af33219838706cd31fa82aaf75e3a140f256185a6b7025356b0a2b78412e20ab90856696a4399523b09482659f67b55b75d078ecad689b0640088a85514cb491de86c607b989f78880014b16c0978f124bef5ca3f40e613621e73837ca82d89ae4249615b34c3c9a3edc87719ae00afe11071b6a10fb5b795e447307dc351b9a31d8273dc4e93d732aa7f60967829db1230bd2fee8684141d20a056c5f53b50049d4f3892e08c395c20d1e6e1b2e6078f35d3f19240b45ca3fc1132d3693d71062f158ec475bbd2a27b3be0986a4d163f7c77b38bbdedd63ac9d9c4065fd7cf34b5b943e4be1a53d2f2dfb13fce0e85df8e3f033a1698f744af2bc5037f05f5ef0d747cbc9c24e401420160d43a17aae273f715d42b56ec3b7f3bef903a8bf276e9917315c08f33f034c02ac1a9607d5de2ffe305d0764feec24c68df9bbc5bbe55065df91be333ac6c02e93ce3987d838a692b9b97dad4f5fec08f4f40f37c18ce4cde3e54bee5c6556b9aa1512481e41bd15ec7572554130ded873ffb00b4b9a4584750c71905f29b160f877f3adaed002c4c7a03779edbb0f766d509c70e209123977f9eeb687cee496cb9d4a4a6c665e3e0b3d9d0aa7a0a93205498b77aa8a27346b590d5841ba9f61561df8fcf756fb2cf38273cb48af59229366d8f3fca18e1ce482b111ed3672d73724f6bac0b3cb58096663f713f2961a30adc57c648207c41d59e5d626648798fe81d45cf86d0f84455fd5bb2caac09b1646a3e8854b8f15153d496bcc5f22a83b0d34588b717049e2f412de39f3cbfe22352595dcadfdb5323f9c4cabfdf60f4541d7eba0bb2cda5fc903ee897789ff5c13ecab4db2aff14eda901010c49623163b91268283d77497026c76adb28d99925b77c38211ab56b79d3eda864cf77badfbdb20a11272ee2f7804f17a45ee452b8889125e55f011a6551d710fe3750252da46463ddae1006c6a07659fd997bccc4734cc461442a6ff60c02d50425c47d37b0e39b2ee09e575b4bd5fe30b1bbe0cabea3c223a5f0d4b681a314d56a8e1c380b4a05fdc87b4720c383feb6eda2027c3b67d1cba1e264e7170361626dbc5557b87125bf96ab09d746230b17a006a698eeef50e05ec5f169a52dc5e2ed7c24794699c2fbba75f87d84dc34580d2952930e63050d817baa1bc380a5041dc7e88efd4f5e5381db93d9a2d0e8cdbdafa576a31bba2f95ae1ac7fbb12923564cf8907585641ce0807e60be9b6f01cd2f202ba4ca5d93787f20213b05ad0babc4b8991163aa4fba7750f5e28ac2974283b2a4dccba8c1e1da27e713f56fdd67b5dbd06d1a499fcf270477b775e56f91c26a1fb63793fe5331e64af0e9d9dd731cb0784f6517456ef6a0c90a2aec6812e3ec98f7d6ba4061a2770a3dbde114e564262f8bbd449824646847bd0b7415479c4b9c8cf601a68b631630b95cbc973c92862f3a24b57c8294a7484e70be8b213dbbc578240bae07726741c5adf3e91260e30bc98634fe840517072114f088e5f9521b27a5ed395fa34ef27080a488a14810ccd0229b149067d4131a12e78253253ebb8e79d98a8b5f0d32104adfc15a325c492dfcaadfe114a234cfc5a1443a79f3855a0767b210ad578fb5bc54847b4e05d30428ab512fd13bf88d3af80e407e940ccb3583019b780cc0ae00348cb6cc7544663ab666d9e3e4b5dfe1eae19aec53991c72677418f7eb5b8c01efd92b0a37ad0baca1c5e31d61075456d439c85234f74c9a479b4fbb47e777d82c237f07a747b7b1184b695b17ac939055c89e1ff24d3f9201ca4481e7a4936f7550503402ac2fa18c802b5a6cdf1cbd0e0ecad41727e4c989927cea8a8ecb679a1831f5498c259be80cb1b00734458136b777cbcaaf49a961fb6ae29473a1cab65d5b2d2a363168f44fa954f66599b993380a8bd7205661187e52df1da7d8cc1f14fb1d4ea783fa6a34ac6881d79c7788e0565f2798fa3ebb0f2629d8a7cbb6e178a7b505218e4bb0f8f51111b410c96d516a83f1cb6a4210b2fc3e2ee3ad3e76531c67240ff962481ee585a5635aadb8036baf65659838fa5e715b0e0e203a2cf2bc2ddb0b4c7e5a8cb4b5a7c5c5c96a5a8a77382a218942e56cbd46a7051c4c2954ff28983b91beb3f636d1426112da24d5a23e75f9aaba712d1e453a4bef56f60375e4f75bdb8b60eb2e9725eb39eb65d0aff7be7aa9a222cdcbf900ebbb4caf772cf9b574ea475a04d3c9564d7c5aa3d98a95930be0a4cf5ced4bc4e29d182435520291c9285c644f8d9839303ea4f9f83cf8c05b034ec813a3325c14e532b753612362c4dab47a1c221b916f8aed5c5b6285d280d1f6e42ea0cdf9f89651de49dac4819714b3ccc153411f9980ef3af1da0942f5fb7fcbe75a6351fcde0bac3b3c1f95b55100e31690851852b81243bbd89eda0b6c9dc1a3f558a68af2c12c8e0a49b35ecf7d8fc3c7fb9f66661c2b2bdadbe3b72fb568fa81d5d7e699acf598eb881b90d642f3612dac262ebd807f1ca649c97c5996d9a89eb415b7eac082f44efd7e45b17d344cae050d82cd0841bebd8c08c7d6a0c7d39f22364fa8b94c93d16528bebdb8dcffcb6fc70d12d7fc61b97d7c503730f40d1f128386d8c457b68b58285e2ed78e96351563315b63dc541282f90a5fdfb139bb131b689a210494d3dd63cec030a6e09db651873fe15117d224340d147c23f1e5f40582c37d2a75453485b9a269bc64573e57bcec349b2f3073efc9d0a706f7618124de900b0f99ff37801a5bc632078feae4f7debb4bf890720fc7ad6ecaa2d852c245bbc70cb3e89269371796d46e48561ff484c675c0ac7fc38851e1e7a56c3698613ddd202746c50b62bc16f9ee6efb42eebd4f2ae0724800d7492c6663b7c40cc941cc3982e7e3d7211f40776549242b3f9730011359ab2963d08d22f01cc3000853aa4d6038a92b9aed9788c104b1b3a3e3f14317a03c7c19468226bc526eb5d8a7e553b5ac5e344f7f86cb85d383750d199438916f0c4c15723572b11ba8a20000b0289b671a7aa32940c6cf88f44ecbdcb820be8d05b385f25694a9055a5f73755af926051e7faded6f35b0bb78da863cdf003f7aa1f571c7656baf07ca21a09ca22b44693d625a0e2a422ec9acf46a96c4272ff3482fc5b34b2d2adc9462530abc62d14d301dc2f834c3fb516b590a553d334090f4ac79a699d2958c749a81548e7b557b9b01c7f0e15f18fc851beffc0ff54de8113d0635142104b0bd9e565c3a8b9fc4e291e4234c40353ba8a18ad7825114a58730311f37be50012cefa80e84fe534ba03c90c7e5cab24d38fafafd05cf1a7db0ca78b9c163872dfc50d3a32cd7b1830d01047657f8e5e1d5327c767c4700b7d2f9289b329b39daca7b3c810921b2cd5de0593ed53e60d2244c8f58264660bccfec8a61ba316e9f9f50ada7cd2ecf2ae9d68e6a2246bd777424a7f3766ef5844ce6f389e5111a3457a360f1b9beb1aed9a66a48af8b2195431db25ec12e60c5190dbabec1a0373c651f7270b7e4d6868cf290a45bfe5097fc9f509fc8afc32f89ac2e7282209dfe70072d7ba3eac405b3a6eec96e695c05a9ddb73d33e72d2dc414f5c372f76a3292cbfa2d6d0398592ac84337a0e16ecf4dcd8f0a5806c632a97a67579d757c2e60a428058047e743c54edeecea349fe5fd78253bf1dd287e14931e0906d7811aeacbc49ecf09a212ed1f9ebe4c3072d4af9253b79a8771c303e30da72473bd5fd48c7bc65ae36ab4056d8e7284f732e835bfbf09282660d4cb6e3e55904d0a972c6d003a8cddd7b0a437e01a74505af961d16784533badc4ddc88dbade176b94fe5b07ae232e14366f7887905ce523ce241410f7c7142c1ddbaf341c86d64165ba6bab72f172c4b6c47ea74a484201e3cb2de8af24009f4abbb0bd4dfd579835e5e0e98f296ff39c314da8f0cdca4374fe04baee569fbccf127dbe2d21fe67e7d7725df07409542848c011d52efe94c947ddfe79a6f5bbe96987070b89d88896a1acdddae430221671d3b15c4b1aa414d17cf2cc00bc4e9368ab1dc590befc02d9f9f97c60895d348f108c3613ab68ecc631a9b85e504af601f31dfca7ebb44ebfc43291af3569c0ed7bfe5036121e790dac30ad8a5fb32d571bb4162976753a62cfacefe9506052b36a8f1ae3bdaa0f92f73f42603fead8901a4da2de00bbc9b7f475c9e1d4bd48b5d0ed556a1eee43863337db3c4d7ea6e88724610c392c6338ffdd399f5ff1e2ca68f575e8b94610d79a81b513ab676d4b6731ccacd0d921a4d7ac7ade98b7ed08d56eb8da57275e0a2c318ea20421094360f3db376a3090847caad70e98bc8ce4df75c5a070e15c42e4d07bd2939243c42b834db23c55e7f38041a0faeb5e6e839a01cafb4104bb4e27dcaba2a2c87fc33fa932c0b6870b73383854911576e354a44c077936c50d3047e4b7b7ebddb341b54a08c603f8dd7a971e957e2d9bf50e86c9f500eafea393dd994bf3553d89adf8e1bf0a793dd6f3ec43a66521860e490b8bed3f14f6e661295ee41fd97f3ddccc280638d2cccb3ffa2afec94598f27945d74bbf0d8bca5d2aa031f678a66717d71049d5a3b5d2434f4e10d9f6af90c618ad2c1ad75f1f7cbdc6996954ef5bb0ebe73abbca76caa66d97a481bbda8b29a095e828ae3b838ab59e1ed564944bc8c3344dfddf4475dd18aff827442119665ab845a9ef28bcedbb7e2dad93392b05a879019336decd4ec59655591ffd5cb4d6748ace4a027d407cba0597abc9296cde79334c1c9f95b46fc94d1fc89fa0b966650574b5e0e88d6fdcad291aeb39d6b7c72cce64181e926220ead8c3494c2e483a6c2ddeb8b2ad25aeb7e08fa6b0680d98d49579fcc85ed8821314c46d446124f783695a977b63fe2d1dfb221e8fc400d47e99b82c9832b272b2aa1823ad3d3c71d305c7048ee543374e47d2be705509af557919fcd9c236abd541a86eb12c26fb37b1064a3d9f8944abab0c5c8acda725face0346eccbd1797770efbcb5a334634b06855a08310f10057a121d84515272e4f6a7838ee59faef820b5f17acad44ccd0c50f6e4d3fdca9aedff3e50d2530c2899c134f5f9944078527dcba99add27b0a81cc359d088ccae1dd7ec39c31b39f236b4817b3d9464aa972bda5f44272bf23c3f6a6643665381ac0a035b6b18e88fbf83042aa17aa1574a38d0c0be2325e60e28e7535757695939a783362fdd13d3f01bee9c477527a4796fdd514ea7368702c5169084430315498664771759bd1a0b71f977d8101a0276b6ee2a50a137562b7246a0588a063918cc949a80b6cf8abeabec00d44adfb68426e0cad15f81fffbc2973e7b77b9d18a40c7c85fe1d28360ed59006f196943100418460f286df95bf124da84d4fbdf156246eceba8d0ebfd99402b885e9659bc349e2d2a35e333cb89896adc50e0778ab388a6474af534cdb603eb4921645c1596b1fd69bc6e2dbcc08f5869a4910915d98780ed6cccef9d9cf42ad4fc16e48c9e651840984b7489b0992decd837b652b456e77ca060ba2b556caa59fc2a56ce57fe671d8ed2d1e271e856fff5ec84058fb23e427b95dd331bcbbd27cbbeaae869f132e988721fafe7b8d4830610c3c06d0716f56f31d65ba4091bada68c217f67064361ad105c293fd3ac3274ec1a964e6e079b036dfbb71864d51b1a1e740ebc30b4653ae9b6ea9983e98fae57a0ee84083fda09fd431610f42d174768da6865e66fabb67b7f1289451139cb6b58f9038683954d0bd16be75764f45ad4ad8660b7206a28bcfc88d0c460980f5f5eece9ccc3ecaf978439a92cc0d365b7b74b9a88aba9a6a2167c81caaecd4731d144dbb234be178f4735255acba5999f4ff4b335a61ce122fa9a1c4ce0a7ef4fa7b8024422579a61b2ad3a730dba702b22d0ffe6cd905e203055341bbf244a7fcda4f9c69c74c26d37a54a73f86c1a3e674afdf0b1de087fcecffdafcc96ab8915572c629663089531e47fc4450ba29f5f88b3e2b7ca5f5191945c08fd9b141b0cd7cef8111259699b4db2e5cb4ba2d654c51ed98a4f1812cfd13f5a6dc7cc364ad41dcedd455ae5df272744b26643276e987c6b0496c4dc0cc9c6336da88f523595d54a8c55b42c467406c13946a1346bf0984688e491681b7a76ed9bed2cde85b303d280e6db73e72004d152f091d77ae40574732a73469ac9f9ecc99bfaf784957418b6d7140ca06d26d3e91c2b5aeb4bfdc32b9b939524a535c543ff617b8d2a1a15b626283855d89bb357ec29c3649679e39fe566ab8cd9a649df421d92ccc1ce01c2ec8c29263168dad80621701b06936a3734ae027f6e8508774ae5d4512f29ae39c4397f52799ed61610b66441086f27eaf204cd046dfc7169864312365d2e5a885bdc8e3dcad754a9246464689a1f9807e8eaa179554074d956dfa0247fbcb31c0f3422158899d468561f2b70d9175c9e5947941d9953aad83df95116efa0317ec77f7c405cff6a161e1ba761e861bb130c9ba16319ba2bcbd606e30dc91c4101aa38ad8be200b7870b7e377e7221f31750a3b402fba1e11b1ce83a02984aaedaed79f05e0b238416a85c6dfb46f87e2ba5c38c294b53404adbc6c975bda74d1decd36c285e22db26726e3d53002b427657832d965210ce7cb8db61dd4450638bc1ad9db66cdadb334cb608fbda973c83d48f09009c5a73a16d0b406ee4b34173c7732e73e60a7b6d357ec3298ee5319abe19d150013e7e1f6d480d609ef9e900a6468007d6982ba275eb4ea811217a91c8edf75540d382292a90738e2549cb3fce22e6d8b14b110b12abe3b75415cbf272cc5d8fefd08349ec9b50060357e624cbb5908a3815d2d3b67d984633559f44cf3a8953b574910432a2c847972e9d4df96f2987dbe35871e411e8b60d6c35fa6be98d6b9cc5eaee2e2986956abe06df2d6d74c79ceea3abcb919234f0ef5e21a9dcc0b463dd20b6e4c317f58b5c607a08167d3343a6edf8457e41c114db8b9f6f4579d05e08eb04093be2f2fb3efdf897acb652d47e7722c24f2aa790120602ca6caffc778e9f2f28337c78ce651040e09626dc84e63cd63fc15fcc2135e09697ceb492e098911a8daff8eb03f114abff622b79283ca6c4c9dd106142f01492301f19531f55632f967fb6c1625f248c71c9a3466d1fc2f0a21039399d8e324e29055b076a7a0844b521a1ce787f111cffb354c337775920754f2a1d9515f17d3bd2fab5a5f8da00b1d73e1426797262ea1762b3af89df4ef667cb0efd943e2f2eee6420697dba4bf32e6dee1d774b24b7728531e0119cb0d0ee0c3a965d36a9f720a55c03f1355745c8010e58c1b786b2f35cf8a25af2b62795f46b9d27b267aab08ff9f463f0a640a86a4ae8cd68640720a5fa6d5a65d046685d973ac70b9c3a9cdf39fd0d48b3dbede35f24fd832027657bffc6cbfc7ce1fab741636eca1021749452de6c886be197d02dad0c944f34f43be8866ae840e7735b3e1322143859f5fb673529514ef02dec2b1fd6237328fad70e4e7259002d6e99d9a95dced00d7e68559fd2295bf7df1ecd12ef5478f579a4119c90c3e51e1bde14ef823d30ac96edf0580e6119f5074a13836b2f1cdbb5d2bf07d99ea05a905ace2978c4b9861000894da6bef7a51fbc16cc5d9e720a75df984c616b95f6094522e8ba0154b39d5fe3540e14e0292852730050874849ade55a5fa8d820f5f1259c23f383aac24afe342f897186d2cc725df5e5521e62d8c00ef4ac27985af203fe5cb08d1d708f8f2c8bfc7b95d1388b38c759c220c97b70e7db033b93994716eff25a034a9378ad1f644523e1cd8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="人生规划" scheme="https://ruvikm.gitee.io/categories/%E4%BA%BA%E7%94%9F%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>实习规划</title>
    <link href="https://ruvikm.gitee.io/2024/04/27/%E5%AE%9E%E4%B9%A0%E8%A7%84%E5%88%92/"/>
    <id>https://ruvikm.gitee.io/2024/04/27/%E5%AE%9E%E4%B9%A0%E8%A7%84%E5%88%92/</id>
    <published>2024-04-27T08:57:02.000Z</published>
    <updated>2024-04-27T10:51:53.316Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="6c3c453af3bdd54753d6502ff1a75d5bcb20a0fbd4fd2f9883eacea165c02326">f666a1e82130d441cf5f17739ffab407d3700cc5340db38aca8cc539ab20da66955efd2229a88f228c2b043e435c632234ba58b9599b5db4b315db24ea1b712ffda270aa7ecfeb9bb15204a9e2b665faa99d7dc1f44755898b8a4c13ef5c4e75693ff484b9043ddbf7e02452aa852453a1f2169c2e78244c91f9cedc486857f58ddebe03739017a0f0c8fad7829e6c863ad8de560ae7df1b4c3021031958502fbd651fe5815aaabc24e907a929795c4cc6aa6eb605c57f320585bc5f219625ad8530e074ccd933d19870b1bdfa1467c5fbf33a97f221a58b62387520c75882ee34f7e690b3ccec362968080bb4ecc7cb9b5a1bafcc33d7ab4eafb2a10e7c1778d8ea3533b9950a89ef536912202a357ce2e072b2b506317d66fcd16da30fcd87fbc0edbb024941f7a8380396bced2240b475c4427508876650eba8d00fd37da9dfad6ed5f01fa4fe0f2307421d01166d99dab9bdee0762d8c6a098f5562149d2f15452c3ea62f8878c4532cd504ae42ae8d1cb84d61e5c72428f30cc65623d2a87bbe0538162ed46374407381efd5302c80883113b7da2d20cf8c5ae63217a28438c22d5caa540c4ba41673fed7060520746472c3a2b8144984bff025db8b4899edfd0b0351d156b6510f8ddb0cd165a9dfc76b2882c07576f8374ad8eaa7e6780ee5d27ba29b237f0ee0227face9e6dc28239c9776cc5b4f1bb2303988dfe685117e7398dc531721f653f1c68209e8d1149c59fadaa530c9ed4ab00e37f5682a81ee3fcca8fe4ef8ad2d46d79c4d88df1a1d8fa7b29a8b257ce9665c3d582d2cb449a717d82788e2f00fb96a1fb24a277c0fddf331c13be24aac49cbcb4c00b8784ade7c0b847b519767eba7992ff4885ff87d0706ea42fcbfb82534a8b1afce4ba3733f92f96c5a6bec26cef9086acd289280e958155b740ec413e5ecfa65e0d9a95dd31c115943a1e8c0da8c45cca9e0862aa44d0fe3cc8eb28cbe972096a3297384fb3ae1e0a56a91260f3a4410e7d417784d425bb7fe803bc7ebd73b4f93205cd4ca02a4742604fa85d6f47966372808ff9f9f29156737989aaaefbde90d9c1d9902c898d11b93f9bc3a9af60c172ae29d29b046f994d8b297c0a6427aa9347988003aa69d6e9a61983ac9a7807cd5390b7afa16c61d8ab3f940629af963d3530deea92c448c60a40f73e5dd967b06bacf6ecf86c238c23cf0a07b222ab9b12ff3b39341b9f78e30fe703ec5e087dd2511ffcd77deba839cf22fbd139be374a10c3fb2c2a2dca5335859d39c7d051b01dda3280122f481621d5d464206ac66a6ff10f2eb24f473ab5df37b4ee05ef2c071eea001842ac1e6620f4f67f1ccd3486bb234122ab2f4b9772c3e11e3bf8f94bf454a0f32c0f3fd8e3db9ba8e6b9dfe56e6d9b323125eb205b94d417b4aba9ed1c868ad172e77f55e2d870eb789d4e180afff26b50f3d2b0c98fa30cd7b835481752f1f1aaa53fc66a5cd42e3fc5e0d5883222901b1ab3bc4e3dab2ef372ed7e284aa0adbebf9f32adeb8935390ca6676975a6a02c227467c0ab81b1d283eac675d84edc76118c35fd0a7690d2b410b9111a8bc80b16bbfbba02de3865c664e62e6938e4c54027eabef841d5d6986549a94ca162349452a59e30a5b15fece75637f1bbb13d81b33f4ec2cf6b62df7075710c352ef8f0b07d5dc01ffb972d0ed9e9ee02ff552e626b5aa343a811b6f3ad852f7642d6b9b798376ee54fe624588c69806af9fb6eb6da06b9a63535bbc5e87da5c410da69fce880601859156a49f62ae78929895b3463f7adb05eee87174f225e5ccee0669cec8230a5bda3fc9e995384d59a4cae7478cb363fd58d8abd6dc4674576c04e06d654bb5c646a6b8e17c6c32b3b79b69954ebd590cab988cff6a31f4b33c6877a341c71e55d08899dec556f7d0f0b6695ae73fab63706e0fde7dccc18351b52f88804909a14ba4efee5285176ce44b9b311a674de6168ecc0637a7bd89edc130998c5ff2064820fe6c47aff2988c6d591e99148c07ab78f94a1fb51ef6f593942aeee26b4e2817db45589186c9b4d9b17eb4ff4cce554833fa5b70789a9210016c5e0f32944e6b4ddb0cb84bfe87e1b3433ca7cf171e7cc3160eb95f59ad52bcce1e0775e35f5fa2d113f7b89b5f3e47e5886d958aedf149a9d2505249f75c820fd2caff7e6fa06af0a905e865b5243be832dd6a4bc2899747cce9c47c6574e5c15c5d1a88d21a086d1419b73f8365b98b52cc0b92eee1a095b6b0231408ebe75aa812a1e387720d50429af6a1375091c8366c9e9d2d3a29e50d65188d05102de9a869d28fd669e7713c0dafc6b899574c261d6595598fbbcc919a8c2e9e464b41f03b1aefb6717038e2eeed28ab1fecca91698e996bb092ece37f3d5681fd128910361229c756226d276f01038cabcc6f84c5886327a3e2baa35d3e2be6bdb4a8d8ee4b28f2598320f0e7e3f319d6612edb7f1afca4c89c7fd7eee258bb32ef190998869a56908d7f45af017221acef55ac64da8307194be63a33450219c9b2a9d565ba92b31ca71e315733cdfb96cc27d7e5038c939ea718e4dd7c3b031f384a8d6bda43207d2f28f3440257684e506604b6b908d2faf0f2afbbc1a3204c321bfbf4bafccdaab807de234af243421a86a84b478f72224bed5b79ba310d1cebb83e9cc2a0be2baff70501221100a6ce90978774d1fcba35f1d0fc1b197fc227b9207a9a9155666e83be5596147de79f11374fd802ebfa01bb3b75671fa04715923a3cb0ae59a5d5d75c6c4936c26a88fcf7cdfff22b35f0587da6000f8fb536a3fdeefe2af7f578e20eabc54896d8e41c5334cd30ce4d70e8e76dd2aaf3110a7803a70e03496574aa6b96f4b110b6cbce1f483a31de8c5b120234bc3aa4d73a4c74f254fe63b8d6238d73179b12adbf200f4a2fdeff0f308d8c9b034fb66193e7afd24fd2592f8e7d6b69985e45a65b97881f17248451984c28e622bf32d35d094f227cd5aea914f614f18e3c038de52e16c3bfca911feec1faf29ead8f1f80ba79e75320ddd3609b6dde2bd4fc85bc62f6178447ce81fcecb9847f35157b6c31af5154e0c39e0a3c4cf9cedb1b3b1b865ebd0ba0c0433a475f48c029dd5bf44b166a60d11891455a8689b0ce86440c393b7c0494e95eaaaa59dd890a56d6dd2e67dc088e9de804eaf43c652ff1ed239cb6af66debecaa31d9ae4c380134bc7da84caa0a9f09256f5caec248d705d6daae27e1b6ffd5ccd93811cdd8039534c463945fbc0b1c35883d0f3c2c81fa5a1370f5d4f76bf3f5ddd82a111edd950dcf7e96ebf855ea7eaf80df80e2ad3fdda8bca36c50dcaf63fbbd4eee907d614ef9a6a7c81c7a5e444d40f2af97110ab8da8f9894b71db4fba3b7ba4f989f7edf4f4cfa81e6155bc8da4625b7a5c9067409418defd9ee2feb0b6ac1026c2c00bcc98904fe647e8d466c8315e0d8980ba67d13ef61f4aa1d555c7966afe5e47ac1581c3d392745fd801d5b9ac5657880e6be88d82c78e58b2366a9142900ae4fbbdb8ba631c6d1e8412350219672a44af30a34efc63aa2eade25207aa9d9a5c43b19295be6b055da0d4d322b81e1dc6167369fedfd255063b94b2a1bd5ca090d9b5d031abc9eebce22029a77830740c27ba0797ec8cba9b42f2f5ec9545792db62cfaa07e9c865ee24714a534c2a3b44557fdfe35f6874681d75c6888d6ba0abd3be6b4dc0250d5b8c5754e3cd7b0efb735ebe047b18c6a99f820e2d77de752c89d8e25520fa9deb154068fab5d8fb9a22ce44d2566451fecf5c0e5b5ce4f639668e800523a3eb614c29216367299fdd317342570865ce9cb022ac35ac60097faad86e6c556611954c614edd774193e8f747ca7268a304edab2007f5a6baaff51d50b9c8fb00aea1870bd8cbddf14e7155854c3869a6557a810f2f2957881a11b1b6282f988de28055276141bbf6ef08109500b607ed9338435fe1510afd2cc3b85b1b8bc12eb1e275254f93fdb93b3da61b41cfe44a73b406697108b9304c08a732e37fd3a3010c998305803e76d85393c81141faf1b992255b3d6d3bded0266b399d6f70eb68d91b408d72e33b76a1d9ac36da5ccedc10c58a23a9418ed8c32d8c04694f52ee21ba52c25a142197cdea21dd537edb1cb980a5487f17ed561a74253e6f8ffdac35684846f2f923fcd35c7e806a682662b55b77d810af1f90fd7c9b896d8b343829af6bd8601fd4429222e78fe6043f52d067f62e5b507c472466540f2f555a1db9b91125582f84f552d5916d131eb292e987c1847b8c40d56da1dabe181996c8559ec777664c5324c0b35e2a0d62df99e4a07f9abbb5422c148aaecd430216836606f45f5ed8a60b63171c4a8fc7f22efa413d4eaefa48fefb57ee1457fc257410fa81b66f0475398711664f5da4481f2941ceeda92e54b881e4f0d35279250bd69437b2bca99aa125c4bc908d1adc1db553a4ec3d8b63b35d97e2bb949028c9a255f8cdfc6f0608dd1ebb21fed4ae76b29685a8b68e519a41173aec35f91814ac5490740de12c021af65bdbb40b108e4772389fc23cbcf0a1976f12b1bae8fc7e7e89899d8685639aeb61f3385c2d041d3eb24ca0ed933b8b4b4eac2a3838b668220d523f68258954738043bf9fb211ef2bf6f79005f8eb00cddb0716ef58fc24ab78675c67c2f21eea613919f1c09f775bb1892932cb9a320624607bc23e9dfb32baca95f3b09b6559bbf1269c8dc2ab509e326eb7fa49bc391bb606efb9e29600cf375ecb2f85746cb8b3b168ade323d954caf71ffbe489baed6506652b291514c304473903e61575c11e6bb6e264a3cfdef8f0530f85b28c60662b7042e4f2f2a1e4ecb166d36cd553d038ba74be3f94061ec89e8265c364a93a07c285953492b542990fa81ff0eee360f3c9a6ada7fd716da6d4869576c611dfdb83db0c27a068f6e057a8286c63553f1633ab60637094b9e039d15b0f28731e377d603534602e09b7bd34f654e0360106ce346be7c3c4c233d17c8109ba052cc00eea5de7dd6c425ce85f74290599149903a01d3b46f8e776207a6037707cf18cef5050bb5523dbd4a9525bff5ce5297150116036bf72285b10d20fd952b5c4d89c7b6dbd8d99951a7a1a7f896eca9b5b8ec1d41c091f27d05d831bfa89915648bfa3186651c8bf4d5036468e0ad4458a2a871ed6e0892ef5dcc37f11e863abd560c9f7f8758db5948300759ba90bfbd6cd758b45213d5149e206b68d1d765ff7b19540ea2a0698ecc9fa8eefe72666b3927bbdf3a3fb584d3dd2e54e6325ca0969071d9897e39323a6843934d9981681cab677e42c16c933b26a3d60267d46fe82d6301e4e0767f6992679b7282ac314b81afe0b3c682ec4433d26ea47383de792e89c9917e67e23059139acc5938ce51d8fa5b5b9059ab76f99e08ebce01c00b0259f1406c981e0e543e4006d88468cfc65e3f71d8b147b987793b3515c6e9dbd6c99a836b4881761df98e0c2e6ad9a1e8dba049b2f98d5d842ff33f986688df49e21bbce1de5c7dc591f519e37b838311aff187c2527372cca44d21cda24ccac40612b37c45ae00c6cff0c0fe54c8bdf7bf7c30d101b4b7690b7207198e25b24059f3bf65d4ac9eebc8b77301f71e42fdd63fef374f907b82fe644cb19e452e02bff5749df06352be375285472312fddc14790292d25ea0ae02b4bdf2568afc32e415bdff4d56672c6b4a4c8f708d6f600dd7249272d08ca56a35555d1be0675ed68a4ccade4ea80d59e3b41d1423243bfd735122f209df0c908817e2e5aa39d0dc969314e381e49437da117119c649735e9377b3fe62f82f3480b69418bbe093b9be66c40434ae6cd8221eae5bcf063cdc83912293992b673113716cffa46eefb4dfc2d912f7e104a6259835ddb725a3cd40b34795a848e9617c4cbc2b86318fc8c9ea02a2859fbfd4a6263fd91e05d30d0f8db4b723c24cdb1866b7cbf6de61b8ddfd24b92392a6be3a8a162c61ad8c097cddd59266d9308d5ed774b21626cf8483817a600be0238600132b5eae4d8c138d2e317189722a5ac7cdf7268889b3fbb03f77381aca94795c155d5788030c6b9af44312f190bfc4f2cb7831f5da04e5e247ba48ebedd1a31a645a00855a46a7339a502e8b8b48e549b3df973002dff3cbeb744fc2befffe28c42c0c6fa5d41f740e3c3f867a45c3db4badee34c74eba278b63c16203bb4c6f839743b1a5442e1df3534c9bab812123b3b25106cb93b3f1f55a8bbb1142d3c4c8172228be277fb897ed9aaee1f4017e1ed902c4ccd0a4b8586b3f642e9ee1abe1bf69bba21916b774fb05bc8ea26a1ee82a3ab38645ca4e1e91b708e1023cb84c7d203a818dd6a265507a5a182dc3f8dc3d3251a3d27e7e55a94c55c449f3ef5bb462aff131c4e3e78aa9d9c8fbb3b98d4fd9cf3dd96ffd3c4f031ef2160942a1e2f3218d40bef24549349f696e35fc79c9c8297cee49770997296a4e411a2afb45d672d16d16171fb17c187b8a34b440921ee17187f56fa5462831a140b8b7150f270eaf2e12f98da66a2a1e4319af77964b744956e5044a456a45a0aa28e6b8444f16d27e6ace93701cf53750e1acb995a2fc9c0e6e3b8f9498f857805e31b9a1cb06b64b758940e30248d2035fbd5e335a023a4be7a8f43a78780ac6876ecfbafb9be9058324e8a975631934fbe200d16954baeb136f6c09ee677617ed4868a989bfe832d71c300ca3205670ddcaa153fbc4394c39ddc7c6c48c7639be6dc6737e0760321817fbd848c02994b4da4869871568b6a1589717a92334bac462cfefef8b22652ad4f7a157c266822451c51b761bca6204edc6b40a8dabf41ed99de3774c18d0b4d622b3ab2e3ef97d48f8d5b65f4b0d7937f31987b4d20bcf6bb9017ab95b18950d15fc0d856b7dd8f00678bb981284289330891b2511049dc847124f56d0b6875a13e1b977f83f7e6590a61944e58f11f92389952584d3e14f8611f2c8873544dc99711dbbf8896a6416ee810007515b90ea64871fae6934d853a1bcd996ac1653853c55db46cf02a8b02cee14ed02fe7c9f0cfb637e6c8a2fd50db71f86b50031453eb7a2d5677ae83f762402fd94831a49812a9b4dad1d86214fa9a849e80adb79b92890d417310e285ffaedd59311030902ea7a6253643ab8495cd006ed277e39b23b03284d90008e359f71f582f0d97440534a07c66bbacce0f6148eae695a19b0cd8976bcf82b938c40fc483a41d6dd4907fb9688b04499fc31b88cb1581c3f8ad8ce5f90d3fd30d17c9fac3729b84abb1b380d46fe5ee49c053123e8e8270abf6f8b1fa118eb113807b32dc7ee3b0986c538f012f6c0533d5355c06fc04517bf9b3f30188030b8f7a542101baacda1b3d8c95ecc1d198a44fe6d46c8c41f067c9931e594f12bd1361528ea2e4e92f3485f8b8b25e83c6b8c68b7ee0acad10a8645e9db49936e1fd292ee1e7dfb22eff4b5238ea8e58fc55a8d71353981fffdc8eb72fcfbc2579e49a884288603999e79adaaf66b43514d02be1a1e23e03fda3ba95673a8cf9de2b803f0d83e7b90d4324f9c6681bd26d95f5d2b03fd1b4f6154671211eaf524af78d2ecb6ce7838698900c8d4655bc42233d566062ed0c2fb5da290d81e51504d003ae9714eacc1c6f821cd92562fbf8bc68459461efd475d2e845c0d1233c3d847c68ba6b1718a9f6bf8c985958c22975cf441a5a3e8ed19d40134e9394846d4c46f024b271f0d58c866420305d12d9a68c060aa2081ce81aa83c635af3a4a6dda9836c620486e0be2872df46eadbd20dbaa67fcf71f01ed7d6ef7f81c2286995407549ec269f3a64a355bffb1670490671a46332c363a75f48ff845eeea1002aa46636193c2ed942992695030128fb4641b2e93c43ad65a2227e05e6bdac9cb20eb656f691de4a56e900afac7ec368bf4f840aabb3847c312d29f539dfd28d8855b27b4b99f5bd1df999c80576fa536f29b455f8c027962a72829dfcf8ade1fe6a3d54f36aa9ed35e05e6fa52775b60dc8c8ea71c298d4d0f868126e778361cfb3207dfb69549ee2e8b9cb5c6547d2dd9d5af264e9a726f6004beb669eb4cebe58606a8612aa6290a2c5bcf10a871c41028b7a6a1c7a05cdf0676c87e5eb16d02f91fb37236ff1d5ee6659b042588e32b4fac2fe1ef9542f8041fa5af9582ac0eeed9b439bd1ab966f916579250f8d2bd4711383b2deb0548990f92b7cceb235072834dc4b2c8442923d0d06834d0addddd3f1bbfecb0fc975329e01c172ea05e32ffee6e10f3bf6ef5cedc2d86fbd77753591aa52fac9579dfbaaf9bc3b5351a6676c194defad581756d04f2f6bcabe00b956c3a512df9d8206f929165ed62edd634bd22567033aacfb290db3a7c9396eaa8a019bc2328407599337c5956a48bffb4fe21541a4b1f8db0ef68f326e3804afe5985ac2c71e03a0d2a857321457c007815bb939bce20ef505f7afb05f758a174a670d1ca8d31879ea2912d15e3a97b76d65d2226da28f2730ecf2f8c391b45f9143d02c52ea801a475456b9f87f161725316281c36ce778f9afaee8e37a93785eff71f73596730420baf4fab8219a05210db9f2b1ca05e542ac17b8ef40448f544edfeb92b874eb2f4c9c715a1fdbcd3d1ce848ae8329326cbd9f414d778579455a70bdd5f54e231326e850f9620414093b18199f8c34f15204ba0187127d33b0d22968fe1411b89fc929a3267745a961e7d84d3403da3bb60c0c26ab29dc07b3d31bcbc7311c900dbbde0eb734f1cfbbcac1ae4a4e4489c63c74eaea78d197e10b55a52cd1818b6569ca844b3ca208bbbba16fc371a3e568fa305f18d6fcebea2baf8d214f6357fe4cd58eb6a4012228646e7667e6411397654f15bbfe160d2e647e1a4a2c1948aed8efe4de3e5bfa3b87cc910f3619e6907e5647aeb19532fdf31790a648afd0ca01ad32252fbcea5a557f651e11fa692ecfc52fa203c2543c788490730c7cdbec9be8dec7ca3d4004020a50c5a727da31770e9dc2418e003520e09e1fb5b1b3aefb9fa9f1f058fef15a1583efe35b11c8a42ced62ceeea81744c47d1eb9058c9eb0443796c3a27314158f46bf69f40ea06cccea48f1385400fefa96f392fb6994808a4c03d0ac16e66ac2e04419784aabf0187a38eb1648bd760f525185fae3a20dbe5533f40c1e86fe92e38eabd617fa0fec190ff8e6cbebf54f06d21c9bd5d666825cc7d5aafeec95b7d85ba5f813500c8eb7cc0332d81e8cb3ff4fc5ac839381cf1661adf2d826a6a743b37fd78186904e855a606bfa84491ef06075ba967c0182b42b326841e815dbaf33c4c2932cb7ba1a622652773250ab1e911ce1acd5d001478874f2358de949051f13660d138b2f9ef10e32519a7cccc310ed314b2b4309286375dd47eec0f5341c41685ab728eed0bd03b49219a9d378d49a8c055d0a21b80003d1886c5e404afdc74656293e5301cecd58d86932e1de92e82356afcb8a222ee45ce81f142d619e41ea98f9a0c7e5d87799485b2ce3dbe545461105915ed649e2af39934237c7d34e2e69c6f2a1ac86b5e7a5d93ba4de871f56cf3db8d58f5064d24c1ac53f96c2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="人生规划" scheme="https://ruvikm.gitee.io/categories/%E4%BA%BA%E7%94%9F%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>学校GPU平台使用教程(优化版)</title>
    <link href="https://ruvikm.gitee.io/2024/04/01/%E5%AD%A6%E6%A0%A1GPU%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E6%94%B9%E8%BF%9B%E7%89%88/"/>
    <id>https://ruvikm.gitee.io/2024/04/01/%E5%AD%A6%E6%A0%A1GPU%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E6%94%B9%E8%BF%9B%E7%89%88/</id>
    <published>2024-04-01T11:10:22.000Z</published>
    <updated>2024-04-01T11:20:04.095Z</updated>
    
    <content type="html"><![CDATA[<p>首先连接内网登录<a href="http://paas.183-175-12-11.nip.io:30080/">平台</a></p><p>一般使用的话，直接找到<code>开发环境</code>一栏，创建环境。然后通过<code>Pycharm</code>中的<code>ssh</code>连接</p><p><img src="https://s1.ax1x.com/2023/08/28/pPaw2X6.png" alt="屏幕截图 2023-08-28 221321"></p><p>在<code>Pycharm</code>中，找到工具—部署—配置</p><p><img src="https://s1.ax1x.com/2023/08/28/pPad5zq.png" alt="image-20230828220300678"></p><p>点击<code>+</code>后选择<code>SFTP</code></p><p><img src="https://s1.ax1x.com/2023/08/28/pPaw5Ae.png" alt="屏幕截图 2023-08-28 221526"></p><p>在<code>SSH配置</code>那里后点击后面<code>...</code></p><p><img src="https://s1.ax1x.com/2023/08/28/pPawbct.png" alt="屏幕截图 2023-08-28 092517"></p><p>进入后填写主机名和用户名，这里详细讲一下</p><p>例如平台给的ssh连接是</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ssh://root@paas.xxx-xxx-xx-xx.nip.io:xxxxx</span><br></pre></td></tr></table></figure><p>这里用户名就需要填写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root</span><br></pre></td></tr></table></figure><p>主机名填写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">paas.xxx-xxx-xx-xx.nip.io</span><br></pre></td></tr></table></figure><p>端口号填写<code>xxxxx</code></p><p>然后填写创建环境时设置的密码</p><p><img src="https://s1.ax1x.com/2023/08/28/pPawjHS.png" alt="屏幕截图 2023-08-28 092917"></p><p>这一步完事以后，点击确定，返回到之前的页面，点击<code>映射</code></p><p><img src="https://s1.ax1x.com/2023/08/30/pPd7RaD.png" alt="屏幕截图 2023-08-30 145658"></p><p>配置好本机的地址和远程的地址，点击确认</p><p><img src="https://s1.ax1x.com/2023/08/30/pPd7LdS.png" alt="image-20230830145937224"></p><p>之后选择工具—部署—选项</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdHIkF.png" alt="QQ截图20230830150656"></p><p>可以根据自己习惯决定是否配置一下</p><p>之后就可以用Pycharm作为修改代码和文件传输的工具了</p><p>由于Pycharm自带的终端个人认为并不好用，所以可以使用Xshell软件使用终端操作，Xshell的配置同上</p><p><img src="https://s21.ax1x.com/2024/04/01/pF7gw01.png" alt></p><p>由于已经在里面安装了Anaconda，所以每次跑一个项目的时候新建一个虚拟环境即可</p><h3 id="切换环境"><a href="#切换环境" class="headerlink" title="切换环境"></a>切换环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate cu118py310</span><br></pre></td></tr></table></figure><h3 id="查看并删除环境"><a href="#查看并删除环境" class="headerlink" title="查看并删除环境"></a>查看并删除环境</h3><h4 id="查看环境列表"><a href="#查看环境列表" class="headerlink" title="查看环境列表"></a>查看环境列表</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda info --<span class="built_in">env</span></span><br></pre></td></tr></table></figure><h4 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda remove -n 环境名 --all</span><br><span class="line"></span><br><span class="line">eg:conda remove -n code --all</span><br></pre></td></tr></table></figure><h3 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n 环境名 python=版本号</span><br><span class="line"></span><br><span class="line">eg:conda create -n ChineseBERT python=3.8</span><br></pre></td></tr></table></figure><h3 id="退出当前环境"><a href="#退出当前环境" class="headerlink" title="退出当前环境"></a>退出当前环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate base</span><br></pre></td></tr></table></figure><h3 id="查看当前环境已安装的包"><a href="#查看当前环境已安装的包" class="headerlink" title="查看当前环境已安装的包"></a>查看当前环境已安装的包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先连接内网登录&lt;a href=&quot;http://paas.183-175-12-11.nip.io:30080/&quot;&gt;平台&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一般使用的话，直接找到&lt;code&gt;开发环境&lt;/code&gt;一栏，创建环境。然后通过&lt;code&gt;Pycharm&lt;/code&gt;中的&lt;co</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>客户端服务端跨平台移植，并添加线程</title>
    <link href="https://ruvikm.gitee.io/2024/03/31/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%A7%BB%E6%A4%8D/"/>
    <id>https://ruvikm.gitee.io/2024/03/31/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%A7%BB%E6%A4%8D/</id>
    <published>2024-03-31T12:14:57.000Z</published>
    <updated>2024-04-27T11:13:22.633Z</updated>
    
    <content type="html"><![CDATA[<p>客户端代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">//uni std</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVALID_SOCKET  (SOCKET)(~0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_ERROR            (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span><span class="comment">//C++标准线程库</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> g_bRun = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region 结构体定义</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CMD</span> &#123;</span><br><span class="line">CMD_LOGIN,</span><br><span class="line">CMD_LOGOUT,</span><br><span class="line">CMD_ERROR,</span><br><span class="line">CMD_LOGIN_RESULT,</span><br><span class="line">CMD_LOGOUT_RESULT,</span><br><span class="line">CMD_NEW_USER_JOIN</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> &#123;</span><br><span class="line"><span class="type">short</span> dataLength;</span><br><span class="line"><span class="type">short</span> cmd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader &#123;<span class="comment">//DataPackage</span></span><br><span class="line"><span class="built_in">Login</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(Login);</span><br><span class="line">cmd = CMD_LOGIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> userName[<span class="number">32</span>];</span><br><span class="line"><span class="type">char</span> PassWord[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">LoginResult</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(LoginResult);</span><br><span class="line">cmd = CMD_LOGIN_RESULT;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">Logout</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(Logout);</span><br><span class="line">cmd = CMD_LOGOUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> userName[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">LogoutResult</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(LogoutResult);</span><br><span class="line">cmd = CMD_LOGOUT_RESULT;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">NewUserJoin</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(NewUserJoin);</span><br><span class="line">cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">sock = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataPackage</span> &#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> endregion</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processor</span><span class="params">(SOCKET _cSock)</span> </span>&#123;</span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="type">char</span> szRecv[<span class="number">4096</span>] = &#123;&#125;;</span><br><span class="line"><span class="comment">// 5 接收客户端数据</span></span><br><span class="line"><span class="type">int</span> nLen = <span class="built_in">recv</span>(_cSock, szRecv, <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">DataHeader* header = (DataHeader*)szRecv;</span><br><span class="line"><span class="keyword">if</span> (nLen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;与服务器断开连接，任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (header-&gt;cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> CMD_LOGIN_RESULT: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">LoginResult* login = (LoginResult*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到服务端消息：CMD_LOGIN_RESULT, 数据长度：&quot;</span> &lt;&lt; login-&gt;dataLength &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CMD_LOGOUT_RESULT: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">LogoutResult* logout = (LogoutResult*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到服务端消息：CMD_LOGOUT_RESULT, 数据长度：&quot;</span> &lt;&lt; logout-&gt;dataLength &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CMD_NEW_USER_JOIN: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">NewUserJoin* userJoin = (NewUserJoin*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到服务端消息：CMD_LOGOUT_RESULT, 数据长度：&quot;</span> &lt;&lt; userJoin-&gt;dataLength &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cmdThread</span><span class="params">(SOCKET sock)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">char</span> cmdBuf[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">cin &gt;&gt; cmdBuf;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; cmdBuf &lt;&lt; endl;*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(cmdBuf, <span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;退出cmdThread线程&quot;</span> &lt;&lt; endl;</span><br><span class="line">g_bRun = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(cmdBuf, <span class="string">&quot;login&quot;</span>)) &#123;</span><br><span class="line">Login login;</span><br><span class="line"><span class="built_in">strcpy</span>(login.userName, <span class="string">&quot;lyd&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(login.PassWord, <span class="string">&quot;lydmm&quot;</span>);</span><br><span class="line"><span class="built_in">send</span>(sock, (<span class="type">const</span> <span class="type">char</span>*)&amp;login, <span class="built_in">sizeof</span>(Login), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(cmdBuf, <span class="string">&quot;logout&quot;</span>)) &#123;</span><br><span class="line">Logout logout;</span><br><span class="line"><span class="built_in">strcpy</span>(logout.userName, <span class="string">&quot;lyd&quot;</span>);</span><br><span class="line"><span class="built_in">send</span>(sock, (<span class="type">const</span> <span class="type">char</span>*)&amp;logout, <span class="built_in">sizeof</span>(Logout), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;不支持的命令...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="comment">//启动Windows socket 2.x环境</span></span><br><span class="line">WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA dat;</span><br><span class="line"><span class="built_in">WSAStartup</span>(ver, &amp;dat);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN32</span></span></span><br><span class="line"><span class="comment">// 用Socket API 建立一个简易的TCP服务端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 建立一个socket</span></span><br><span class="line">SOCKET _sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == _sock) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;建立Socket失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;建立Socket成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 连接服务器 connect</span></span><br><span class="line">sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">_sin.sin_family = AF_INET;</span><br><span class="line">_sin.sin_port = <span class="built_in">htons</span>(<span class="number">4567</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="comment">/*_sin.sin_addr.S_un.S_addr = inet_addr(&quot;192.168.88.130&quot;);*/</span></span><br><span class="line">_sin.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">_sin.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.88.130&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//_sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line"><span class="type">int</span>  ret = <span class="built_in">connect</span>(_sock, (sockaddr*)&amp;_sin, <span class="built_in">sizeof</span>(sockaddr_in));</span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == ret) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;连接服务器失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;连接服务器成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(cmdThread, _sock)</span></span>;</span><br><span class="line">t1.<span class="built_in">detach</span>();</span><br><span class="line"><span class="keyword">while</span> (g_bRun) &#123;</span><br><span class="line"></span><br><span class="line">fd_set fdReads;</span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdReads);</span><br><span class="line"><span class="built_in">FD_SET</span>(_sock, &amp;fdReads);</span><br><span class="line">timeval t = &#123; <span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">select</span>(_sock + <span class="number">1</span>, &amp;fdReads, <span class="number">0</span>, <span class="number">0</span>, &amp;t);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;select任务结束&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(_sock, &amp;fdReads)) &#123;</span><br><span class="line"><span class="built_in">FD_CLR</span>(_sock, &amp;fdReads);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">processor</span>(_sock)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;select任务结束2...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程thread</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;空闲时间处理其他业务 ...&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//仅仅适用于Windows</span></span><br><span class="line"><span class="comment">// Sleep(1000);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="comment">// 7 关闭套接字closesocket</span></span><br><span class="line"><span class="built_in">closesocket</span>(_sock);</span><br><span class="line"><span class="comment">// 8 清除windows socket环境</span></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">close</span>(_sock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN32</span></span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;客户端已退出,任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//保留界面</span></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">//uni std</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVALID_SOCKET  (SOCKET)(~0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_ERROR            (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span><span class="comment">//C++标准线程库</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region 结构体定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CMD</span> &#123;</span><br><span class="line">CMD_LOGIN,</span><br><span class="line">CMD_LOGOUT,</span><br><span class="line">CMD_ERROR,</span><br><span class="line">CMD_LOGIN_RESULT,</span><br><span class="line">CMD_LOGOUT_RESULT,</span><br><span class="line">CMD_NEW_USER_JOIN</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> &#123;</span><br><span class="line"><span class="type">short</span> dataLength;</span><br><span class="line"><span class="type">short</span> cmd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader &#123;<span class="comment">//DataPackage</span></span><br><span class="line"><span class="built_in">Login</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(Login);</span><br><span class="line">cmd = CMD_LOGIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> userName[<span class="number">32</span>];</span><br><span class="line"><span class="type">char</span> PassWord[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">LoginResult</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(LoginResult);</span><br><span class="line">cmd = CMD_LOGIN_RESULT;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">Logout</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(Logout);</span><br><span class="line">cmd = CMD_LOGOUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> userName[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">LogoutResult</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(LogoutResult);</span><br><span class="line">cmd = CMD_LOGOUT_RESULT;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">NewUserJoin</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(NewUserJoin);</span><br><span class="line">cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">sock = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataPackage</span> &#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> endregion</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;SOCKET&gt; g_clients;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processor</span><span class="params">(SOCKET _cSock)</span> </span>&#123;</span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="type">char</span> szRecv[<span class="number">4096</span>] = &#123;&#125;;</span><br><span class="line"><span class="comment">// 5 接收客户端数据</span></span><br><span class="line"><span class="type">int</span> nLen = (<span class="type">int</span>)<span class="built_in">recv</span>(_cSock, szRecv, <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">DataHeader* header = (DataHeader*)szRecv;</span><br><span class="line"><span class="keyword">if</span> (nLen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;客户端&lt; socket = &quot;</span> &lt;&lt; _cSock &lt;&lt; <span class="string">&quot; &gt;已退出，任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (header-&gt;cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> CMD_LOGIN: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">Login* login = (Login*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到客户端&lt;Socket = &quot;</span> &lt;&lt; _cSock &lt;&lt; <span class="string">&quot;&gt;请求：CMD_LOGIN, 数据长度：&quot;</span> &lt;&lt; login-&gt;dataLength &lt;&lt; <span class="string">&quot; ,userName =  &quot;</span> &lt;&lt; login-&gt;userName &lt;&lt; <span class="string">&quot; PassWord = &quot;</span> &lt;&lt; login-&gt;PassWord &lt;&lt; endl;</span><br><span class="line"><span class="comment">//忽略判断用户密码是否正确</span></span><br><span class="line">LoginResult ret;</span><br><span class="line"><span class="built_in">send</span>(_cSock, (<span class="type">char</span>*)&amp;ret, <span class="built_in">sizeof</span>(LoginResult), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CMD_LOGOUT: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">Logout* logout = (Logout*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到客户端&lt;Socket = &quot;</span> &lt;&lt; _cSock &lt;&lt; <span class="string">&quot;&gt;请求：CMD_LOGOUT, 数据长度：&quot;</span> &lt;&lt; logout-&gt;dataLength &lt;&lt; <span class="string">&quot; ,userName =  &quot;</span> &lt;&lt; logout-&gt;userName &lt;&lt; endl;</span><br><span class="line"><span class="comment">//忽略判断用户密码是否正确</span></span><br><span class="line">LogoutResult ret;</span><br><span class="line"><span class="built_in">send</span>(_cSock, (<span class="type">char</span>*)&amp;ret, <span class="built_in">sizeof</span>(ret), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: &#123;</span><br><span class="line">DataHeader header = &#123; <span class="number">0</span>,CMD_ERROR &#125;;</span><br><span class="line"><span class="built_in">send</span>(_cSock, (<span class="type">char</span>*)&amp;header, <span class="built_in">sizeof</span>(header), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="comment">//启动Windows socket 2.x环境</span></span><br><span class="line">WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA dat;</span><br><span class="line"><span class="built_in">WSAStartup</span>(ver, &amp;dat);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN32</span></span></span><br><span class="line"><span class="comment">// 用Socket API 建立一个简易的TCP服务端 1 建立一个socket 套接字</span></span><br><span class="line">SOCKET _sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="comment">// 2 bind 绑定用于接受客户端连接的网络接口</span></span><br><span class="line">sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">_sin.sin_family = AF_INET;</span><br><span class="line">_sin.sin_port = <span class="built_in">htons</span>(<span class="number">4567</span>);<span class="comment">// host to net unsigned short</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">_sin.sin_addr.S_un.S_addr = INADDR_ANY;<span class="comment">//inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">_sin.sin_addr.s_addr = INADDR_ANY;<span class="comment">//inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(_sock, (sockaddr*)&amp;_sin, <span class="built_in">sizeof</span>(_sin)) == SOCKET_ERROR) &#123;</span><br><span class="line"><span class="comment">//绑定错误</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;绑定网络端口失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;绑定网络端口成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 listen 监听网络端口</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">listen</span>(_sock, <span class="number">5</span>)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;监听网络端口失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;监听网络端口成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// 伯克利套接字 BSD socket</span></span><br><span class="line">fd_set fdRead; <span class="comment">//描述符(Socket) 集合</span></span><br><span class="line">fd_set fdWrite;</span><br><span class="line">fd_set fdExp;</span><br><span class="line"><span class="comment">//清理集合</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdRead);</span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdWrite);</span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdExp);</span><br><span class="line"><span class="comment">//将描述符(socket)加入集合</span></span><br><span class="line"><span class="built_in">FD_SET</span>(_sock, &amp;fdRead);</span><br><span class="line"><span class="built_in">FD_SET</span>(_sock, &amp;fdWrite);</span><br><span class="line"><span class="built_in">FD_SET</span>(_sock, &amp;fdExp);</span><br><span class="line">SOCKET maxSock = _sock;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = (<span class="type">int</span>)g_clients.<span class="built_in">size</span>() - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line"><span class="built_in">FD_SET</span>(g_clients[n], &amp;fdRead);</span><br><span class="line"><span class="keyword">if</span> (maxSock &lt; g_clients[n]) &#123;</span><br><span class="line">maxSock = g_clients[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//nfds 是一个整数值，是指fd_set集合中所有描述符(socket)的范围，而不是数量</span></span><br><span class="line"><span class="comment">//既是所有文件描述符最大值+1，在Windows中这个参数可以写0</span></span><br><span class="line">timeval t = &#123; <span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span>  ret = <span class="built_in">select</span>(maxSock + <span class="number">1</span>, &amp;fdRead, &amp;fdWrite, &amp;fdExp, &amp;t);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;select任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断描述符(socket)是否在集合中</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(_sock, &amp;fdRead)) &#123;</span><br><span class="line"><span class="built_in">FD_CLR</span>(_sock, &amp;fdRead);</span><br><span class="line"><span class="comment">//4 accept 等待接受客户端连接</span></span><br><span class="line">sockaddr_in clientAddr = &#123;&#125;;</span><br><span class="line"><span class="type">int</span> nAddrLen = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line">SOCKET _cSock = INVALID_SOCKET;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">_cSock = <span class="built_in">accept</span>(_sock, (sockaddr*)&amp;clientAddr, &amp;nAddrLen);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">_cSock = <span class="built_in">accept</span>(_sock, (sockaddr*)&amp;clientAddr, (<span class="type">socklen_t</span>*)&amp;nAddrLen);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN32</span></span></span><br><span class="line"><span class="keyword">if</span> (_cSock == INVALID_SOCKET) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;接受到无效客户端SOCKET...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 新客户端加入，群发</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = (<span class="type">int</span>)g_clients.<span class="built_in">size</span>() - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line">NewUserJoin userJoin;</span><br><span class="line"><span class="built_in">send</span>(g_clients[n], (<span class="type">const</span> <span class="type">char</span>*)&amp;userJoin, <span class="built_in">sizeof</span>(NewUserJoin), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">g_clients.<span class="built_in">push_back</span>(_cSock);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;新客户端加入：socket = &quot;</span> &lt;&lt; (<span class="type">int</span>)_cSock &lt;&lt; <span class="string">&quot;, IP = &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = (<span class="type">int</span>)g_clients.<span class="built_in">size</span>() - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(g_clients[n], &amp;fdRead)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">processor</span>(g_clients[n]) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">auto</span> iter = g_clients.<span class="built_in">begin</span>() + n; <span class="comment">//std::vector&lt;SOCKET&gt;::iterator</span></span><br><span class="line"><span class="keyword">if</span> (iter != g_clients.<span class="built_in">end</span>()) &#123;</span><br><span class="line">g_clients.<span class="built_in">erase</span>(iter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;空闲时间处理其他业务 ...&quot; &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = (<span class="type">int</span>)g_clients.<span class="built_in">size</span>() - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line"><span class="built_in">closesocket</span>(g_clients[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6 关闭套接字closesocket</span></span><br><span class="line"><span class="comment">//7 清除windows socket环境</span></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = (<span class="type">int</span>)g_clients.<span class="built_in">size</span>() - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line"><span class="built_in">close</span>(g_clients[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN32</span></span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;服务器已退出,任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//保留界面</span></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/04/01/pF72K3D.png" alt="image-20240331210407460"></p><p><img src="https://s21.ax1x.com/2024/04/01/pF72QjH.png" alt="Screenshot 2024-03-31 204407"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;客户端代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;if</summary>
      
    
    
    
    <category term="个人项目" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="C++socket项目" scheme="https://ruvikm.gitee.io/tags/C-socket%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>复现KnowLog模型</title>
    <link href="https://ruvikm.gitee.io/2024/03/31/%E5%A4%8D%E7%8E%B0KnowLog%E6%A8%A1%E5%9E%8B/"/>
    <id>https://ruvikm.gitee.io/2024/03/31/%E5%A4%8D%E7%8E%B0KnowLog%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-03-31T01:52:08.000Z</published>
    <updated>2024-03-31T13:05:57.429Z</updated>
    
    <content type="html"><![CDATA[<p>这次要复现的一个项目是<strong><a href="https://github.com/LeaperOvO/KnowLog">KnowLog</a></strong>，首先创建一个虚拟环境</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create KnowLog -n python=3.8</span><br><span class="line">conda activate KnowLog</span><br></pre></td></tr></table></figure><p>然后来到项目的根目录，安装项目所需的环境</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>之后尝试运行训练的部分</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python KnowLog_pretrain.py --pretrain_data ./datasets/pre-train/all_log.json --abbr ./datasets/pre-train/abbr.json --base_model bert-base-uncased</span><br></pre></td></tr></table></figure><p>毫无意外的会出报错，提示少了什么包，这时候提示缺什么用pip安装即可</p><p>再安装完这些包之后，再次尝试训练，出现了下面这个错</p><p><img src="https://s21.ax1x.com/2024/03/31/pF7ZiLT.png" alt="image-20240331100215828"></p><p>查了一下是python关于SSLError的错误，尝试降级版本解决</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install urllib3==1.25.11</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/03/31/pF7ZkeU.png" alt="image-20240331101640666"></p><p>成功解决问题，开启魔法可以正常下载了</p><p><img src="https://s21.ax1x.com/2024/03/31/pF7ZAwF.png" alt="image-20240331101821967"></p><p>但是发现下载一半又断开连接了，可能是这种下载方式不支持断点续传，于是打算先把预训练模型下载到本地试试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">huggingface-cli download --resume-download google-bert/bert-base-uncased --local-dir bert-base-uncased</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/03/31/pF7ZEo4.png" alt="image-20240331104044658"></p><p>下好了之后再次尝试跑一下，应该是下了CPU版的torch，重新安装一下吧</p><p><img src="https://s21.ax1x.com/2024/03/31/pF7ZeY9.png" alt="image-20240331104118085"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install pytorch==1.10.1 torchvision==0.11.2 torchaudio==0.10.1 cudatoolkit=11.3</span><br></pre></td></tr></table></figure><p>再次尝试训练，跑通了！！！</p><p><img src="https://s21.ax1x.com/2024/03/31/pF7ZuS1.png" alt="image-20240331110908244"></p><p>但是一直卡在34%了…重启运行了一下代码，把代理开了开（可能是代理的原因？）就可以继续往下跑了，但是好像跑不动，之后在GPU服务器上跑一下试试</p><p><img src="https://s21.ax1x.com/2024/03/31/pF7ZKQx.png" alt="image-20240331112852208"></p><p>尝试直接验证一下模型</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python KnowLog_finetune_single.py --train_data ./datasets/tasks/MC/hw_switch_train.json --dev_data ./datasets/tasks/MC/hw_switch_dev.json --test_data ./datasets/tasks/MC/hw_switch_test.json</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/03/31/pF7Z3wD.png" alt="image-20240331113220505"></p><p>也跑通了，之后在服务器上完整的跑一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这次要复现的一个项目是&lt;strong&gt;&lt;a href=&quot;https://github.com/LeaperOvO/KnowLog&quot;&gt;KnowLog&lt;/a&gt;&lt;/strong&gt;，首先创建一个虚拟环境&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="论文复现" scheme="https://ruvikm.gitee.io/categories/%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>客户端服务器升为select模型</title>
    <link href="https://ruvikm.gitee.io/2024/03/02/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8D%87%E7%BA%A7%E4%B8%BAselect%E6%A8%A1%E5%9E%8B/"/>
    <id>https://ruvikm.gitee.io/2024/03/02/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8D%87%E7%BA%A7%E4%B8%BAselect%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-03-02T02:17:20.000Z</published>
    <updated>2024-04-27T11:13:09.540Z</updated>
    
    <content type="html"><![CDATA[<p>服务端</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//只有在WIN里可以</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region 结构体定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CMD</span> &#123;</span><br><span class="line">CMD_LOGIN,</span><br><span class="line">CMD_LOGOUT,</span><br><span class="line">CMD_ERROR,</span><br><span class="line">CMD_LOGIN_RESULT,</span><br><span class="line">CMD_LOGOUT_RESULT,</span><br><span class="line">CMD_NEW_USER_JOIN</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> &#123;</span><br><span class="line"><span class="type">short</span> dataLength;</span><br><span class="line"><span class="type">short</span> cmd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader &#123;<span class="comment">//DataPackage</span></span><br><span class="line"><span class="built_in">Login</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(Login);</span><br><span class="line">cmd = CMD_LOGIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> userName[<span class="number">32</span>];</span><br><span class="line"><span class="type">char</span> PassWord[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">LoginResult</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(LoginResult);</span><br><span class="line">cmd = CMD_LOGIN_RESULT;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">Logout</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(Logout);</span><br><span class="line">cmd = CMD_LOGOUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> userName[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">LogoutResult</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(LogoutResult);</span><br><span class="line">cmd = CMD_LOGOUT_RESULT;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">NewUserJoin</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(NewUserJoin);</span><br><span class="line">cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">sock = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataPackage</span> &#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> endregion</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;SOCKET&gt; g_clients;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processor</span><span class="params">(SOCKET _cSock)</span> </span>&#123;</span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="type">char</span> szRecv[<span class="number">4096</span>] = &#123;&#125;;</span><br><span class="line"><span class="comment">// 5 接收客户端数据</span></span><br><span class="line"><span class="type">int</span> nLen = <span class="built_in">recv</span>(_cSock, szRecv, <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">DataHeader* header = (DataHeader*)szRecv;</span><br><span class="line"><span class="keyword">if</span> (nLen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;客户端&lt; socket = &quot;</span> &lt;&lt; _cSock &lt;&lt; <span class="string">&quot; &gt;已退出，任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (header-&gt;cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> CMD_LOGIN: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">Login* login = (Login*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到客户端&lt;Socket = &quot;</span> &lt;&lt; _cSock &lt;&lt; <span class="string">&quot;&gt;请求：CMD_LOGIN, 数据长度：&quot;</span> &lt;&lt; login-&gt;dataLength &lt;&lt; <span class="string">&quot; ,userName =  &quot;</span> &lt;&lt; login-&gt;userName &lt;&lt; <span class="string">&quot; PassWord = &quot;</span> &lt;&lt; login-&gt;PassWord &lt;&lt; endl;</span><br><span class="line"><span class="comment">//忽略判断用户密码是否正确</span></span><br><span class="line">LoginResult ret;</span><br><span class="line"><span class="built_in">send</span>(_cSock, (<span class="type">char</span>*)&amp;ret, <span class="built_in">sizeof</span>(LoginResult), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CMD_LOGOUT: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">Logout* logout = (Logout*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到客户端&lt;Socket = &quot;</span> &lt;&lt; _cSock &lt;&lt; <span class="string">&quot;&gt;请求：CMD_LOGOUT, 数据长度：&quot;</span> &lt;&lt; logout-&gt;dataLength &lt;&lt; <span class="string">&quot; ,userName =  &quot;</span> &lt;&lt; logout-&gt;userName &lt;&lt; endl;</span><br><span class="line"><span class="comment">//忽略判断用户密码是否正确</span></span><br><span class="line">LogoutResult ret;</span><br><span class="line"><span class="built_in">send</span>(_cSock, (<span class="type">char</span>*)&amp;ret, <span class="built_in">sizeof</span>(ret), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: &#123;</span><br><span class="line">DataHeader header = &#123; <span class="number">0</span>,CMD_ERROR &#125;;</span><br><span class="line"><span class="built_in">send</span>(_cSock, (<span class="type">char</span>*)&amp;header, <span class="built_in">sizeof</span>(header), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//启动Windows socket 2.x环境</span></span><br><span class="line">WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA dat;</span><br><span class="line"><span class="built_in">WSAStartup</span>(ver, &amp;dat);</span><br><span class="line"><span class="comment">// 用Socket API 建立一个简易的TCP服务端 1 建立一个socket 套接字</span></span><br><span class="line">SOCKET _sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="comment">// 2 bind 绑定用于接受客户端连接的网络接口</span></span><br><span class="line">sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">_sin.sin_family = AF_INET;</span><br><span class="line">_sin.sin_port = <span class="built_in">htons</span>(<span class="number">4567</span>);<span class="comment">// host to net unsigned short</span></span><br><span class="line">_sin.sin_addr.S_un.S_addr = INADDR_ANY;<span class="comment">//inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(_sock, (sockaddr*)&amp;_sin, <span class="built_in">sizeof</span>(_sin)) == SOCKET_ERROR) &#123;</span><br><span class="line"><span class="comment">//绑定错误</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;绑定网络端口失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;绑定网络端口成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 listen 监听网络端口</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">listen</span>(_sock, <span class="number">5</span>)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;监听网络端口失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;监听网络端口成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// 伯克利套接字 BSD socket</span></span><br><span class="line">fd_set fdRead; <span class="comment">//描述符(Socket) 集合</span></span><br><span class="line">fd_set fdWrite;</span><br><span class="line">fd_set fdExp;</span><br><span class="line"><span class="comment">//清理集合</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdRead);</span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdWrite);</span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdExp);</span><br><span class="line"><span class="comment">//将描述符(socket)加入集合</span></span><br><span class="line"><span class="built_in">FD_SET</span>(_sock, &amp;fdRead);</span><br><span class="line"><span class="built_in">FD_SET</span>(_sock, &amp;fdWrite);</span><br><span class="line"><span class="built_in">FD_SET</span>(_sock, &amp;fdExp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = (<span class="type">int</span>)g_clients.<span class="built_in">size</span>() - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line"><span class="built_in">FD_SET</span>(g_clients[n], &amp;fdRead);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//nfds 是一个整数值，是指fd_set集合中所有描述符(socket)的范围，而不是数量</span></span><br><span class="line"><span class="comment">//既是所有文件描述符最大值+1，在Windows中这个参数可以写0</span></span><br><span class="line">timeval t = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span>  ret = <span class="built_in">select</span>(_sock + <span class="number">1</span>, &amp;fdRead, &amp;fdWrite, &amp;fdExp, &amp;t);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;select任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断描述符(socket)是否在集合中</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(_sock, &amp;fdRead)) &#123;</span><br><span class="line"><span class="built_in">FD_CLR</span>(_sock, &amp;fdRead);</span><br><span class="line"><span class="comment">//4 accept 等待接受客户端连接</span></span><br><span class="line">sockaddr_in clientAddr = &#123;&#125;;</span><br><span class="line"><span class="type">int</span> nAddrLen = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line">SOCKET _cSock = INVALID_SOCKET;</span><br><span class="line">_cSock = <span class="built_in">accept</span>(_sock, (sockaddr*)&amp;clientAddr, &amp;nAddrLen);</span><br><span class="line"><span class="keyword">if</span> (_cSock == INVALID_SOCKET) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;接受到无效客户端SOCKET...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 新客户端加入，群发</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = (<span class="type">int</span>)g_clients.<span class="built_in">size</span>() - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line">NewUserJoin userJoin;</span><br><span class="line"><span class="built_in">send</span>(g_clients[n], (<span class="type">const</span> <span class="type">char</span>*)&amp;userJoin, <span class="built_in">sizeof</span>(NewUserJoin), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">g_clients.<span class="built_in">push_back</span>(_cSock);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;新客户端加入：socket = &quot;</span> &lt;&lt; (<span class="type">int</span>)_cSock &lt;&lt; <span class="string">&quot;, IP = &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> n = <span class="number">0</span>; n &lt; fdRead.fd_count; n++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">processor</span>(fdRead.fd_array[n]) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">auto</span> iter = <span class="built_in">find</span>(g_clients.<span class="built_in">begin</span>(), g_clients.<span class="built_in">end</span>(), fdRead.fd_array[n]);</span><br><span class="line"><span class="keyword">if</span> (iter != g_clients.<span class="built_in">end</span>()) &#123;</span><br><span class="line">g_clients.<span class="built_in">erase</span>(iter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试中间select函数最后一个参数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;空闲时间处理其他业务 ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> n = g_clients.<span class="built_in">size</span>() - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line"><span class="built_in">closesocket</span>(g_clients[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6 关闭套接字closesocket</span></span><br><span class="line"><span class="comment">//7 清除windows socket环境</span></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;服务器已退出,任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//保留界面</span></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//只有在WIN里可以</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region 结构体定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CMD</span> &#123;</span><br><span class="line">CMD_LOGIN,</span><br><span class="line">CMD_LOGOUT,</span><br><span class="line">CMD_ERROR,</span><br><span class="line">CMD_LOGIN_RESULT,</span><br><span class="line">CMD_LOGOUT_RESULT,</span><br><span class="line">CMD_NEW_USER_JOIN</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataHeader</span> &#123;</span><br><span class="line"><span class="type">short</span> dataLength;</span><br><span class="line"><span class="type">short</span> cmd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span> : <span class="keyword">public</span> DataHeader &#123;<span class="comment">//DataPackage</span></span><br><span class="line"><span class="built_in">Login</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(Login);</span><br><span class="line">cmd = CMD_LOGIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> userName[<span class="number">32</span>];</span><br><span class="line"><span class="type">char</span> PassWord[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginResult</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">LoginResult</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(LoginResult);</span><br><span class="line">cmd = CMD_LOGIN_RESULT;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logout</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">Logout</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(Logout);</span><br><span class="line">cmd = CMD_LOGOUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> userName[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LogoutResult</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">LogoutResult</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(LogoutResult);</span><br><span class="line">cmd = CMD_LOGOUT_RESULT;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NewUserJoin</span> : <span class="keyword">public</span> DataHeader &#123;</span><br><span class="line"><span class="built_in">NewUserJoin</span>() &#123;</span><br><span class="line">dataLength = <span class="built_in">sizeof</span>(NewUserJoin);</span><br><span class="line">cmd = CMD_NEW_USER_JOIN;</span><br><span class="line">sock = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataPackage</span> &#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> endregion</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processor</span><span class="params">(SOCKET _cSock)</span> </span>&#123;</span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="type">char</span> szRecv[<span class="number">4096</span>] = &#123;&#125;;</span><br><span class="line"><span class="comment">// 5 接收客户端数据</span></span><br><span class="line"><span class="type">int</span> nLen = <span class="built_in">recv</span>(_cSock, szRecv, <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">DataHeader* header = (DataHeader*)szRecv;</span><br><span class="line"><span class="keyword">if</span> (nLen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;与服务器断开连接，任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (header-&gt;cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> CMD_LOGIN_RESULT: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">LoginResult* login = (LoginResult*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到服务端消息：CMD_LOGIN_RESULT, 数据长度：&quot;</span> &lt;&lt; login-&gt;dataLength &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CMD_LOGOUT_RESULT: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">LogoutResult* logout = (LogoutResult*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到服务端消息：CMD_LOGOUT_RESULT, 数据长度：&quot;</span> &lt;&lt; logout-&gt;dataLength &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CMD_NEW_USER_JOIN: &#123;</span><br><span class="line"><span class="built_in">recv</span>(_cSock, szRecv + <span class="built_in">sizeof</span>(DataHeader), header-&gt;dataLength - <span class="built_in">sizeof</span>(DataHeader), <span class="number">0</span>);</span><br><span class="line">NewUserJoin* userJoin = (NewUserJoin*)szRecv;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收到服务端消息：CMD_LOGOUT_RESULT, 数据长度：&quot;</span> &lt;&lt; userJoin-&gt;dataLength &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//启动Windows socket 2.x环境</span></span><br><span class="line">WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA dat;</span><br><span class="line"><span class="built_in">WSAStartup</span>(ver, &amp;dat);</span><br><span class="line"><span class="comment">// 用Socket API 建立一个简易的TCP服务端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 建立一个socket</span></span><br><span class="line">SOCKET _sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == _sock) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;建立Socket失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;建立Socket成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 连接服务器 connect</span></span><br><span class="line">sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">_sin.sin_family = AF_INET;</span><br><span class="line">_sin.sin_port = <span class="built_in">htons</span>(<span class="number">4567</span>);</span><br><span class="line">_sin.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">connect</span>(_sock, (sockaddr*)&amp;_sin, <span class="built_in">sizeof</span>(sockaddr_in));</span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == ret) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;连接服务器失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;连接服务器成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">fd_set fdReads;</span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;fdReads);</span><br><span class="line"><span class="built_in">FD_SET</span>(_sock,&amp;fdReads);</span><br><span class="line">timeval t = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">select</span>(_sock, &amp;fdReads, <span class="number">0</span>, <span class="number">0</span>, &amp;t);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;select任务结束&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(_sock, &amp;fdReads)) &#123;</span><br><span class="line"><span class="built_in">FD_CLR</span>(_sock, &amp;fdReads);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">processor</span>(_sock)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;select任务结束2...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;空闲时间处理其他业务 ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">Login login;</span><br><span class="line"><span class="built_in">strcpy</span>(login.userName, <span class="string">&quot;lyd&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(login.PassWord, <span class="string">&quot;lyd&quot;</span>);</span><br><span class="line"><span class="built_in">send</span>(_sock, (<span class="type">const</span> <span class="type">char</span>*)&amp;login, <span class="built_in">sizeof</span>(Login), <span class="number">0</span>);</span><br><span class="line"><span class="comment">//仅仅适用于Windows</span></span><br><span class="line"><span class="comment">// Sleep(1000);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7 关闭套接字closesocket</span></span><br><span class="line"><span class="built_in">closesocket</span>(_sock);</span><br><span class="line"><span class="comment">// 8 清除windows socket环境</span></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;客户端已退出,任务结束...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//保留界面</span></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s11.ax1x.com/2024/03/02/pF0yFOS.png" alt="image-20240302101949530"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;服务端&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;defin</summary>
      
    
    
    
    <category term="个人项目" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="C++socket项目" scheme="https://ruvikm.gitee.io/tags/C-socket%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>nginx反向代理出错</title>
    <link href="https://ruvikm.gitee.io/2024/01/26/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%87%BA%E9%94%99/"/>
    <id>https://ruvikm.gitee.io/2024/01/26/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%87%BA%E9%94%99/</id>
    <published>2024-01-26T13:24:54.000Z</published>
    <updated>2024-01-26T14:07:24.191Z</updated>
    
    <content type="html"><![CDATA[<p>使用yum安装好了nginx</p><h2 id="问题再现"><a href="#问题再现" class="headerlink" title="问题再现"></a>问题再现</h2><p>进入路径配置好了<code>nginx.conf</code>文件</p><p><img src="https://s11.ax1x.com/2024/01/26/pFnwVDP.png" alt="QQ截图20240126212909"></p><p>验证<code>nginx.conf</code>文件是否有语法错误</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nginx -t</span><br></pre></td></tr></table></figure><p>重载nginx服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure><p>然后启动程序，发现nginx报错</p><p><img src="https://s11.ax1x.com/2024/01/26/pFnwmE8.png" alt="img"></p><p>在终端可以尝试输入了这样一句话</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setsebool -P httpd_can_network_connect <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>解释：可能是SELinux的原因，它会基于最小权限原则默认拦截了 Nginx 的请求</p><p><img src="https://s11.ax1x.com/2024/01/26/pFnwnUS.png" alt="image-20240126213917121"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用yum安装好了nginx&lt;/p&gt;
&lt;h2 id=&quot;问题再现&quot;&gt;&lt;a href=&quot;#问题再现&quot; class=&quot;headerlink&quot; title=&quot;问题再现&quot;&gt;&lt;/a&gt;问题再现&lt;/h2&gt;&lt;p&gt;进入路径配置好了&lt;code&gt;nginx.conf&lt;/code&gt;文件&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/tags/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>在虚拟机Centos 7中配置Redis环境</title>
    <link href="https://ruvikm.gitee.io/2024/01/08/%E9%85%8D%E7%BD%AERedis%E7%8E%AF%E5%A2%83/"/>
    <id>https://ruvikm.gitee.io/2024/01/08/%E9%85%8D%E7%BD%AERedis%E7%8E%AF%E5%A2%83/</id>
    <published>2024-01-08T12:05:08.000Z</published>
    <updated>2024-01-08T13:04:38.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载fedora的epel仓库</span></span><br><span class="line">sudo yum install epel-release</span><br><span class="line"><span class="comment"># 安装redis数据库</span></span><br><span class="line">sudo yum install redis</span><br></pre></td></tr></table></figure><p>测试是否安装成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动redis</span></span><br><span class="line">service redis start</span><br><span class="line"><span class="comment">#查看redis进程</span></span><br><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure><p><img src="https://s11.ax1x.com/2024/01/08/pFSvcQg.png" alt="image-20240108203745982"></p><h2 id="配置Redis"><a href="#配置Redis" class="headerlink" title="配置Redis"></a>配置Redis</h2><p><strong>以需求为远程连接Redis为例</strong></p><p>开始配置之前，先关闭Redis服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#关闭redis</span></span><br><span class="line">service redis stop</span><br></pre></td></tr></table></figure><h4 id="打开配置文件"><a href="#打开配置文件" class="headerlink" title="打开配置文件"></a>打开配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/redis.conf</span><br></pre></td></tr></table></figure><p>进入编辑器后，输入<code>/</code>+<code>搜索的内容</code>然后回车进行搜索，按<code>n</code>键查找下一个(eg:修改端口号时输入/port)，按<code>i</code>进入到插入模式进行修改，修改完后按<code>Esc</code>退出插入模式</p><h4 id="修改端口号（按照需求修改）"><a href="#修改端口号（按照需求修改）" class="headerlink" title="修改端口号（按照需求修改）"></a>修改端口号（按照需求修改）</h4><p><img src="https://s11.ax1x.com/2024/01/08/pFSvmM4.png" alt="image-20240108202709064"></p><h4 id="修改默认密码（建议修改）"><a href="#修改默认密码（建议修改）" class="headerlink" title="修改默认密码（建议修改）"></a>修改默认密码（建议修改）</h4><p><img src="https://s11.ax1x.com/2024/01/08/pFSvnsJ.png" alt="image-20240108202554924"></p><h4 id="取消只允许在本机连接redis"><a href="#取消只允许在本机连接redis" class="headerlink" title="取消只允许在本机连接redis"></a>取消只允许在本机连接redis</h4><p><img src="https://s11.ax1x.com/2024/01/08/pFSzuU1.png" alt="image-20240108202958241"></p><p>将<code>bind 127.0.0.1</code>注释掉</p><p>然后输入<code>:wq</code>保存并退出</p><h4 id="设置Redis开机自启"><a href="#设置Redis开机自启" class="headerlink" title="设置Redis开机自启"></a>设置Redis开机自启</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig redis on</span><br></pre></td></tr></table></figure><h2 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h2><p>在linux下的防火墙中开放6379端口（如果上面更换了端口号就按自己的来）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=6379/tcp --permanent</span><br></pre></td></tr></table></figure><p>重启防火墙</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart firewalld</span><br></pre></td></tr></table></figure><h2 id="使用可视化软件连接Redis"><a href="#使用可视化软件连接Redis" class="headerlink" title="使用可视化软件连接Redis"></a>使用可视化软件连接Redis</h2><p>下载可视化软件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://gitee.com/qishibo/AnotherRedisDesktopManager/releases</span><br></pre></td></tr></table></figure><p>查看自己ip地址</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p><img src="https://s11.ax1x.com/2024/01/08/pFSzK4x.png" alt="屏幕截图 2024-01-08 204612"></p><p>配置远程连接，地址为上面的箭头所指的ip地址，密码为刚刚配置Redis时配置的</p><p><img src="https://s11.ax1x.com/2024/01/08/pFSzQC6.png" alt="屏幕截图 2024-01-08 205033"></p><p>连接成功</p><p><img src="https://s11.ax1x.com/2024/01/08/pFSzl8K.png" alt="屏幕截图 2024-01-08 205120"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装Redis&quot;&gt;&lt;a href=&quot;#安装Redis&quot; class=&quot;headerlink&quot; title=&quot;安装Redis&quot;&gt;&lt;/a&gt;安装Redis&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/tags/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>建立一个简易的TCP客户端与服务端</title>
    <link href="https://ruvikm.gitee.io/2023/12/15/%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    <id>https://ruvikm.gitee.io/2023/12/15/%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF/</id>
    <published>2023-12-15T10:19:52.000Z</published>
    <updated>2024-04-27T11:12:58.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a>TCP服务端</h2><p>分为一下六步：</p><ol><li>建立一个socket 套接字</li><li>bind 绑定用于接受客户端连接的网络接口</li><li>listen 监听网络端口</li><li>accept 等待接受客户端连接</li><li>send 向客户端发送一条数据</li><li>关闭套接字closesocket</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//只有在WIN里可以</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//启动Windows socket 2.x环境</span></span><br><span class="line">WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA dat;</span><br><span class="line"><span class="built_in">WSAStartup</span>(ver, &amp;dat);</span><br><span class="line"><span class="comment">// 用Socket API 建立一个简易的TCP服务端</span></span><br><span class="line"><span class="comment">// 1 建立一个socket 套接字</span></span><br><span class="line">SOCKET _sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="comment">// 2 bind 绑定用于接受客户端连接的网络接口</span></span><br><span class="line">sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">_sin.sin_family = AF_INET;</span><br><span class="line">_sin.sin_port = <span class="built_in">htons</span>(<span class="number">4567</span>);<span class="comment">// host to net unsigned short</span></span><br><span class="line">_sin.sin_addr.S_un.S_addr = INADDR_ANY;<span class="comment">//inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(_sock, (sockaddr*)&amp;_sin, <span class="built_in">sizeof</span>(_sin)) == SOCKET_ERROR) &#123;</span><br><span class="line"><span class="comment">//绑定错误</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;绑定网络端口失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;绑定网络端口成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 listen 监听网络端口</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">listen</span>(_sock, <span class="number">5</span>)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;监听网络端口失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;监听网络端口成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4 accept 等待接受客户端连接</span></span><br><span class="line">sockaddr_in clientAddr = &#123;&#125;;</span><br><span class="line"><span class="type">int</span> nAddrLen = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line">SOCKET _cSock = INVALID_SOCKET;</span><br><span class="line"><span class="type">char</span> msgBuf[] = <span class="string">&quot;Hello ,I&#x27;m Server.&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">_cSock = <span class="built_in">accept</span>(_sock, (sockaddr*)&amp;clientAddr, &amp;nAddrLen);</span><br><span class="line"><span class="keyword">if</span> (_cSock == INVALID_SOCKET) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;接受到无效客户端SOCKET...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;新客户端加入：IP =&quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr) &lt;&lt; endl;</span><br><span class="line"><span class="comment">//5 send 向客户端发送一条数据</span></span><br><span class="line"><span class="built_in">send</span>(_cSock, msgBuf, <span class="built_in">strlen</span>(msgBuf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6 关闭套接字closesocket</span></span><br><span class="line"><span class="built_in">closesocket</span>(_sock);</span><br><span class="line"><span class="comment">//7 清除windows socket环境</span></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="comment">//保留界面</span></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP服务端-1"><a href="#TCP服务端-1" class="headerlink" title="TCP服务端"></a>TCP服务端</h2><p>分为四步：</p><ol><li>建立一个socket</li><li>连接服务器 connect</li><li>接受服务器信息 recv</li><li>关闭套接字closesocket</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//只有在WIN里可以</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//启动Windows socket 2.x环境</span></span><br><span class="line">WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA dat;</span><br><span class="line"><span class="built_in">WSAStartup</span>(ver, &amp;dat);</span><br><span class="line"><span class="comment">// 用Socket API 建立一个简易的TCP服务端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 建立一个socket</span></span><br><span class="line">SOCKET _sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == _sock) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;建立Socket失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;建立Socket成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 连接服务器 connect</span></span><br><span class="line">sockaddr_in _sin = &#123;&#125;;</span><br><span class="line">_sin.sin_family = AF_INET;</span><br><span class="line">_sin.sin_port = <span class="built_in">htons</span>(<span class="number">4567</span>);</span><br><span class="line">_sin.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">connect</span>(_sock, (sockaddr*)&amp;_sin, <span class="built_in">sizeof</span>(sockaddr_in));</span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == ret) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;连接Socket失败...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;连接Socket成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 接受服务器信息 recv</span></span><br><span class="line"><span class="type">char</span> recvBuf[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line"><span class="type">int</span> nlen = <span class="built_in">recv</span>(_sock, recvBuf, <span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (nlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;接收到数据为：&quot;</span> &lt;&lt; recvBuf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4 关闭套接字closesocket</span></span><br><span class="line"><span class="built_in">closesocket</span>(_sock);</span><br><span class="line"><span class="comment">// 5 清除windows socket环境</span></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="comment">//保留界面</span></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><strong>服务端</strong></p><p><img src="https://s11.ax1x.com/2023/12/15/pi41BFK.png" alt="屏幕截图 2023-12-15 181558"></p><p><strong>客户端</strong></p><p><img src="https://s11.ax1x.com/2023/12/15/pi41DJO.png" alt="屏幕截图 2023-12-15 181602"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TCP服务端&quot;&gt;&lt;a href=&quot;#TCP服务端&quot; class=&quot;headerlink&quot; title=&quot;TCP服务端&quot;&gt;&lt;/a&gt;TCP服务端&lt;/h2&gt;&lt;p&gt;分为一下六步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立一个socket 套接字&lt;/li&gt;
&lt;li&gt;bind 绑定用于</summary>
      
    
    
    
    <category term="个人项目" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="C++socket项目" scheme="https://ruvikm.gitee.io/tags/C-socket%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>JZ22 链表中倒数最后k个结点</title>
    <link href="https://ruvikm.gitee.io/2023/11/20/JZ22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8Ek%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://ruvikm.gitee.io/2023/11/20/JZ22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8Ek%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2023-11-20T08:08:47.000Z</published>
    <updated>2024-04-27T11:11:36.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>输入一个长度为 n 的链表，设链表中的元素的值为 a_i ，返回该链表中倒数第k个节点。</p><p>如果该链表长度小于k，请返回一个长度为 0 的链表。</p><p>数据范围：</p><script type="math/tex; mode=display">0 \leq n \leq 10^5,0 \leq a_i \leq 10^9,0 \leq k \leq 10^9</script><p>要求：空间复杂度 <em>O</em>(n)，时间复杂度 O<em>(</em>n)</p><p>进阶：空间复杂度O(1)，时间复杂度 O(n)</p><p>例如输入{1,2,3,4,5},2时，对应的链表结构如下图所示：</p><p><img src="https://z1.ax1x.com/2023/11/20/piap43j.png" alt="img"></p><p>其中蓝色部分为该链表的最后2个结点，所以返回倒数第2个结点（也即结点值为4的结点）即可，系统会打印后面所有的节点来比较。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">&#123;1,2,3,4,5&#125;,2</span><br><span class="line">返回值：</span><br><span class="line">&#123;4,5&#125;</span><br><span class="line">说明：</span><br><span class="line">返回倒数第2个节点4，系统会打印后面所有的节点来比较。 </span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">&#123;2&#125;,8</span><br><span class="line">返回值：</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>首先求出链表的长度<code>n</code>，从题目的倒数第<code>k</code>个结点，推出是正数的第<code>n - k</code>个结点。若<code>n - k &lt; 0</code>，则返回空值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param pHead ListNode类</span></span><br><span class="line"><span class="comment">     * @param k int整型</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pHead, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode* p = pHead;</span><br><span class="line">        <span class="keyword">for</span> (; p != <span class="literal">nullptr</span>; p = p-&gt;next, len++);</span><br><span class="line">        <span class="type">int</span> step = len - k;</span><br><span class="line">        <span class="keyword">if</span> (step &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (step--) &#123;</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>用一个栈处理，由于栈是后进先出的，所以正好符合题意的倒数。倒数第k个结点就意味着栈需要弹出k次即可。</p><p>这里有一个细节，栈都弹完了，k还是大于等于0的，则应该返回空值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param pHead ListNode类</span></span><br><span class="line"><span class="comment">     * @param k int整型</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pHead, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        stack&lt;ListNode*&gt; st;</span><br><span class="line">        ListNode* res;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(pHead);</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (k-- &amp;&amp; !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;输入一个长度为 n 的链表，设链表中的元素的值为 a_i ，返回该链表中倒数第k个节点。&lt;/p&gt;
&lt;p&gt;如果该链表长度小于k，请返回一个长度</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://ruvikm.gitee.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>jz23 链表中环的入口结点</title>
    <link href="https://ruvikm.gitee.io/2023/11/20/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/"/>
    <id>https://ruvikm.gitee.io/2023/11/20/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/</id>
    <published>2023-11-20T02:33:18.000Z</published>
    <updated>2024-04-27T11:12:49.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。</p><p>数据范围： n≤10000，1&lt;=结点值&lt;=10000</p><p>要求：空间复杂度 O<em>(1)，时间复杂度 O</em>(<em>n</em>)</p><p>例如，输入{1,2},{3,4,5}时，对应的环形链表如下图所示：</p><p><img src="https://z1.ax1x.com/2023/11/20/piU6lqS.png" alt="img"></p><p>可以看到环的入口结点的结点值为3，所以返回结点值为3的结点。</p><h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>输入分为2段，第一段是入环前的链表部分，第二段是链表环的部分，后台会根据第二段是否为空将这两段组装成一个无环或者有环单链表</p><h3 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h3><p>返回链表的环的入口结点即可，我们后台程序会打印这个结点对应的结点值；若没有，则返回对应编程语言的空结点即可。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2&#125;,&#123;3,4,5&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回环形链表入口结点，我们后台程序会打印该环形链表入口结点对应的结点值，即3   </span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1&#125;,&#123;&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;null&quot;</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">没有环，返回对应编程语言的空结点，后台程序会打印&quot;null&quot;   </span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;,&#123;2&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环的部分只有一个结点，所以返回该环形链表入口结点，后台程序打印该结点对应的结点值，即2 </span><br></pre></td></tr></table></figure><h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>如果不考虑空间复杂度，可以使用一个大小为10000的数组<code>a</code>存放各个结点的值，每当遍历到一个节点V的时候，就把<code>a[v-val]++</code></p><p>因为存在换，所以当第一个<code>a[v-val] == 2</code>的时候，即为环的入口结点</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vt</span><span class="params">(<span class="number">10000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(pHead != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            vt[pHead-&gt;val]++;</span><br><span class="line">            <span class="keyword">if</span>(vt[pHead-&gt;val] == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>可以使用快慢指针，快指针<code>fast</code>每次走两步，慢指针<code>slow</code>每次走一步。这样如果有环存在的话，在环中，快慢指针的距离，每移动一次距离就会减一，这样如果它们相遇的话，就一定可以判断链表中有没有环。</p><p>那么如何判断环的入口点是在哪里呢？我们假设环前面的节点有a个，环中的节点有b个，慢指针走的长度为S_dis</p><p>快指针走的路线为F_dis。当两个指针相遇时，依据题意可以等于以下两个等式</p><script type="math/tex; mode=display">F_{dis} = 2  S_{dis}(因为快指针每次走的步数是慢指针的两倍)</script><script type="math/tex; mode=display">F_{dis} = a + nb(当两者相遇时，快指针一定已经绕环走了n圈)</script><p>联立可得</p><script type="math/tex; mode=display">2  S_{dis} = a + nb</script><p>可以得出</p><script type="math/tex; mode=display">a = S_{dis} = nb</script><script type="math/tex; mode=display">F_{dis} = 2nb</script><p>所以当两个指针相遇的时候，将快指针移到链表头部重新往后走，这次一次走一步。慢指针保持原来的位置，继续向后走，也是一次走一步，当两个指针相遇的时候，即是环的入口处。（这时候快指针刚好走完<code>a = nb</code>的长度到达环的入口处）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = pHead;</span><br><span class="line">        ListNode* fast = pHead;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = slow -&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">//如果指向空就说明没有环</span></span><br><span class="line">            <span class="keyword">if</span> (slow == <span class="literal">nullptr</span> || fast == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。&lt;/p&gt;
&lt;p&gt;数据范围： n≤10000，1&amp;lt;=结</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://ruvikm.gitee.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>JZ52 两个链表的第一个公共结点</title>
    <link href="https://ruvikm.gitee.io/2023/11/19/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/"/>
    <id>https://ruvikm.gitee.io/2023/11/19/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/</id>
    <published>2023-11-19T11:13:13.000Z</published>
    <updated>2024-04-27T11:11:50.475Z</updated>
    
    <content type="html"><![CDATA[<p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p><p>数据范围： n≤1000<br>要求：空间复杂度 O<em>(1)，时间复杂度 )</em>O<em>(</em>n)</p><p>例如，输入{1,2,3},{4,5},{6,7}时，两个无环的单向链表的结构如下图所示：</p><p><img src="https://z1.ax1x.com/2023/11/19/piUE2Pf.png" alt="img"></p><p>可以看到它们的第一个公共结点的结点值为6，所以返回结点值为6的结点。</p><h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>输入分为是3段，第一段是第一个链表的非公共部分，第二段是第二个链表的非公共部分，第三段是第一个链表和第二个链表的公共部分。 后台会将这3个参数组装为两个链表，并将这两个链表对应的头节点传入到函数FindFirstCommonNode里面，用户得到的输入只有pHead1和pHead2。</p><h3 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h3><p>返回传入的pHead1和pHead2的第一个公共结点，后台会打印以该节点为头节点的链表。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;6,7&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一个参数&#123;1,2,3&#125;代表是第一个链表非公共部分，第二个参数&#123;4,5&#125;代表是第二个链表非公共部分，最后的&#123;6,7&#125;表示的是2个链表的公共部分</span><br><span class="line">这3个参数最后在后台会组装成为2个两个无环的单链表，且是有公共节点的          </span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1&#125;,&#123;2,3&#125;,&#123;&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2个链表没有公共节点 ,返回null，后台打印&#123;&#125;       </span><br></pre></td></tr></table></figure><h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>首先先求出两个链表的长度，让长度长一点的指针先往前走几步（走的步数 = 两链表长度差），然后让两个指针分别指向两个链表，当两个指针相等的时候几个返回当前指向的结点</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span> || pHead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> len1 = <span class="number">0</span>, len2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ListNode* p = pHead1; p != <span class="literal">nullptr</span>; p = p-&gt;next, len1++);</span><br><span class="line">        <span class="keyword">for</span> (ListNode* p = pHead2; p != <span class="literal">nullptr</span>; p = p-&gt;next, len2++);</span><br><span class="line">        <span class="type">int</span> step = <span class="built_in">abs</span>(len2 - len1);</span><br><span class="line"><span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line"><span class="keyword">while</span>(step--)&#123;</span><br><span class="line">pHead1 = pHead1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(step--)&#123;</span><br><span class="line">pHead2 = pHead2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(pHead1 != pHead2)&#123;</span><br><span class="line">pHead1 = pHead1-&gt;next;</span><br><span class="line">pHead2 = pHead2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> pHead1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>用两个指针分别指向两个链表，让其循环移动，当指向同一个结点的时候即为公共结点</p><p><img src="https://z1.ax1x.com/2023/11/19/piUES4f.png" alt="微信图片_20231119204317"></p><p>也就是说，当指针1走完{1,2,3,6,7}的时候，让它指向{4,5}。同理，当指针2走完{4,5,6,7}的时候，让它指向{1,2,3}</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="literal">nullptr</span> ||pHead2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">ListNode * H1 = pHead1, * H2 = pHead2;</span><br><span class="line"><span class="keyword">while</span>(H1 != H2)&#123;</span><br><span class="line">H1 = (H1 == <span class="literal">nullptr</span>) ? pHead2 : H1-&gt;next;</span><br><span class="line">H2 = (H2 == <span class="literal">nullptr</span>) ? pHead1 : H2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> H1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）&lt;/p&gt;
&lt;p&gt;数据范围： n≤1000&lt;br&gt;要求：空间复杂度 O&lt;em&gt;(1)，时间复杂度 )&lt;/em&gt;</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://ruvikm.gitee.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>jz25 合并两个排序的链表</title>
    <link href="https://ruvikm.gitee.io/2023/11/18/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>https://ruvikm.gitee.io/2023/11/18/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2023-11-18T02:35:51.000Z</published>
    <updated>2024-04-27T11:12:03.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p>数据范围： 0≤10000≤<em>n</em>≤1000，−1000≤节点值≤1000−1000≤节点值≤1000<br>要求：空间复杂度 <em>O</em>(1)，时间复杂度 <em>O</em>(<em>n</em>)</p><p>如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6}，转换过程如下图所示：</p><p><img src="https://z1.ax1x.com/2023/11/19/piUEyVI.png" alt="09DD8C2662B96CE14928333F055C5580"></p><p>或输入{-1,2,4},{1,3,4}时，合并后的链表为{-1,1,2,3,4,4}，所以对应的输出为{-1,1,2,3,4,4}，转换过程如下图所示：</p><p><img src="https://z1.ax1x.com/2023/11/19/piUE6at.png" alt="8266E4BFEDA1BD42D8F9794EB4EA0A13"></p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,3,5&#125;,&#123;2,4,6&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3,4,5,6&#125;</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;,&#123;&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;-1,2,4&#125;,&#123;1,3,4&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;-1,1,2,3,4,4&#125;</span><br></pre></td></tr></table></figure><h1 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h1><p>可以使用虚拟头结点，可以再新建一个链表，然后把两个链表的结点从小到大依次插入到新链表中即可。使用双指针分别指向两个链表，然后每次将较小的结点放在虚拟头结点后面，然后指针（刚刚较小的）放后移动，另一个指针不动</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param pHead1 ListNode类</span></span><br><span class="line"><span class="comment">     * @param pHead2 ListNode类</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span> (pHead2 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        ListNode* p = pHead2, *q = pHead1;</span><br><span class="line">        ListNode* newHead;</span><br><span class="line">        newHead = p-&gt;val &lt;= q-&gt;val ? p : q;</span><br><span class="line">        ListNode *res = newHead;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt;= q-&gt;val) &#123;</span><br><span class="line">                ListNode* tmp = p-&gt;next;</span><br><span class="line">                ListNode* node = p;</span><br><span class="line">                newHead-&gt;next = node;</span><br><span class="line">                newHead = node;</span><br><span class="line">                p = tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ListNode* tmp = q-&gt;next;</span><br><span class="line">                ListNode* node = q;</span><br><span class="line">                newHead-&gt;next = node;</span><br><span class="line">                newHead = node;</span><br><span class="line">                q = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            newHead-&gt;next = p;</span><br><span class="line">            newHead = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            newHead-&gt;next = q;</span><br><span class="line">            newHead = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本来打算将一个链表插入到另一个链表之中的，但是太复杂了，一直没有AC</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。&lt;/p&gt;
&lt;p&gt;数据范围： 0≤10000≤&lt;em</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://ruvikm.gitee.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>JZ24 反转链表</title>
    <link href="https://ruvikm.gitee.io/2023/11/16/JZ24%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://ruvikm.gitee.io/2023/11/16/JZ24%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2023-11-16T10:48:55.000Z</published>
    <updated>2023-11-19T12:58:52.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个单链表的头结点<code>pHead</code>(该头节点是有值的，比如在下图，它的<code>val</code>是1)，长度为n，反转该链表后，返回新链表的表头。</p><p>数据范围： 0≤10000≤<em>n</em>≤1000</p><p>要求：空间复杂度 O<em>(1) ，时间复杂度 O</em>(<em>n</em>) 。</p><p>如当输入链表{1,2,3}时，</p><p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。</p><p>以上转换过程如下图所示：</p><p><img src="https://z1.ax1x.com/2023/11/19/piUEBKH.png" alt="4A47A0DB6E60853DEDFCFDF08A5CA249"></p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;3,2,1&#125;</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空链表则输出空                 </span><br></pre></td></tr></table></figure><h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>使用栈当做中转站，把每个节点倒过来，然后重新拼成一个新链表</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param head ListNode类</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        stack&lt;ListNode*&gt; st;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tail = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        ListNode* res = tail;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ListNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            tail-&gt;next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后的节点为原来的头结点，需要将其的下一个节点设为空，否则会构成环</span></span><br><span class="line">        tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://z1.ax1x.com/2023/11/16/pit8EWR.png" alt="构成环"></p><p><strong>题目细节</strong></p><p>结点3为<code>tail</code>变量，经过<code>while</code>循环，会使用尾插法将结点1和2都插入到3后面，这期间，结点2和3和<code>next</code>指针都经过了处理，而最后一个结点1的<code>next</code>指针（结点1的<code>next</code>原本是指向结点2的）却没有处理，因为此时已经跳出了<code>while</code>循环。如果不将结点1的下一个结点置为空，则会在结点1和2之间形成环，程序输出会如下：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">3,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...</span><br></pre></td></tr></table></figure><h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>使用两个结点求解，将摘下来的每一个结点使用头插法插入到新的链表中，如图画了程序两步的情况</p><p><img src="https://z1.ax1x.com/2023/11/17/pit5oeP.png" alt="反转链表"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *int val;</span></span><br><span class="line"><span class="comment"> *struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ListNode* newHead = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* tmp = head-&gt;next;</span><br><span class="line">            head-&gt;next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>扩展思维</strong></p><p>其实用<code>vector</code>容器顺序存放各个结点，然后出来的时候使用头插法新建链表也可以，这样分离结点的时候可能不太容易出错</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param head ListNode类</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        vector&lt;ListNode*&gt; vt;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">//分离结点</span></span><br><span class="line">            ListNode* tmp = head-&gt;next;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            vt.<span class="built_in">push_back</span>(head);</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新建链表</span></span><br><span class="line">        ListNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node : vt) &#123;</span><br><span class="line">            node-&gt;next = res;</span><br><span class="line">            res = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样也可以不使用<code>vector</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param head ListNode类</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* tmp = head-&gt;next;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            ListNode* node = head;</span><br><span class="line"></span><br><span class="line">            node-&gt;next = res;</span><br><span class="line">            res = node;</span><br><span class="line"></span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>tip：之前头插法一直记错了，如果头结点没有数据的话，可以使用下面的操作</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">node-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = node;</span><br></pre></td></tr></table></figure><p>但是如果头结点有值，就要用下列的插入</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">node-&gt;next = head；</span><br><span class="line">head = node;</span><br></pre></td></tr></table></figure><h2 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h2><p>原地反转，用三个指针逆置</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *int val;</span></span><br><span class="line"><span class="comment"> *struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ListNode* p = head-&gt;next, *pre = head;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//第一个结点的next指针要预先处理，循环只能处理后面结点的next指针</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* tmp = p-&gt;next;</span><br><span class="line">            <span class="comment">//反转</span></span><br><span class="line">            p-&gt;next = pre;</span><br><span class="line"></span><br><span class="line">            pre = p;</span><br><span class="line">            p = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法4"><a href="#解法4" class="headerlink" title="解法4"></a>解法4</h2><p>使用递归解决</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param head ListNode类</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* cur_next = head-&gt;next;</span><br><span class="line">        ListNode* newHead = <span class="built_in">ReverseList</span>(cur_next);</span><br><span class="line">        cur_next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;给定一个单链表的头结点&lt;code&gt;pHead&lt;/code&gt;(该头节点是有值的，比如在下图，它的&lt;code&gt;val&lt;/code&gt;是1)，长度为</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://ruvikm.gitee.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>JZ6 从尾到头打印链表</title>
    <link href="https://ruvikm.gitee.io/2023/11/15/JZ6%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://ruvikm.gitee.io/2023/11/15/JZ6%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</id>
    <published>2023-11-15T12:15:13.000Z</published>
    <updated>2023-11-19T12:58:04.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</p><p>如输入{1,2,3}的链表如下图:</p><p><img src="https://z1.ax1x.com/2023/11/19/piUE8bR.png" alt="103D87B58E565E87DEFA9DD0B822C55F"></p><p>返回一个数组为[3,2,1]</p><p>0 &lt;= 链表长度 &lt;= 10000</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[3,2,1]</span><br></pre></td></tr></table></figure><h2 id="算法思路1"><a href="#算法思路1" class="headerlink" title="算法思路1"></a>算法思路1</h2><p>主要考察翻转数组的操作，把链表的数据放到数组里，然后在数组里操作，一个比较简单的操作是调用C++的库函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vt;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            vt.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(vt.<span class="built_in">begin</span>(),vt.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> vt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="算法思路2"><a href="#算法思路2" class="headerlink" title="算法思路2"></a>算法思路2</h2><p>使用递归的方式解决，递归出口是链表循环到末尾，每次递归做的事就是把当前结点的值放到<code>vector</code>容器中，由于递归到末尾才会开始存放结点（<code>res.push_back(head-&gt;val);</code>）的值，时间顺序正好为从后往前的存放，符合题目要求的逆序</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(ListNode* head,vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">reverse</span>(head-&gt;next,res);</span><br><span class="line">            res.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">reverse</span>(head,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。&lt;/p&gt;
&lt;p&gt;如输入{1,2,3}的链表如下图:&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://ruvikm.gitee.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Win11配置多个CUDA环境</title>
    <link href="https://ruvikm.gitee.io/2023/09/30/Win11%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AACUDA%E7%8E%AF%E5%A2%83/"/>
    <id>https://ruvikm.gitee.io/2023/09/30/Win11%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AACUDA%E7%8E%AF%E5%A2%83/</id>
    <published>2023-09-30T01:25:18.000Z</published>
    <updated>2023-09-30T04:13:35.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>由于跑项目发现需要配置不同版本的Pytorch，而不同版本的Pytorch又对应不同版本的CUDA，于是有了在Win上装多个CUDA的打算</p><p>默认已经在电脑上装了一个CUDA</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqY5Bd.png" alt="屏幕截图 2023-09-30 112423"></p><p>现在开始下载第二个CUDA版本，前面下载的操作和普通安装的几乎一样</p><h2 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h2><p><a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA下载链接</a></p><p>下载自己需要的CUDA版本，以我自己要安装的为例</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqlwXn.png" alt="屏幕截图 2023-09-30 095614"></p><p><img src="https://z1.ax1x.com/2023/09/30/pPqlD00.png" alt="屏幕截图 2023-09-30 095815"></p><p>下载打开exe文件进行安装，第一步不用管，直接点击确认</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqlWc9.png" alt="屏幕截图 2023-09-30 100402"></p><p>后面选择自定义安装，只选择安装CUDA</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqlfXR.png" alt="屏幕截图 2023-09-30 100534"></p><p>其他一路下一步就可以了</p><h2 id="安装cuDNN"><a href="#安装cuDNN" class="headerlink" title="安装cuDNN"></a>安装cuDNN</h2><p><a href="https://developer.nvidia.com/rdp/cudnn-archive">cuDNN下载链接</a></p><p>PS：下载需要登录一下账号</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqlchF.png" alt="屏幕截图 2023-09-30 100047"></p><p>下载下来后，把压缩包解压，得到如下文件</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqlq9e.png" alt="image-20230930100746137"></p><p>将<strong>bin，include文件夹中的文件</strong>，分别复制到下列地址对应的文件夹下（CUDA的安装地址，以我的地址为例），遇到提示，为全部选择覆盖和替换。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.7</span><br></pre></td></tr></table></figure><p>需要注意的是，lib文件夹里的所有文件，需要复制到</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.7\lib\x64</span><br></pre></td></tr></table></figure><p>至此，安装工作就做完了，可以看到电脑上已经有两个CUDA版本了</p><p><img src="https://z1.ax1x.com/2023/09/30/pPq3dZq.png" alt="image-20230930101157014"></p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>由于CUDA11.7是后面安装的，所以可以看到系统把之前的环境覆盖了</p><p><img src="https://z1.ax1x.com/2023/09/30/pPq3rJU.png" alt="屏幕截图 2023-09-30 103109"></p><p>以作者在为例，系统变量的PATH里配置一下路径</p><p><strong>CUDA_11.7</strong></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%CUDA_PATH_V11_7%\lib\x64</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_7%\include</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_7%\extras\CUPTI\lib64</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_7%\bin</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_7%\libnvvp</span></span><br></pre></td></tr></table></figure><p><strong>CUDA_11.0</strong></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%CUDA_PATH_V11_0%\lib\x64</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_0%\include</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_0%\extras\CUPTI\lib64</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_0%\bin</span></span><br><span class="line"><span class="comment">%CUDA_PATH_V11_0%\libnvvp</span></span><br></pre></td></tr></table></figure><p>配置好如下：</p><p><img src="https://z1.ax1x.com/2023/09/30/pPq3yz4.jpg" alt="微信截图_20230930105036"></p><p>配置好之后，默认CUDA版本是11.7的，如果要切换到11.0版本的，只需要把下面的五条整体上移到CUDA_11.7配置的前面</p><p><img src="https://z1.ax1x.com/2023/09/30/pPq3cQJ.jpg" alt="微信截图_20230930105411"></p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="测试CUDA11-7"><a href="#测试CUDA11-7" class="headerlink" title="测试CUDA11.7"></a>测试CUDA11.7</h3><p>首先验证CUDA_11.7是否配置成功</p><p><img src="https://z1.ax1x.com/2023/09/30/pPq8upF.png" alt="image-20230930105601201"></p><p>测试Pytorch是否可以调用显卡</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.cuda.is_available()</span><br><span class="line">torch.cuda.get_device_name(<span class="number">0</span>)</span><br><span class="line">torch.version.cuda</span><br></pre></td></tr></table></figure><p><img src="https://z1.ax1x.com/2023/09/30/pPqYiOH.png" alt="image-20230930120418607"></p><h3 id="测试CUDA11-0"><a href="#测试CUDA11-0" class="headerlink" title="测试CUDA11.0"></a>测试CUDA11.0</h3><p>先把系统变量里Path里相关路径上移</p><p><img src="https://z1.ax1x.com/2023/09/30/pPq8ZkV.jpg" alt="微信截图_20230930110409"></p><p><strong>然后重启！重启！重启！</strong></p><p>验证CUDA_11.7是否配置成功</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqGkge.png" alt="image-20230930112425329"></p><p>测试Pytorch是否可以调用显卡</p><p><img src="https://z1.ax1x.com/2023/09/30/pPqYkmd.png" alt="image-20230930112626663"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>切换CUDA的时候除了要修改系统变量Path中的路径顺序，一定要记得重启！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;由于跑项目发现需要配置不同版本的Pytorch，而不同版本的Pytorch又对应不同版本的CUDA，于是有了在Win上装多个CUDA的打算&lt;</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>学校GPU平台使用教程</title>
    <link href="https://ruvikm.gitee.io/2023/08/28/%E5%AD%A6%E6%A0%A1GPU%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://ruvikm.gitee.io/2023/08/28/%E5%AD%A6%E6%A0%A1GPU%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2023-08-28T01:18:54.000Z</published>
    <updated>2024-04-01T11:09:52.725Z</updated>
    
    <content type="html"><![CDATA[<p>首先连接内网登录<a href="http://paas.183-175-12-11.nip.io:30080/">平台</a></p><p>一般使用的话，直接找到<code>开发环境</code>一栏，创建环境。然后通过<code>Pycharm</code>中的<code>ssh</code>连接</p><p><img src="https://s1.ax1x.com/2023/08/28/pPaw2X6.png" alt="屏幕截图 2023-08-28 221321"></p><p>在<code>Pycharm</code>中，找到工具—部署—配置</p><p><img src="https://s1.ax1x.com/2023/08/28/pPad5zq.png" alt="image-20230828220300678"></p><p>点击<code>+</code>后选择<code>SFTP</code></p><p><img src="https://s1.ax1x.com/2023/08/28/pPaw5Ae.png" alt="屏幕截图 2023-08-28 221526"></p><p>在<code>SSH配置</code>那里后点击后面<code>...</code></p><p><img src="https://s1.ax1x.com/2023/08/28/pPawbct.png" alt="屏幕截图 2023-08-28 092517"></p><p>进入后填写主机名和用户名，这里详细讲一下</p><p>例如平台给的ssh连接是</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ssh://root@paas.xxx-xxx-xx-xx.nip.io:xxxxx</span><br></pre></td></tr></table></figure><p>这里用户名就需要填写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root</span><br></pre></td></tr></table></figure><p>主机名填写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">paas.xxx-xxx-xx-xx.nip.io</span><br></pre></td></tr></table></figure><p>端口号填写<code>xxxxx</code></p><p>然后填写创建环境时设置的密码</p><p><img src="https://s1.ax1x.com/2023/08/28/pPawjHS.png" alt="屏幕截图 2023-08-28 092917"></p><p>这一步完事以后，点击确定，返回到之前的页面，点击<code>映射</code></p><p><img src="https://s1.ax1x.com/2023/08/30/pPd7RaD.png" alt="屏幕截图 2023-08-30 145658"></p><p>配置好本机的地址和远程的地址，点击确认</p><p><img src="https://s1.ax1x.com/2023/08/30/pPd7LdS.png" alt="image-20230830145937224"></p><p>之后选择工具—部署—选项</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdHIkF.png" alt="QQ截图20230830150656"></p><p>可以根据自己习惯决定是否配置一下</p><p>然后找到工具—启动SSH会话，选择刚刚配置的SSH</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdbmtg.png" alt="屏幕截图 2023-08-30 151730"></p><p>然后输入</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.executable)</span><br></pre></td></tr></table></figure><p>记住输出的地址，比如我的就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usr/bin/python</span><br></pre></td></tr></table></figure><p>最后，找到项目—项目XXXX—Python解释器，找到添加解释器—SSH</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdHj0K.png" alt="image-20230830151124394"></p><p>选择刚刚配置的SSH服务器，然后下一步</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdbHUS.png" alt="屏幕截图 2023-08-30 152226"></p><p>点击下一步</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdbO3j.png" alt="image-20230830152644100"></p><p>然后选择<code>现有</code></p><p>把刚刚的地址输入到<code>解释器</code>里</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdqSbV.png" alt="image-20230830152826067"></p><p>点击确定就完事了</p><p><img src="https://s1.ax1x.com/2023/08/30/pPdqtqP.png" alt="image-20230830152939492"></p><p>之后用<code>工具</code>—<code>SSH会话</code>配合，就可以用学校的GPU跑程序了</p><p>tips：后期可以在服务器上安装<code>Anaconda</code>，然后把新建的虚拟环境中python路径配置到上述图片的<code>解释器</code>中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook --ip 0.0.0.0 --allow-root</span><br></pre></td></tr></table></figure><p>再补充一下，之前用conda的操作可能是麻烦了，服务器里自带好多python的环境，每个环境里也有很多自带的包</p><p><img src="https://z1.ax1x.com/2023/10/04/pPOHyIe.png" alt="屏幕截图 2023-10-04 204942"></p><p>选择例如选择python3.6后</p><p><img src="https://z1.ax1x.com/2023/10/04/pPOHgGd.png" alt="屏幕截图 2023-10-04 211210"></p><p>之后就《愉快》的调参吧，附一张成功用学校GPU跑代码的图片</p><p><img src="https://z1.ax1x.com/2023/10/04/pPOHqRs.png" alt="image-20231004211915616"></p><p> <strong>10.19继续补充一下</strong><br>有的项目跑起来需要运行作者的<code>run.sh</code>文件，这时候需要切换到项目的目录然后运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash run.sh</span><br></pre></td></tr></table></figure><p>但是环境默认是python2.7版本的，项目跑不起来，这时候需要切换python的环境</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whereis python</span><br><span class="line">rm /usr/bin/python</span><br><span class="line">ln -s /usr/bin/python3.6 /usr/bin/python</span><br></pre></td></tr></table></figure><p><img src="https://z1.ax1x.com/2023/10/19/piitih6.png" alt="image-20231019153231564"></p><p>还有一种方法，比如需要切换的环境在</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usr/bin/python3.6</span><br></pre></td></tr></table></figure><p>这时候需要在<code>.sh</code>文件中开头加上</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env python3.6</span></span><br></pre></td></tr></table></figure><p>可以在后面查看python环境</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python --version</span><br></pre></td></tr></table></figure><p><img src="https://z1.ax1x.com/2023/10/19/piir6K0.png" alt="image-20231019163749724"></p><p>这时候就切换了</p><p>2024-4-1补充</p><p>其实可以用Pycharm上传文件，然后用Xshell跑代码，Xshell配置和之前的大差不差</p><p><img src="https://s21.ax1x.com/2024/04/01/pF7gw01.png" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先连接内网登录&lt;a href=&quot;http://paas.183-175-12-11.nip.io:30080/&quot;&gt;平台&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一般使用的话，直接找到&lt;code&gt;开发环境&lt;/code&gt;一栏，创建环境。然后通过&lt;code&gt;Pycharm&lt;/code&gt;中的&lt;co</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>使用蓝牙外设却不小心把台式机电脑蓝牙关了</title>
    <link href="https://ruvikm.gitee.io/2023/08/12/%E4%BD%BF%E7%94%A8%E8%93%9D%E7%89%99%E5%A4%96%E8%AE%BE%E5%8D%B4%E4%B8%8D%E5%B0%8F%E5%BF%83%E6%8A%8A%E5%8F%B0%E5%BC%8F%E6%9C%BA%E7%94%B5%E8%84%91%E8%93%9D%E7%89%99%E5%85%B3%E4%BA%86/"/>
    <id>https://ruvikm.gitee.io/2023/08/12/%E4%BD%BF%E7%94%A8%E8%93%9D%E7%89%99%E5%A4%96%E8%AE%BE%E5%8D%B4%E4%B8%8D%E5%B0%8F%E5%BF%83%E6%8A%8A%E5%8F%B0%E5%BC%8F%E6%9C%BA%E7%94%B5%E8%84%91%E8%93%9D%E7%89%99%E5%85%B3%E4%BA%86/</id>
    <published>2023-08-12T09:43:40.000Z</published>
    <updated>2023-08-12T10:54:07.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>今天犯了一个贼SB的错误，起因是蓝牙键盘突然就不能输入了（虽然是连接状态，但是按什么键都没有反应）</p><p>原来我的解决方法就是重启一下电脑，但是那会电脑开了贼多的软件。我就想重启也太麻烦了，既然重启的本质也是重启蓝牙，那我要不直接就把蓝牙重启算了，当时想到这里啊，我心中一阵狂喜，觉得我真TMD是个天才</p><p>于是我兴冲冲的找到系统设置—蓝牙，把蓝牙关了，然后当我准备开启蓝牙的时候，我傻眼了，艹，我外设都是蓝牙连接的啊，这TM开不开了</p><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><h3 id="尝试用带USB接收器的鼠标"><a href="#尝试用带USB接收器的鼠标" class="headerlink" title="尝试用带USB接收器的鼠标"></a>尝试用带USB接收器的鼠标</h3><p>我的鼠标不仅可以蓝牙连接，还可以用USB接收器连接，我心想这不是轻轻松松简简单单。于是给鼠标换了一个连接方式，插入了USB接收器。但是奇怪的事情发生了，无论我怎么动鼠标，鼠标的指针就是纹丝不动。我怀疑难道是关了蓝牙功能，连这个都影响到了吗</p><h3 id="尝试用有线设备"><a href="#尝试用有线设备" class="headerlink" title="尝试用有线设备"></a>尝试用有线设备</h3><p>虽然心中有一丝紧张，但是我感觉这不就是个小事嘛，那要不找个有线的外设不就可以了。于是翻箱倒柜，刨出来家里的古董有线键盘，插入了电脑前面的USB口。</p><p>但是，重量级来了，无论按什么键，都没有反应，让我一度以为是不是键盘寄了。然后我把键盘插到了笔记本上，发现还是可以用的，灯也是亮的（但是刚刚插在台式机上灯就没亮）</p><p>前面不行，后面总可以吧，肯定么得问题（Flag立的飞起）我买的主板可是有7个USB插口呢！！！这么想着我钻到桌子下面，吸着尘土，一个一个试着USB口，结果是全都不能用。当时心态就发生了一丝变化，我看着屏幕，屏幕看着我，但是感觉我们之间隔了一个不可逾越的鸿沟，那个鸿沟就是USB口。</p><h3 id="尝试远程软件"><a href="#尝试远程软件" class="headerlink" title="尝试远程软件"></a>尝试远程软件</h3><p>我逐渐意识到了问题的严重性，但我灵机一动，心想不还有远程软件么，用手机作为输入不就解决了。</p><p>我再次满怀希望的打开手机远程操作APP，在“我的设备”里寻找台式机，但是，咚咚咚！！！设备显示是离线状态，这我才想起来之前为了优化开机，把这个软件的开机自启给关了，我又傻眼了。</p><h3 id="分析现状"><a href="#分析现状" class="headerlink" title="分析现状"></a>分析现状</h3><p>现在的问题是，台式机蓝牙关了，但是我的常用外设都是蓝牙连接的，没有有线功能。我有一个有线键盘，但是台式机的USB口不知道为什么全不能用了，这就意味着即使我有有线鼠标理论上也没有用。远程软件也没有开启，不用通过手机远程把蓝牙打开。</p><h3 id="扣电池"><a href="#扣电池" class="headerlink" title="扣电池"></a>扣电池</h3><p>和卖主板的客服沟通后，建议我扣主板电池试试。关机后，等待5min后（为了放干净电），我把电池扣了下来，又等了3min左右装了上去。奇迹发生了，USB口能用了！！！于是我用键盘操作（一路按tab键）这找到了蓝牙的开关按钮，</p><p><img src="https://s1.ax1x.com/2023/08/12/pPu8BIP.png" alt="屏幕截图 2023-08-12 181458"></p><p>按空格打开了蓝牙的开关，至此，终于是解决了！！！</p><p>PS：如果不知道用空格是确认，当时用键盘打开我的远程软件其实也解决了</p><h2 id="反思及预防"><a href="#反思及预防" class="headerlink" title="反思及预防"></a>反思及预防</h2><p>三思而后行啊，<del>以及中午不能睡时间太长</del></p><h3 id="关闭蓝牙功能影响USB接收器的使用吗"><a href="#关闭蓝牙功能影响USB接收器的使用吗" class="headerlink" title="关闭蓝牙功能影响USB接收器的使用吗"></a>关闭蓝牙功能影响USB接收器的使用吗</h3><p>之后又专门把蓝牙关了，使用带USB接收器的鼠标连接，发现可以正常使用。看来问题就出在USB接口上了</p><h3 id="为什么USB接口不能用"><a href="#为什么USB接口不能用" class="headerlink" title="为什么USB接口不能用"></a>为什么USB接口不能用</h3><p>然后网上查到了USB口之前为什么不能用的原因及解决方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了省电，Windows默认情况下会在不使用USB控制器时将其关闭，在需要时再将其重新开启。但有时候Windows不会自动开启。</span><br><span class="line">1、右键单击开始菜单，打开设备管理器。</span><br><span class="line">2、双击展开“通用串行总线控制器”一栏。</span><br><span class="line">3、双击列表中的第一个“USB根集线器”。</span><br><span class="line">4、点击切换到“电源管理”标签页。</span><br><span class="line">5、取消勾选“允许计算机关闭此设备以节省电源”，点击“确定”。</span><br><span class="line">6、对通用串行总线控制器列表中的每个“USB根集线器”重复步骤3-5。</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/08/12/pPu8haq.png" alt="image-20230812182055614"></p><p>按照教程把上面一个一个都关了就好了</p><h3 id="打开远程软件的自启"><a href="#打开远程软件的自启" class="headerlink" title="打开远程软件的自启"></a>打开远程软件的自启</h3><p>由于也没啥重要的东西，就把软件自启打开了。再也不想为了一点优化差点坑死自己了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;今天犯了一个贼SB的错误，起因是蓝牙键盘突然就不能输入了（虽然是连接状态，但是按什么键都没有反应）&lt;/p&gt;
&lt;p&gt;原来我的解决方法就是重启一</summary>
      
    
    
    
    <category term="个人笔记" scheme="https://ruvikm.gitee.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
