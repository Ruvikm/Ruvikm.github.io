<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>2021王道数据结构——线性表课后大题 | Ruvikm</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="线性表的顺序表示课后大题——P19–P21有几个必须掌握的算法  归并排序 P19.7 P20.11 用空间换时间——有n个元素就开一个大小为n的数组 P20.12 P21.13 离散数学中的 P19.8 P20.10  全部代码如下，代码中已给出题目 #include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&amp;gt">
<meta property="og:type" content="article">
<meta property="og:title" content="2021王道数据结构——线性表课后大题">
<meta property="og:url" content="https://ruvikm.github.io/2022/01/10/2021%E7%8E%8B%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8%E8%AF%BE%E5%90%8E%E5%A4%A7%E9%A2%98_1/index.html">
<meta property="og:site_name" content="Ruvikm">
<meta property="og:description" content="线性表的顺序表示课后大题——P19–P21有几个必须掌握的算法  归并排序 P19.7 P20.11 用空间换时间——有n个元素就开一个大小为n的数组 P20.12 P21.13 离散数学中的 P19.8 P20.10  全部代码如下，代码中已给出题目 #include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&amp;gt">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201029193736874.png#pic_center">
<meta property="article:published_time" content="2022-01-10T11:22:30.000Z">
<meta property="article:modified_time" content="2022-01-10T11:30:54.463Z">
<meta property="article:author" content="Ruvikm">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20201029193736874.png#pic_center">
  
    <link rel="alternate" href="/atom.xml" title="Ruvikm" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.0.0-rc1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ruvikm</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://ruvikm.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2021王道数据结构——线性表课后大题_1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/10/2021%E7%8E%8B%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8%E8%AF%BE%E5%90%8E%E5%A4%A7%E9%A2%98_1/" class="article-date">
  <time datetime="2022-01-10T11:22:30.000Z" itemprop="datePublished">2022-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      2021王道数据结构——线性表课后大题
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>线性表的顺序表示课后大题——P19–P21</strong><br>有几个必须掌握的算法</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/124356219">归并排序</a><br> P19.7<br> P20.11</li>
<li>用空间换时间——有n个元素就开一个大小为n的数组<br> P20.12<br> P21.13</li>
<li>离散数学中的<img src="https://img-blog.csdnimg.cn/20201029193736874.png#pic_center" alt="矩阵的预算规则"><br> P19.8<br> P20.10</li>
</ol>
<p><strong>全部代码如下，代码中已给出题目</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _for(i,a,b) for( int i=(a); i&lt;(b); ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _rep(i,a,b) for( int i=(a); i&lt;=(b); ++i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> data[MAX];</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;List;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	t = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定一个List，传入List的大小，要逆转的起始位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reserve</span><span class="params">(List* list, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (end &lt;= start || end &gt;= size) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">	_rep(i, <span class="number">0</span>, mid - start) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(&amp;list-&gt;data[start + i], &amp;list-&gt;data[end - i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*  _for(i, 0, list-&gt;length) &#123;</span></span><br><span class="line"><span class="comment">		  printf(&quot;%d &quot;, list-&gt;data[i]);</span></span><br><span class="line"><span class="comment">	  &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P19.1</span></span><br><span class="line"><span class="comment">//从顺序表中删除具有最小值的元素(假设唯一)并由函数返回被删元素的值。空出的位</span></span><br><span class="line"><span class="comment">//置由最后一个元素填补, 若顺序表为空则显示出错信息并退出运行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindMin</span><span class="params">(List* list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(*list).length) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> Min = <span class="number">9999</span>;</span><br><span class="line">	<span class="type">int</span> point;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (*list).length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((*list).data[i] &lt; Min)</span><br><span class="line">		&#123;</span><br><span class="line">			Min = (*list).data[i];</span><br><span class="line">			point = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	(*list).data[point] = (*list).data[(*list).length - <span class="number">1</span>];</span><br><span class="line">	(*list).length -= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> Min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P19.2</span></span><br><span class="line"><span class="comment">//设计一个高效算法，将顺序表的所有元素逆置，要求算法的空间复杂度为O⑴</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(List* list)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!list-&gt;length)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (*list).length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(&amp;(list-&gt;data[i]), &amp;(list-&gt;data[list-&gt;length - i - <span class="number">1</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P19.3</span></span><br><span class="line"><span class="comment">//对长度为n的顺序表L, 编写一个时间复杂度为O(m)空间复杂度为O(1)的算法,</span></span><br><span class="line"><span class="comment">//该算法删除线性表中所有值为x的数据元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteX</span><span class="params">(List* list, <span class="type">int</span> X)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (*list).length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((*list).data[i] == X) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; (*list).length; j++) &#123;</span><br><span class="line">				(*list).data[j - <span class="number">1</span>] = (*list).data[j];</span><br><span class="line">			&#125;</span><br><span class="line">			(*list).length -= <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P19.4</span></span><br><span class="line"><span class="comment">//从有序顺序表中删除其值在给定值s与t之间(要求s &lt; t)的所有元素, 如果s或t不合</span></span><br><span class="line"><span class="comment">//理或顺序表为空, 则显示出错信息并退出运行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OrderlyDelete</span><span class="params">(List* list, <span class="type">int</span> X, <span class="type">int</span> T)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i; i &lt; (*list).length; i++)</span><br><span class="line">		<span class="keyword">if</span> ((*list).data[i] &gt;= X)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (j; j &lt; (*list).length; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((*list).data[j] &gt; T)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> len = j - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i; i &lt; (*list).length; i++, j++) &#123;</span><br><span class="line">		list-&gt;data[i] = list-&gt;data[j];</span><br><span class="line">	&#125;</span><br><span class="line">	list-&gt;length -= len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P19.5</span></span><br><span class="line"><span class="comment">//从顺序表中删除其值在给定值s与t之间(包含s和t, 要求s &lt; t)的所有元素,</span></span><br><span class="line"><span class="comment">//如果s或t不合理或顺序表为空, 则显示出错信息并退出运行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteS_T</span><span class="params">(List* list, <span class="type">int</span> S, <span class="type">int</span> T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (S &gt;= T || !list-&gt;length)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (*list).length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((*list).data[i] &gt;= S &amp;&amp; (*list).data[i] &lt;= T) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; (*list).length; j++) &#123;</span><br><span class="line">				(*list).data[j - <span class="number">1</span>] = (*list).data[j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//要重新回退一个位置，重新检测，否则会跳过某些数字</span></span><br><span class="line">			<span class="keyword">if</span> (i)</span><br><span class="line">				i -= <span class="number">1</span>;</span><br><span class="line">			(*list).length -= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P19.6</span></span><br><span class="line"><span class="comment">//从有序顺序表中删除所有其值重复的元素,使表中所有元素的值均不同</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OlderlyDeleteSame</span><span class="params">(List* list)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list-&gt;length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (list-&gt;data[i + <span class="number">1</span>] == list-&gt;data[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; list-&gt;length; j++) &#123;</span><br><span class="line">				list-&gt;data[j] = list-&gt;data[j + <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			list-&gt;length -= <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i)</span><br><span class="line">				i -= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P19.7</span></span><br><span class="line"><span class="comment">//将两个有序顺序表合并为一个新的有序顺序表, 并由函数返回结果顺序表</span></span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">MergeList</span><span class="params">(List A, List B)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	List C;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; A.length &amp;&amp; j &lt; B.length) &#123;</span><br><span class="line">		<span class="keyword">if</span> (A.data[i] &gt;= B.data[j]) &#123;</span><br><span class="line">			C.data[k++] = B.data[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			C.data[k++] = A.data[i++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; A.length) &#123;</span><br><span class="line">		C.data[k++] = A.data[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; B.length) &#123;</span><br><span class="line">		C.data[k++] = B.data[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	C.length = k;</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P19.8</span></span><br><span class="line"><span class="comment">//已知在一维数组A[m + n]中依次存放两个线性表(a1, a2, a3…, am)和(b, b2, b3, …, bn)。试编</span></span><br><span class="line"><span class="comment">//写一个函数, 将数组中两个顺序表的位置互换, 即将(b1,b2,b3,…, bn)放在(a1，a2, a3, …, am)的前面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swaplist</span><span class="params">(List* A, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">Reserve</span>(A, <span class="number">0</span>, m + n - <span class="number">1</span>, size);</span><br><span class="line">	<span class="built_in">Reserve</span>(A, <span class="number">0</span>, n - <span class="number">1</span>, size);</span><br><span class="line">	<span class="built_in">Reserve</span>(A, n, m + n - <span class="number">1</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P20.9线性表(a1,a2,a3,..,an)中的元素递增有序且按顺序存储于计算机内。</span></span><br><span class="line"><span class="comment">//要求设计一算法, 完成用最少时间在表中查找数值为x的元素, 若找到则将其与后继元素位置相交换,</span></span><br><span class="line"><span class="comment">//若找不到则将其插入表中并使表中元素仍递增有序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我的方法 大力出奇迹</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckAndSwap</span><span class="params">(List* A, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	_for(i, <span class="number">0</span>, A-&gt;length) &#123;</span><br><span class="line">		<span class="keyword">if</span> (A-&gt;data[i] == x) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(&amp;A-&gt;data[i], &amp;A-&gt;data[i + <span class="number">1</span>]);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Find it\n&quot;</span>);</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Not find\n&quot;</span>);</span><br><span class="line">		<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; A-&gt;length &amp;&amp; A-&gt;data[i] &lt;= x; i++);</span><br><span class="line">		<span class="keyword">if</span> (i &lt; A-&gt;length)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = A-&gt;length; j &gt;= i; j--) &#123;</span><br><span class="line">				A-&gt;data[j + <span class="number">1</span>] = A-&gt;data[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		A-&gt;data[i] = x;</span><br><span class="line">		A-&gt;length += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//答案方法 折半查找</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SearchExchangeInsert</span><span class="params">(List* A, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> low = <span class="number">0</span>, mid = A-&gt;length / <span class="number">2</span>, high = A-&gt;length - <span class="number">1</span>;</span><br><span class="line">	<span class="type">bool</span> Isfind = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">		mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (x == A-&gt;data[mid]) &#123;</span><br><span class="line">			Isfind = <span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Find\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; A-&gt;data[mid]) &#123;</span><br><span class="line">			low = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; A-&gt;data[mid]) &#123;</span><br><span class="line">			high = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (Isfind &amp;&amp; mid != A-&gt;length - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Swap\n&quot;</span>);</span><br><span class="line">		<span class="built_in">swap</span>(&amp;A-&gt;data[mid], &amp;A-&gt;data[mid + <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!Isfind) &#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, low);</span><br><span class="line">		<span class="keyword">for</span> (i = A-&gt;length - <span class="number">1</span>; i &gt; high; i--) &#123;</span><br><span class="line">			A-&gt;data[i + <span class="number">1</span>] = A-&gt;data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		A-&gt;data[i + <span class="number">1</span>] = x;</span><br><span class="line">		A-&gt;length += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P20.10</span></span><br><span class="line"><span class="comment">//〖2010统考真题〗设将n(n &gt; 1)个整数存放到一维数组R中。设计一个在时间和空间两</span></span><br><span class="line"><span class="comment">//方面都尽可能高效的算法。将R中保存的序列循环左移p(0&lt;p&lt;n)个位置, 即将R中的</span></span><br><span class="line"><span class="comment">//	数据由(X0,X1,…,Xn-1)变换为(Xp+Xp+1…,Xn-1,X0,X1…,Xp - 1)。要求</span></span><br><span class="line"><span class="comment">//	1)给出算法的基本设计思想</span></span><br><span class="line"><span class="comment">//	2)根据设计思想, 采用C或C++ + 或Java语言描述算法, 关键之处给出注释</span></span><br><span class="line"><span class="comment">//	3)说明你所设计算法的时间复杂度和空间复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveList</span><span class="params">(List* list, <span class="type">int</span> MoveStep)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//BA=(A^-1*B^-1)^-1</span></span><br><span class="line">	<span class="built_in">Reserve</span>(list, <span class="number">0</span>, MoveStep - <span class="number">1</span>, MAX);</span><br><span class="line">	<span class="built_in">Reserve</span>(list, MoveStep, list-&gt;length - <span class="number">1</span>, MAX);</span><br><span class="line">	<span class="built_in">Reserve</span>(list, <span class="number">0</span>, list-&gt;length - <span class="number">1</span>, MAX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P20.11</span></span><br><span class="line"><span class="comment">//〖2011统考真题】一个长度为L(L≥1)的升序序列S, 处在第[L/2]个位置的数称为S的</span></span><br><span class="line"><span class="comment">//中位数。例如, 若序列S1 = (1, 13, 15, 17, 19), 则S1的中位数是15, 两个序列的中位数</span></span><br><span class="line"><span class="comment">//是含它们所有元素的升序序列的中位数。例如, 若S2 = (2, 4, 6, 8, 20), 则S1和S2的中位</span></span><br><span class="line"><span class="comment">//数是11。现在有两个等长升序序列A和B, 试设计一个在时间和空间两方面都尽可能</span></span><br><span class="line"><span class="comment">//高效的算法, 找出两个序列A和B的中位数。要求</span></span><br><span class="line"><span class="comment">//1)给出算法的基本设计思想</span></span><br><span class="line"><span class="comment">//2)根据设计思想, 采用C或C++或Java语言描述算法, 关键之处给出注释</span></span><br><span class="line"><span class="comment">//3)说明你所设计算法的时间复杂度和空间复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改编的归并排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindMid</span><span class="params">(List A, List B)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i + j != (A.length + B.length) / <span class="number">2</span> - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (A.data[i] &lt;= B.data[j]) &#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> A.data[i] &lt; B.data[j] ? A.data[i] : B.data[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P20.12</span></span><br><span class="line"><span class="comment">//〖2013统考真题〗已知一个整数序列A = (a0, a1…, an-1), 其中0 ≤ ai &lt; n(0 ≤i &lt; n)。若</span></span><br><span class="line"><span class="comment">//	存在 ap1 = ap2 = ... = apm = x 且 m &gt; n / 2   (0≤ Pk &lt; n,1≤ k ≤ m), 则称x为A的主元素。</span></span><br><span class="line"><span class="comment">//	例如A=(0,5,5,3,5,7,5,5)，则5为主元素; 又如A = (0, 5, 5, 3, 5, 1, 5, 7), 则A中没有主</span></span><br><span class="line"><span class="comment">//	元素。假设A中的n个元素保存在一个一维数组中, 请设计一个尽可能高效的算法, 找</span></span><br><span class="line"><span class="comment">//	出A的主元素。若存在主元素, 则输岀该元素; 否则输出 - 1。要求:</span></span><br><span class="line"><span class="comment">//1)给出算法的基本设计思想</span></span><br><span class="line"><span class="comment">//2)根据设计思想, 采用C或C十或Java语言描述算法, 关键之处给出注释</span></span><br><span class="line"><span class="comment">//3)说明你所设计算法的时间复杂度和空间复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//次优算法，用空间换时间，类似桶排</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">FindMain</span><span class="params">(List A, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> m_num = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span>* Box = <span class="keyword">new</span> <span class="type">int</span>[n](); <span class="comment">//动态申请一个大小为n的数组</span></span><br><span class="line">	_for(i, <span class="number">0</span>, A.length) &#123;</span><br><span class="line">		Box[A.data[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	_for(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Box[i] &gt; n / <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> A.data[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P21.13</span></span><br><span class="line"><span class="comment">//〖2018统考真题】给定一个含n(n≥1)个整数的数组, 请设计一个在时间上尽可能高效</span></span><br><span class="line"><span class="comment">//的算法, 找出数组中未出现的最小正整数。例如, 数组&#123; -5,3,2,3 &#125;中未出现的最小正整数</span></span><br><span class="line"><span class="comment">//是1; 数组&#123; 1,2,3 &#125;中未出现的最小正整数是4。要求</span></span><br><span class="line"><span class="comment">//1)给出算法的基本设计思想</span></span><br><span class="line"><span class="comment">//2)根据设计思想, 采用C或C艹语言描述算法, 关键之处给出注释</span></span><br><span class="line"><span class="comment">//3)说明你所设计算法的时间复杂度和空间复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用空间换时间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindMinNum</span><span class="params">(List A, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>* Box = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>]();</span><br><span class="line">	_for(i, <span class="number">0</span>, A.length) &#123;</span><br><span class="line">		<span class="keyword">if</span> (A.data[i] &gt; <span class="number">0</span> &amp;&amp; A.data[i] &lt;= n)</span><br><span class="line">			Box[A.data[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	_for(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!Box[i])</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	List list1;</span><br><span class="line">	List list2;</span><br><span class="line">	list1.length = <span class="number">4</span>;</span><br><span class="line">	list2.length = <span class="number">5</span>;</span><br><span class="line">	<span class="type">int</span> Data1[] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="type">int</span> Data2[] = &#123; <span class="number">22</span>,<span class="number">43</span>,<span class="number">64</span>,<span class="number">87</span>,<span class="number">180</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list1.length; i++)</span><br><span class="line">		list1.data[i] = Data1[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list2.length; i++)</span><br><span class="line">		list2.data[i] = Data2[i];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">FindMinNum</span>(list1, <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/Ruvikm/Wangdao-Data-Structures">源代码链接</a></p>
<p>如有不足，请多多指教~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ruvikm.github.io/2022/01/10/2021%E7%8E%8B%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8%E8%AF%BE%E5%90%8E%E5%A4%A7%E9%A2%98_1/" data-id="clhyqpa1c0007hovg02ncbzew" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/01/10/C_C++%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8C%96for%E5%BE%AA%E7%8E%AF/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          C_C++用宏定义简化for循环
        
      </div>
    </a>
  
  
    <a href="/2022/01/10/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E4%BD%BF%E7%94%A8C_C++%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">使用C/C++实现进程调度算法</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B6%E4%BB%96/" rel="tag">其他</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/java/" style="font-size: 16.67px;">java</a> <a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 13.33px;">其他</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 10px;">微信小程序</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/01/10/hexo-%E6%9C%AC%E5%9C%B0%E6%98%BE%E7%A4%BA%E9%83%A8%E7%BD%B2%E5%90%8E%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2%E6%9C%AA%E6%9B%B4%E6%96%B0%EF%BC%88Github%E5%B7%B2%E6%9B%B4%E6%96%B0%EF%BC%89/">hexo 本地显示部署后博客页面未更新（Github已更新）</a>
          </li>
        
          <li>
            <a href="/2022/01/10/%E7%8E%8B%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E7%BA%BF%E6%80%A7%E8%A1%A8%20%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%B0%8F%E7%BB%93/">王道数据结构 线性表 链式存储小结</a>
          </li>
        
          <li>
            <a href="/2022/01/10/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%20C_C++/">斐波那契数列 C_C++</a>
          </li>
        
          <li>
            <a href="/2022/01/10/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">算法期末复习</a>
          </li>
        
          <li>
            <a href="/2022/01/10/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">软件体系结构基本知识——期末复习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Ruvikm<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>